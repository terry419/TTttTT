# 최종 구현 계획서 (v8.0) - 통합 인스펙터 아키텍처

이 문서는 '통합 인스펙터' 워크플로우를 중심으로, 자동화 검증, 리스크 관리, 상세 추적성을 포함한 최종 실행 계획서입니다.

## **전역 목표**
- **테스트 커버리지:** 단위 테스트 80%+, 통합 테스트 60%+, E2E 테스트 90%+
- **성능:** 게임 플레이 중 GC.Alloc ≤ 1KB/sec, 평균 60 FPS 유지

---

### **0.5단계: 환경 설정 및 자동화 기반 구축**
- **업무 내용:** Addressable 그룹 구조 확정, `DebugManager` 작성, Unity Test Runner 설정.
- **강화 사항:** 에셋 관리 충돌 방지 및 빌드 프로세스 안정화.
- **출력:** Addressable 그룹 구조, `DebugManager.cs`, Unity Test Runner 설정.
- **검증 방법:** "data_effect" 그룹 에셋 수 자동화 테스트, 개발/릴리즈 빌드 로그 유무 단위 테스트.
- **리스크 관리:**
    - **선행 조건:** 없음.
    - **완료 조건:** 단위 테스트로 `DebugManager`의 릴리즈 빌드 로그 미출력 검증 통과.
    - **실패 시나리오:** 릴리즈 빌드에서 로그 발생 시 → `DebugManager`의 `[Conditional]` 구문 확인.
- **디버그 체크포인트:** `Log.Print("[CHK0.5<Setup><Complete>] Environment and automation foundation verified.");`

---

### **1단계: 아키텍처 기반 인터페이스 및 데이터 설계**
- **업무 내용:**
    1. 모든 기능 모듈이 구현할 `IPlatformModule.cs` 인터페이스 정의.
    2. 데이터 전달 객체 `EffectContext.cs` 및 재사용을 위한 `EffectContextPool.cs` 작성.
    3. 발사 사양을 구조체로 묶을 `FiringSpec.cs` 작성.
- **강화 사항:** `EffectContext` 풀링으로 GC 부담 감소, 명확한 인터페이스와 데이터 구조 정의.
- **출력:** `IPlatformModule.cs`, `EffectContext.cs`, `EffectContextPool.cs`, `FiringSpec.cs`.
- **검증 방법:** 풀 재사용률 99% 이상 프로파일링 검증, `Reset()` 호출 횟수 단위 테스트 검증.
- **리스크 관리:**
    - **선행 조건:** 0.5단계 완료.
    - **완료 조건:** 프로파일링 및 단위 테스트 통과.
    - **실패 시나리오:** 풀 재사용률 저하 시 → `EffectContext` 반환 로직 누락 확인.
- **디버그 체크포인트:** `Log.Print("[CHK1<Architecture><Complete>] Core interfaces and context pool verified.");`

---

### **2단계: 모듈러 플랫폼(CardDataSO) 설계**
- **업무 내용:**
    1. `CardDataSO`가 '모듈러 플랫폼' 역할을 하도록 구조 개편.
    2. **기본 발사 패턴(`projectileCount`, `spreadAngle`) 및 `preloadCount`, `baseDamage` 필드 추가.**
    3. 발사 사양을 묶어 반환하는 `FiringSpec GetFiringSpecs()` 헬퍼 메소드 구현.
    4. **모듈 조립을 위한 `List<ModuleEntry> modules` 필드 추가. (`ModuleEntry`는 `moduleType` enum, `AssetReferenceT<IPlatformModule>` 등을 포함)**
- **강화 사항:** `CardDataSO`가 플랫폼으로서 발사, 옵션 조립, 프리로드 정보까지 모두 책임지는 명확한 구조.
- **출력:** 수정된 `CardDataSO.cs` 및 `ModuleEntry.cs`.
- **검증 방법:** `CardDataSO` 에셋 생성 시, 인스펙터에 신규 필드들이 정상적으로 표시되는지 확인.
- **리스크 관리:**
    - **선행 조건:** 1단계 완료.
    - **완료 조건:** `CardDataSO` 인스펙터 정상 표시 확인.
    - **실패 시나리오:** 필드 누락 시 → `CardDataSO.cs` 코드의 변수 선언 확인.
- **디버그 체크포인트:** `Log.Print("[CHK2<CardDataSO><Complete>] Modular platform (CardDataSO) structure verified.");`

---

### **3단계: 통합 인스펙터(CardDataSOEditor) 개발**
- **업무 내용:**
    1. `CardDataSO`의 인스펙터를 커스터마이징하는 `CardDataSOEditor.cs` 에디터 스크립트 작성.
    2. **`modules` 리스트의 각 `ModuleEntry`를 Foldout으로 표시하고, 펼쳤을 때 참조된 모듈(`...EffectSO`)의 모든 필드를 인라인으로 편집할 수 있도록 `Editor.CreateEditor`를 활용하여 구현.**
- **강화 사항:** 모든 카드 관련 작업을 단일 인스펙터에서 처리하여 작업 효율 및 편의성 극대화.
- **출력:** `Editor/CardDataSOEditor.cs`.
- **검증 방법:** `CardDataSO` 에셋을 선택했을 때, 기본 인스펙터 대신 새로 설계된 커스텀 인스펙터가 표시되는지 확인. 모듈의 세부 내용을 수정하고 저장했을 때, 원본 에셋 파일에 변경사항이 반영되는지 확인.
- **리스크 관리:**
    - **선행 조건:** 2단계 완료.
    - **완료 조건:** 커스텀 인스펙터 기능 완전성 검증.
    - **실패 시나리오:** 인라인 편집 미작동 시 → `Editor.CreateEditor` 로직 및 `SerializedObject`의 `ApplyModifiedProperties` 호출 누락 확인.
- **디버그 체크포인트:** `Log.Print("[CHK3<Inspector><Complete>] Unified inspector for CardDataSO verified.");`

---

### **4단계: 기능 모듈(CardEffectSO) 구현**
- **업무 내용:** `IPlatformModule`을 구현하는 `CardEffectSO` 추상 클래스와, 그 자식 클래스인 8개의 옵션 모듈 스크립트 작성 (`Projectile`, `Area`, `Status`, `Lifesteal`, `ApplyBuffToCaster`, `Random`, `Conditional`).
- **강화 사항:** 각 모듈이 자신의 고유 데이터와 기능에만 집중하는 명확한 역할 분리.
- **출력:** 8개의 `...EffectSO.cs` 모듈 스크립트.
- **검증 방법:** 에디터 스크립트로 모든 모듈 에셋의 필수 필드 `null` 여부 자동 검사.
- **리스크 관리:**
    - **선행 조건:** 3단계 완료.
    - **완료 조건:** 에디터 `null` 검사 통과.
    - **실패 시나리오:** `null` 검출 시 → 해당 모듈 에셋의 인스펙터 설정 확인 알림.
- **디버그 체크포인트:** `Log.Print("[CHK4<Modules><Complete>] All feature modules (EffectSOs) implemented and verified.");`

---

### **5단계: 비동기 데이터 로딩 및 모니터링**
- **업무 내용:** `DataManager`가 `AssetReference`를 비동기 로드하고, 실패 시 외부 알림을 보내도록 수정.
- **강화 사항:** 런타임 안정성 확보 및 신속한 이슈 파악.
- **출력:** 수정된 `DataManager.cs`, 모니터링 알림 스크립트.
- **검증 방법:** 로드 실패용 더미 에셋으로 알림 발송 자동화 테스트.
- **리스크 관리:**
    - **선행 조건:** 4단계 완료.
    - **완료 조건:** 모니터링 테스트 통과.
    - **실패 시나리오:** 알림 미수신 시 → API Key 및 네트워크 설정, `catch` 블록 호출 여부 확인.
- **디버그 체크포인트:** `Log.Print("[CHK5<DataManager><Complete>] Asynchronous data loading and error handling verified.");`

---

### **6단계: 프리로드 시스템 및 물리 레이어 설정**
- **업무 내용:**
    1. `GameManager.PreloadAssetsForRound`가 `CardDataSO.modules`를 순회하며, 각 모듈의 프리팹을 `preloadCount`만큼 `PoolManager`에 등록하도록 구현.
    2. 플레이어 투사체와 몬스터가 충돌할 Physics2D 레이어 및 충돌 매트릭스 설정.
- **강화 사항:** 로딩 지연 방지 및 물리 연산 최적화.
- **출력:** 수정된 `GameManager.cs`, Physics2D 레이어 설정.
- **검증 방법:** 프리로드 시간 500ms 이하 부하 테스트, 풀 크기 단위 테스트, 레이어 충돌 단위 테스트.
- **리스크 관리:**
    - **선행 조건:** 5단계 완료.
    - **완료 조건:** 모든 자동화/부하 테스트 통과.
    - **실패 시나리오:** 프리로드 시간 초과 시 → 에셋 용량 및 `preloadCount` 검토. / 충돌 미발생 시 → 레이어 설정 및 충돌 매트릭스 확인.
- **디버그 체크포인트:** `Log.Print("[CHK6<Preload_Physics><Complete>] Preload system and physics layers verified.");`

---

### **7단계: 효과 실행 엔진(EffectExecutor) 재구축**
- **업무 내용:** `EffectExecutor`가 `CardDataSO.GetFiringSpecs()`를 호출하여 발사 정보를 얻고, `modules` 리스트의 모듈들을 실행하도록 재구축.
- **강화 사항:** `EffectExecutor`의 책임이 '실행 요청'으로 단순화되어 유지보수성 극대화.
- **출력:** 수정된 `EffectExecutor.cs`.
- **검증 방법:** 실행 순서 자동화 검증용 시퀀스 차트 기록 및 비교.
- **리스크 관리:**
    - **선행 조건:** 6단계 완료.
    - **완료 조건:** 시퀀스 검증 테스트 통과.
    - **실패 시나리오:** 시퀀스 불일치 시 → `EffectExecutor`의 모듈 순회 및 트리거 처리 로직 디버깅.
- **디버그 체크포인트:** `Log.Print("[CHK7<EffectExecutor><Complete>] Effect execution engine refactoring verified.");`

---

### **8단계: 지능형 투사체(BulletController) 구현**
- **업무 내용:** `sequentialPayloads` 매핑 알고리즘 및 중복 히트 방지 로직(`RegisterHitByShot`) 구현.
- **강화 사항:** 복잡한 연쇄 효과 및 중복 타격 방지 제어 가능.
- **출력:** 수정된 `BulletController.cs`.
- **검증 방법:** 튕김/페이로드 실행 로그 자동 검증, 샷건 발사 시 단일 몬스터에 대한 `TakeDamage` 로그가 한 번만 찍히는지 확인.
- **리스크 관리:**
    - **선행 조건:** 7단계 완료.
    - **완료 조건:** 모든 로직 검증 테스트 통과.
    - **실패 시나리오:** 중복 타격 발생 시 → `RegisterHitByShot` 메소드의 `shotID` 생성 및 관리 로직 검토.
- **디버그 체크포인트:** `Log.Print("[CHK8<BulletController><Complete>] Intelligent projectile logic (payload, multi-hit guard) verified.");`

---

### **9단계: 조기 통합 및 스모크 테스트**
- **업무 내용:** 현재까지의 기능(1~8단계)을 통합하여, 가장 기본적인 '단일 투사체 발사 카드'가 정상 작동하는지 조기 검증.
- **강화 사항:** 치명적인 시스템 결함을 조기에 발견하여 프로젝트 실패 리스크를 최소화.
- **출력:** 조기 통합 테스트용 브랜치.
- **검증 방법:** "샘플 카드 발사 → 몬스터 피격 → 데미지 로그 확인"의 최소 기능 스모크 테스트 자동화.
- **리스크 관리:**
    - **선행 조건:** 8단계 완료.
    - **완료 조건:** 스모크 테스트 통과.
    - **실패 시나리오:** **(치명적 오류)** 공격 미발생 시 → 즉시 이전 안정 버전으로 롤백. `[CHK]` 로그를 역추적하여 어느 단계에서 흐름이 끊겼는지 분석.
- **디버그 체크포인트:** `Log.Print("[CHK9<SmokeTest><Complete>] Core attack loop integration verified.");`

---

### **10단계: 최종 통합 및 E2E 테스트**
- **업무 내용:** 모든 기능이 통합된 상태에서 복잡한 조합의 카드를 조립하고, 전체 게임 플레이 시나리오 검증.
- **강화 사항:** 전체 워크플로우의 안정성 및 완성도 검증.
- **출력:** 최종 통합 브랜치.
- **검증 방법:** QA용 자동화 시나리오(PlayMode Test)로 "카드 발사→로그 흐름" 녹화 후 기대 패턴과 매칭.
- **리스크 관리:**
    - **선행 조건:** 9단계 완료.
    - **완료 조건:** E2E 테스트 통과.
    - **실패 시나리오:** 특정 카드 조합에서 오류 발생 시 → 해당 조합에 사용된 모듈들의 상호작용 로직 분석.
- **디버그 체크포인트:** `Log.Print("[CHK10<E2E_Test><Complete>] Full system end-to-end test verified.");`

---

### **11단계: 아키텍처 최종 검증 - "일곱개의 대죄 사슬"**
- **업무 내용:** `ProjectileEffectSO`의 `sequentialPayloads` 기능을 사용하여, 7번 튕길 때마다 다른 효과가 발동하는 복잡한 카드를 통합 인스펙터에서 데이터 조립만으로 구현.
- **강화 사항:** 가장 복잡한 시나리오를 성공시킴으로써, 아키텍처의 유연성과 확장성을 최종 증명.
- **출력:** "일곱_개의_대죄_사슬_카드.asset".
- **검증 방법:** BDD 테스트 자동 실행.
- **리스크 관리:**
    - **선행 조건:** 10단계 완료.
    - **완료 조건:** BDD 테스트 통과.
    - **실패 시나리오:** BDD 시나리오 실패 시 → `BulletController`의 `currentRicochet` 값과 `sequentialPayloads`의 `onBounceNumber` 매칭 로직을 집중 디버깅.
- **디버그 체크포인트:** `Log.Print("[CHK11<SevenSins><Complete>] Final architecture validation with complex logic verified.");`

---

### **11.5단계: 후속 작업 - 최적화 및 편의기능**
- **업무 내용:** 프로파일링 기반 최적화 및 게임 내 디버그 모드 토글 기능 구현.
- **강화 사항:** 서비스 안정성 확보 및 디버그 편의성 제공.
- **출력:** 최적화된 코드, 게임 내 디버그 메뉴.
- **검증 방법:** 빌드 결과물 분석 자동화, 프로파일러로 전역 성능 목표 달성 확인.
- **리스크 관리:**
    - **선행 조건:** 11단계 완료.
    - **완료 조건:** 전역 성능 목표 달성.
    - **실패 시나리오:** 성능 목표 미달 시 → 프로파일러로 병목 구간 코드 분석 및 수정.
- **디버그 체크포인트:** `Log.Print("[CHK11.5<Finalization><Complete>] Project optimization and debug features verified.");`


  1단계: 아키텍처 기반 인터페이스 및 데이터 설계

   * 업무 내용: 카드 효과 시스템의 핵심 계약(Interface)과 데이터 구조(Class/Struct)를 코드로 직접 정의합니다.
     EffectContext의 메모리 관리를 위한 오브젝트 풀을 구현합니다.
   * 강화 사항: EffectContext 풀링 설계로 런타임 GC 부담을 원천적으로 제거합니다.
   * 핵심 산출물 및 코드 예시:

       1. `IPlatformModule.cs` (인터페이스):

   1         // 모든 기능 모듈이 반드시 구현해야 할 계약
   2         public interface IPlatformModule
   3         {
   4             // context를 받아 실제 효과 로직을 실행
   5             void Execute(EffectContext context);
   6         }

       2. `EffectContext.cs` (데이터 클래스):

    1         public class EffectContext
    2         {
    3             public CharacterStats Caster;
    4             public MonsterController Target;
    5             // ... (기타 모든 필드) ...
    6
    7             // 풀에 반환될 때 호출될 초기화 메소드
    8             public void Reset()
    9             {
   10                 Caster = null;
   11                 Target = null;
   12                 // ... (모든 참조 타입 필드를 null로, 값 타입은 기본값으로) ...
   13             }
   14         }

       3. `EffectContextPool.cs` (오브젝트 풀):

    1         public class EffectContextPool
    2         {
    3             private readonly Stack<EffectContext> pool = new Stack<EffectContext>();
    4
    5             public EffectContext Get()
    6             {
    7                 return pool.Count > 0 ? pool.Pop() : new EffectContext();
    8             }
    9
   10             public void Return(EffectContext context)
   11             {
   12                 context.Reset();
   13                 pool.Push(context);
   14             }
   15         }

   * 검증 방법:
       * [단위 테스트 케이스] `Pool_Reuses_Instances`:
           * Given: EffectContextPool을 생성하고 Get()을 5번 호출하여 모두 Return().
           * When: 다시 Get()을 1번 호출.
           * Then: new EffectContext()가 총 5번만 호출되었음을 Mock 객체나 카운터로 확인. 반환된 인스턴스의
             필드가 Reset()에 의해 모두 초기화되었는지 Assert.IsNull(context.Caster) 등으로 검증.
       * [프로파일링] 위 테스트 실행 시, Unity Profiler의 GC.Alloc이 0B임을 스냅샷으로 확인.

   * 디버그 체크포인트: Log.Print("[CHK1<Architecture><Complete>] Context pool and SO base classes verified.
     Pool efficiency: 99%+");

  ---

  2단계: '공존 후 대체'를 위한 CardDataSO 구조 개편

   * 업무 내용: 기존 CardDataSO는 유지한 채, 새로운 아키텍처를 따르는 NewCardDataSO.cs를 생성합니다. 두
     시스템의 공존을 위한 준비 작업을 진행합니다.
   * 강화 사항: 기존 시스템을 절대 깨뜨리지 않고, 안전하게 새 시스템을 도입하고 검증할 수 있는 '공존' 환경을
     구축합니다.
   * 핵심 산출물 및 코드 예시:

       1. `NewCardDataSO.cs` (신규 플랫폼):

    1         // [CreateAssetMenu(fileName = "NewCard_", ...)]
    2         public class NewCardDataSO : ScriptableObject
    3         {
    4             public int projectileCount = 1;
    5             public float spreadAngle = 0f;
    6             public int preloadCount = 10;
    7             public float baseDamage = 10f;
    8             public List<ModuleEntry> modules;
    9             // ... (기타 BasicInfo, StatModifiers 등) ...
   10         }

       2. `EffectExecutor` 임시 분기 로직:

    1         public void Execute(ScriptableObject card, ...)
    2         {
    3             if (card is NewCardDataSO newCard)
    4             {
    5                 // 새로운 모듈러 로직 실행
    6                 Log.Print("[Exec<NewSystem>] Executing with NewCardDataSO.");
    7             }
    8             else if (card is CardDataSO oldCard)
    9             {
   10                 // 기존 로직 실행 (레거시 지원)
   11                 Log.Print("[Exec<Legacy>] Executing with old CardDataSO.");
   12             }
   13         }

   * 검증 방법:
       * [수동 테스트] NewCardDataSO 에셋을 하나 생성하고, EffectExecutor가 [Exec<NewSystem>] 로그를
         정상적으로 출력하는지 확인. 기존 CardDataSO 카드는 [Exec<Legacy>] 로그를 출력하며 이전처럼 작동하는지
          확인.
       * [에디터 스크립트] `CardDataMigrator.cs`: oldCardDataSO 에셋을 입력받아 newCardDataSO 에셋을 생성하는
         에디터 창을 구현. effectType을 분석하여 해당하는 ...EffectSO 모듈을 modules 리스트에 자동으로
         추가해주는 로직 포함.

   * 디버그 체크포인트: Log.Print("[CHK2<CardDataSO><Complete>] NewCardDataSO co-existence setup verified.");

  ---

  3~6단계: 토대 구축 및 기능 검증

  이 단계들은 상호 의존적이므로, 하나의 거대한 '기반 공사' 단계로 묶어 설명합니다.

   * 업무 내용:
       1. (3단계) CardDataSOEditor.cs를 작성하여 NewCardDataSO의 통합 인스펙터를 구현합니다.
       2. (4단계) 모든 ...EffectSO.cs 모듈 스크립트를 IPlatformModule을 구현하여 작성합니다.
       3. (5단계) DataManager가 "data_effect" 레이블의 모든 모듈 에셋을 비동기 로드하도록 수정합니다.
       4. (6단계) GameManager의 PreloadAssetsForRound가 NewCardDataSO.modules를 순회하며, 각 모듈 내부의
          프리팹들을 preloadCount만큼 PoolManager에 등록하도록 구현합니다.
   * 강화 사항: 데이터 조립(인스펙터) -> 데이터 로딩(DataManager) -> 에셋 프리로딩(GameManager)으로 이어지는
     데이터 파이프라인을 완성합니다.
   * 핵심 산출물: CardDataSOEditor.cs, 모든 ...EffectSO.cs 파일, 수정된 DataManager.cs 및 GameManager.cs.
   * 검증 방법:
       * [통합 기능 테스트] 'Hello World' 카드 제작 및 검증:
           1. 조립: NewCardDataSO 에셋("TestCard_HelloWorld")을 만들고, 통합 인스펙터에서 `ProjectileEffectSO`
              모듈("TestModule_BasicShot")을 추가. bulletPrefabReference에 간단한 Sprite 프리팹 연결.
           2. Addressable 설정: "TestCard_HelloWorld"와 "TestModule_BasicShot" 에셋을 Addressable에 등록하고
              레이블 부여.
           3. 실행: 게임 시작 시, DataManager가 [DataManager_Load]` 로그를 통해 "TestModule_BasicShot"을
              로드했는지 확인.
           4. 검증: GameManager의 [Preload] 로그를 통해, 로드된 모듈 안의 bulletPrefabReference를 찾아
              PoolManager에 preloadCount만큼 등록했는지 확인.
   * 디버그 체크포인트: Log.Print("[CHK6<Foundation><Complete>] Data pipeline (Inspector->DataManager->Preload)
     verified with 'Hello World' card.");

  ---

  7단계: 지능형 투사체(BulletController) 구현

   * 업무 내용: 투사체의 생명주기(이동, 충돌, 소멸)와 관련된 모든 핵심 로직을 구현합니다. sequentialPayloads를
      해석하여 연쇄 효과를 발동시키고, 샷건 중복 히트를 방지하는 로직을 포함합니다.
   * 강화 사항: 복잡한 연쇄 효과와 중복 타격 방지 제어가 가능해져, 카드 설계의 깊이가 더해집니다.
   * 핵심 산출물 및 코드 예시:
       1. `BulletController.cs` (핵심 로직):

    1         public class BulletController : MonoBehaviour
    2         {
    3             // ... (spec, payloads, casterStats 등) ...
    4             private int currentRicochet = 0;
    5             private MonsterController lastHitTarget;
    6
    7             private void OnTriggerEnter2D(Collider2D other)
    8             {
    9                 if (other.TryGetComponent<MonsterController>(out var monster))
   10                 {
   11                     // 1. 중복 히트 방지 (샷건용)
   12                     if (!monster.RegisterHitByShot(this.shotID)) return; // 이미 맞았다면 무시
   13
   14                     Log.Print($"[CHK7<Bullet><Hit>] Collision with {monster.name}. Ricochets
      left: {ricochetCount - currentRicochet}");
   15
   16                     // 2. 데미지 계산 및 적용
   17                     // ...
   18
   19                     // 3. 페이로드 실행
   20                     ExecutePayloadsForCurrentState();
   21
   22                     // 4. 다음 행동 결정 (리코셰 > 관통 > 소멸)
   23                     HandleNextAction(monster);
   24                 }
   25             }
   26
   27             private void ExecutePayloadsForCurrentState()
   28             {
   29                 Log.Print($"[CHK7<Bullet><Payload>] Executing payload for bounce #
      {currentRicochet}.");
   30                 // sequentialPayloads 리스트에서 onBounceNumber가 currentRicochet과 일치하는
      모든 효과를 찾아 EffectExecutor에 실행 요청
   31             }
   32
   33             private void HandleNextAction(MonsterController hitMonster)
   34             {
   35                 if (currentRicochet < ricochetCount)
   36                 {
   37                     currentRicochet++;
   38                     lastHitTarget = hitMonster;
   39                     // FindNextTarget() 로직 (lastHitTarget 제외)
   40                 }
   41                 // ...
   42             }
   43         }
   * 검증 방법:
       * [단위 테스트 케이스] `Ricochet_Avoids_Last_Target`:
           * Given: 몬스터 A, B, C가 있고, 투사체가 방금 A를 lastHitTarget으로 기록.
           * When: FindNextTarget() 호출.
           * Then: 반환된 타겟이 B 또는 C이며, 절대 A가 아님을 Assert.AreNotEqual(A, nextTarget)으로 검증.
       * [통합 테스트] '3회 튕기는 카드'를 발사하여, [CHK7<Bullet><Payload>] 로그가 bounce #0, bounce #1,
         bounce #2 순서로 정확히 3번 출력되는지 확인.

   * 디버그 체크포인트: Log.Print("[CHK7<BulletController><Complete>] Intelligent projectile logic (payload,
     multi-hit guard) verified.");

  ---

  8단계 이후: 조립, 검증 및 완성

  8단계부터는 완성된 부품들을 조립하고, 전체 시스템이 유기적으로 동작하는지를 검증하는 단계입니다.

   * 8단계 (MonsterController): TakeDamage와 RegisterHitByShot의 단위 테스트를 통해, 외부로부터의 데이터
     처리가 정확한지만 검증합니다.
   * 9단계 (조기 통합 스모크 테스트):
       * 업무 내용: 1~8단계의 모든 결과물을 합쳐, 최초로 공격이 가능한 빌드를 만듭니다.
       * 검증 방법: 'Hello World' 카드를 장착한 플레이어가 몬스터를 공격했을 때, [CHK7<Bullet><Fire>] 부터
         [Monster_Damage] 로그까지 끊김 없이 순서대로 출력되는지를 검증하는 자동화된 PlayMode 테스트를
         실행합니다. 이 테스트가 통과하는 것이 "프로젝트가 살아있음"을 증명하는 첫 번째 관문입니다.
   * 10단계 (E2E 테스트): '튕김+상태이상', '샷건+광역피해' 등 복합적인 카드를 조립하고, 의도한 모든 효과와
     로그가 정상적으로 발생하는지 검증합니다.
   * 11단계 (최종 검증): '변덕스러운 운명의 만화경' 카드를 BDD 테스트 시나리오에 따라 검증합니다.
     [CHK11<Kaleidoscope><ConditionMet>] 와 같은 조건부 로그가 정확한 시점에 출력되는지 확인하는 것이
     핵심입니다.
   * 11.5단계 (최적화): Profiler를 통해 최종 성능 목표 달성 여부를 최종 확인합니다.




