# 추가 자료 (v8.0 아키텍처 구현용)

이 문서는 'v8.0 - 통합 인스펙터 아키텍처' 구현에 필요한 신규/수정 스크립트의 핵심 코드, 설계 가이드, 테스트 예시를 포함합니다.

---

## 1. Addressable 레이블 매핑 가이드

아래 표와 같이 Addressable 그룹 및 레이블을 설정하여 에셋을 관리합니다.

| 그룹명 | 레이블 | 대상 에셋 타입 |
| :--- | :--- | :--- |
| `Card_Platform` | `data_card` | `NewCardDataSO` |
| `Card_Modules` | `data_effect` | `ProjectileEffectSO`, `AreaEffectSO`, 등 `CardEffectSO` 상속 클래스 |
| `Prefabs_VFX` | `vfx` | 폭발, 피격 등 시각 효과 프리팹 |
| `Prefabs_Projectiles`| `projectile`| 총알, 투사체 등 프리팹 |

**[설정 방법]**
1. `Window > Asset Management > Addressables > Groups` 창을 엽니다.
2. `Create > Group > Packed Assets`로 위 표의 그룹들을 생성합니다.
3. 프로젝트 창에서 대상 에셋(들)을 선택하고, 인스펙터의 `Addressable` 체크박스를 활성화한 뒤, 위 표에 맞는 그룹으로 지정합니다.
4. `Addressables Groups` 창의 `Labels` UI를 통해 각 그룹에 맞는 레이블을 생성하고 할당합니다.

---

## 2. 신규/수정 시스템 클래스 핵심 코드

### `NewCardDataSO.cs` (신규 플랫폼)
```csharp
// [CreateAssetMenu(fileName = "Card_", menuName = "GameData/New Card Platform")]
public class NewCardDataSO : ScriptableObject
{
    [Header("플랫폼 기본 설정")]
    public int projectileCount = 1;
    public float spreadAngle = 0f;
    public int preloadCount = 10;
    public float baseDamage = 10f;

    [Header("모듈 조립 슬롯")]
    public List<ModuleEntry> modules;

    // ... (기타 BasicInfo, StatModifiers 등) ...

    public FiringSpec GetFiringSpecs()
    {
        // 발사에 필요한 기본 사양을 구조체로 묶어 반환하는 로직
        return new FiringSpec { /* ... */ };
    }
}

[System.Serializable]
public class ModuleEntry
{
    public string description; // 인스펙터에서 알아보기 위한 설명
    public AssetReferenceT<IPlatformModule> moduleReference;
}
```

### `EffectExecutor.cs` (수정)
```csharp
public class EffectExecutor
{
    private EffectContextPool contextPool = new EffectContextPool();

    public void Execute(NewCardDataSO card, CharacterStats caster, Vector3 spawnPosition)
    {
        EffectContext context = contextPool.Get();
        context.Caster = caster;
        // ... context 설정 ...

        // 1. 플랫폼의 기본 발사 사양으로 투사체 생성
        FiringSpec spec = card.GetFiringSpecs();
        // ... PoolManager에서 투사체를 꺼내 spec으로 초기화 ...

        // 2. 연결된 모든 모듈 순차 실행
        foreach (var moduleEntry in card.modules)
        {
            // DataManager를 통해 비동기로 모듈 로드 후 Execute 호출
            // ...
        }

        contextPool.Return(context);
    }
}
```

### `GameManager.cs` (Preload 로직 부분)
```csharp
public IEnumerator PreloadAssetsForRound(RoundDataSO roundData)
{
    var ownedCards = ServiceLocator.Get<CardManager>().GetAllOwnedCards();
    foreach (var card in ownedCards)
    {
        if (card is NewCardDataSO newCard)
        {
            Log.Print($"[Preload] Preloading for card: {newCard.name}");
            foreach (var moduleEntry in newCard.modules)
            {
                // 1. 모듈 에셋 자체를 로드
                var moduleHandle = moduleEntry.moduleReference.LoadAssetAsync<IPlatformModule>();
                yield return moduleHandle;

                if (moduleHandle.Status == AsyncOperationStatus.Succeeded)
                {
                    // 2. 모듈이 가진 프리팹 참조(가정)를 다시 로드
                    if (moduleHandle.Result is IPreloadable preloadableModule)
                    {
                        var prefabRef = preloadableModule.GetPrefabReference();
                        if (prefabRef != null && prefabRef.RuntimeKeyIsValid())
                        {
                             var prefabHandle = Addressables.LoadAssetAsync<GameObject>(prefabRef);
                             yield return prefabHandle;
                             if(prefabHandle.Status == AsyncOperationStatus.Succeeded)
                             {
                                 poolManager.Preload(prefabHandle.Result, newCard.preloadCount);
                             }
                        }
                    }
                }
            }
        }
    }
}
```

---

## 3. 통합 인스펙터 및 에디터 스크립트

### `CardDataSOEditor.cs` (신규)
```csharp
[CustomEditor(typeof(NewCardDataSO))]
public class CardDataSOEditor : Editor
{
    public override void OnInspectorGUI()
    {
        serializedObject.Update();

        // 기본 플랫폼 설정 필드들을 그립니다.
        EditorGUILayout.PropertyField(serializedObject.FindProperty("projectileCount"));
        EditorGUILayout.PropertyField(serializedObject.FindProperty("spreadAngle"));
        // ... 기타 필드 ...

        // 모듈 리스트를 커스텀하게 그립니다.
        SerializedProperty modulesProp = serializedObject.FindProperty("modules");
        EditorGUILayout.PropertyField(modulesProp);

        for (int i = 0; i < modulesProp.arraySize; i++)
        {
            SerializedProperty entryProp = modulesProp.GetArrayElementAtIndex(i);
            var moduleRef = entryProp.FindPropertyRelative("moduleReference");

            if (moduleRef.objectReferenceValue != null)
            {
                // 참조된 에셋을 인라인으로 편집할 수 있도록 에디터를 생성하여 그립니다.
                Editor moduleEditor = CreateEditor(moduleRef.objectReferenceValue);
                EditorGUI.indentLevel++;
                moduleEditor.OnInspectorGUI();
                EditorGUI.indentLevel--;
            }
        }

        serializedObject.ApplyModifiedProperties();
    }
}
```

---

## 4. 테스트 자동화 코드 예시

### 단위 테스트 예시 (`EffectContextPoolTests.cs`)
```csharp
[Test]
public void Pool_ReturnsSameInstance_AfterReturning()
{
    // Given
    var pool = new EffectContextPool();
    var initialInstance = pool.Get();
    pool.Return(initialInstance);

    // When
    var reusedInstance = pool.Get();

    // Then
    Assert.AreSame(initialInstance, reusedInstance);
}
```

### 스모크 테스트 예시 (PlayMode)
```csharp
[UnityTest]
public IEnumerator CoreAttackLoop_SmokeTest()
{
    // 1. 씬 설정: 플레이어, 몬스터, 모든 매니저 배치
    yield return SceneManager.LoadSceneAsync("SmokeTestScene");
    yield return null; // 씬 로드 대기

    // 2. 테스트용 카드 강제 장착
    var cardManager = ServiceLocator.Get<CardManager>();
    var testCard = Addressables.LoadAssetAsync<NewCardDataSO>("TestCard_HelloWorld").WaitForCompletion();
    cardManager.AddCard(testCard);

    // 3. 로그 리스너 설정
    bool fired = false;
    bool hit = false;
    Application.logMessageReceived += (logString, stackTrace, type) => {
        if (logString.Contains("[CHK7<Bullet><Fire>]")) fired = true;
        if (logString.Contains("[CHK7<Bullet><Hit>]")) hit = true;
    };

    // 4. 5초간 대기하며 공격이 발생하는지 확인
    yield return new WaitForSeconds(5f);

    // 5. 검증
    Assert.IsTrue(fired, "Bullet was not fired!");
    Assert.IsTrue(hit, "Bullet did not hit anything!");
}
```

---

## 5. 데이터 구조 및 예시

### `RoundDataSO.cs` (구조)
```csharp
[CreateAssetMenu(fileName = "Round_", menuName = "GameData/RoundData")]
public class RoundDataSO : ScriptableObject
{
    public float roundDuration = 180f;
    public List<Wave> waves;
}

[System.Serializable]
public class Wave
{
    public MonsterDataSO monsterData;
    public int count;
    public float duration;
}
```

### 테스트용 라운드 데이터 예시 (인스펙터 설정값)
- **Round_Test_01.asset**
    - `roundDuration`: 60
    - `waves`: (List, size 1)
        - **Element 0:**
            - `monsterData`: (Slime_Normal.asset 참조)
            - `count`: 20
            - `duration`: 30

---

## 6. 네이밍 컨벤션 및 디버그 시스템

### 네이밍 컨벤션 제안
- **카드 플랫폼:** `Card_` + `{카드이름}` (예: `Card_ChainOfSins.asset`)
- **기능 모듈:** `Module_` + `{타입}_` + `{기능}` (예: `Module_Projectile_Ricochet.asset`)
- **VFX 프리팹:** `VFX_` + `{효과이름}` (예: `VFX_Explosion_Small.prefab`)

### `DebugManager.cs` (구현)
```csharp
using System.Diagnostics;

public static class Log
{
    public static int LogCount { get; private set; }

    [Conditional("UNITY_EDITOR"), Conditional("DEVELOPMENT_BUILD")]
    public static void Print(string message)
    {
        UnityEngine.Debug.Log(message);
        LogCount++;
    }

    public static void ResetCount()
    {
        LogCount = 0;
    }
}
```



1. Addressable 레이블 및 에셋 목록:
       * 실제 ScriptableObject 에셋 파일들: 제가 코드 구조를 만들어도, 어떤 카드, 몬스터, 유물 .asset 파일들을
          Addressable로 만들지는 대표님의 프로젝트에만 존재합니다. 이 에셋들의 목록이 필요합니다.
       * 기존 레이블 확인: data_card 등의 레이블이 이미 사용 중인 규칙인지, 아니면 새로 만들어야 하는지 확인이
          필요합니다.

   2. UI 프리팹 및 에셋 링크:
       * 실제 `.prefab` 파일: CardDisplay, CodexItemDisplay 등의 UI 프리팹은 제가 코드는 짜도 시각적인
         결과물은 만들 수 없습니다.
       * 에디터 스크린샷: 만약 기존에 구상하신 커스텀 인스펙터 디자인이 있다면, 그 스크린샷이 필요합니다.
         없다면 제가 제안한 구조로 구현합니다.

   3. 맵 및 캠페인 기획 데이터:
       * 실제 맵/라운드 구성: MapManager가 생성할 맵의 구체적인 노드 타입 비율이나, RoundDataSO에 들어갈
         몬스터 웨이브 구성, 보상 등은 핵심 기획 데이터이므로 대표님께서 결정해주셔야 합니다. 저는 테스트를
         위한 임시 데이터만 만들 수 있습니다.

   4. 기존 네이밍 컨벤션 및 경로:
       * 만약 프로젝트에 이미 규칙적으로 사용 중인 폴더 구조나 에셋 이름 규칙이 있다면, 제가 그 규칙을 따를 수
          있도록 알려주셔야 합니다. 없다면 제가 제안한 규칙으로 진행합니다.

          프로젝트 착수 전에 다음 사항들만 최종 확정해 주시면 바로 개발에 들어갈 수 있습니다.

에셋 파일 이름·경로 일람

NewCardDataSO, ModuleEntry, 각 CardEffectSO 에셋(.asset)과 VFX/프리팹(.prefab)의 실제 파일명 및 프로젝트 내 경로

라벨 data_card, data_effect, vfx, projectile이 정확히 할당된 에셋 목록

서비스 로케이터 등록 순서 및 초기화 흐름

GameManager, DataManager, CardManager, RewardManager, CampaignManager, MapManager, MonsterManager, PoolManager 등의 Awake/Start 진입 순서

각 매니저 간 의존관계와 초기화 단계(예: Addressables 초기화→DataManager 로드→GameManager 진입)

PoolManager API 및 프리로드 정책

PoolManager.Preload(GameObject prefab, int count) 시 즉시 인스턴스를 생성할지, 지연 생성할지

풀 용량 초과 시 행동(오버라이드, 예외, 무시)

테스트 자동화 환경

PlayMode 테스트용 씬 이름 및 배치(prefab 배치, 라이트·카메라 설정 등)

단위 테스트 프레임워크(NUnit 버전, Unity Test Runner 설정)

디버그 로깅 필터링 기준

체크포인트 로그(Log.Print("[CHK...]")) 외에 CI 빌드나 개발 빌드에서 추가로 보고 싶은 로그 종류

릴리즈 빌드 조건

Conditional 속성으로 묶을 심볼(UNITY_EDITOR, DEVELOPMENT_BUILD 외 추가 필요 여부)

최종 릴리즈 빌드에서 자동 제거할 디버그 코드 범위

위 항목만 확정되면 v8.0 통합 인스펙터 아키텍처 구현을 바로 시작하겠습니다.