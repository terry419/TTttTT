==================== CharacterPermanentStats.cs (경로: ./TTttTT/Assets/1.Scripts/Data/CharacterPermanentStats.cs) ====================
// --- 파일명: CharacterPermanentStats.cs ---

using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[System.Serializable]
public class CharacterPermanentStats
{
    public string characterId;

    [Tooltip("테스트 시 해금할 스탯을 여기에 추가하세요. 실제 게임에서는 룰렛을 통해 해금됩니다.")]
    public List<StatType> defaultUnlockedStats = new List<StatType> { StatType.Health, StatType.Attack, StatType.AttackSpeed, StatType.MoveSpeed, StatType.CritMultiplier, StatType.CritRate };

    // [수정] 변수를 선언할 때 바로 new로 초기화해서 Null 참조 예외를 원천적으로 방지
    public Dictionary<StatType, bool> unlockedStatus = new Dictionary<StatType, bool>();
    public Dictionary<StatType, float> investedRatios = new Dictionary<StatType, float>();

    // JSON 저장을 위한 헬퍼 프로퍼티
    public StatDictionaryData statData
    {
        get
        {
            StatDictionaryData data = new StatDictionaryData();
            // unlockedStatus가 null이 아니므로 이제 여기서 에러가 발생하지 않아.
            foreach (var kvp in unlockedStatus)
            {
                data.statTypes.Add(kvp.Key);
                data.unlockedStatuses.Add(kvp.Value);
            }
            foreach (var kvp in investedRatios)
            {
                data.investedRatios.Add(kvp.Value);
            }
            return data;
        }
        set
        {
            unlockedStatus.Clear();
            investedRatios.Clear();
            if (value != null)
            {
                for (int i = 0; i < value.statTypes.Count; i++)
                {
                    unlockedStatus[value.statTypes[i]] = value.unlockedStatuses[i];
                    investedRatios[value.statTypes[i]] = value.investedRatios[i];
                }
            }
        }
    }

    // [수정] JsonUtility가 이 생성자를 사용하지 않으므로, 딕셔너리 초기화 코드는 선언부로 옮기고 여기서는 비워둠.
    public CharacterPermanentStats()
    {
        // 비어 있어도 괜찮아.
    }

    public CharacterPermanentStats(string charId)
    {
        characterId = charId;

        // 모든 스탯을 일단 '잠금' 상태로 초기화
        foreach (StatType type in System.Enum.GetValues(typeof(StatType)))
        {
            unlockedStatus[type] = false;
            investedRatios[type] = 0f;
        }

        // defaultUnlockedStats 리스트에 있는 스탯들만 '해금' 상태로 변경
        foreach (StatType type in defaultUnlockedStats)
        {
            unlockedStatus[type] = true;
        }
    }

    // ... 이하 나머지 코드는 동일 ...

    public List<StatType> GetLockedStats()
    {
        return unlockedStatus.Where(kvp => !kvp.Value).Select(kvp => kvp.Key).ToList();
    }

    public List<StatType> GetUnlockedStats()
    {
        return unlockedStatus.Where(kvp => kvp.Value).Select(kvp => kvp.Key).ToList();
    }

    public bool AllStatsUnlocked()
    {
        return unlockedStatus.Values.All(unlocked => unlocked);
    }

    public void UnlockStat(StatType stat)
    {
        if (unlockedStatus.ContainsKey(stat))
        {
            unlockedStatus[stat] = true;
        }
    }

    public void DistributePoints(int points)
    {
        List<StatType> unlocked = GetUnlockedStats();
        if (unlocked.Count == 0) return;

        for (int i = 0; i < points; i++)
        {
            StatType targetStat = unlocked[Random.Range(0, unlocked.Count)];
            float weight = GetWeightForStat(targetStat);
            investedRatios[targetStat] += weight;
        }
    }

    private float GetWeightForStat(StatType stat)
    {
        switch (stat)
        {
            case StatType.Health: return 0.02f;
            default: return 0.01f;
        }
    }
}

==================== CardDataSO.cs (경로: ./TTttTT/Assets/1.Scripts/Data/CardDataSO.cs) ====================
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AddressableAssets;

// ▼▼▼ 이 내부 클래스들을 먼저 정의합니다. ▼▼▼

[Serializable]
public class BasicInfo
{
    [Tooltip("카드의 고유 ID (예: warrior_basic_001)")]
    public string cardID;
    [Tooltip("UI에 표시될 카드 이름")]
    public string cardName;
    [Tooltip("UI에 표시될 카드 아이콘")]
    public Sprite cardIcon;
    [Tooltip("카드의 타입 (물리 또는 마법)")]
    public CardType type;
    [Tooltip("카드의 희귀도")]
    public CardRarity rarity;
    [Tooltip("카드 효과 설명 텍스트"), TextArea(3, 5)]
    public string effectDescription;
}

[Serializable]
public class StatModifiers
{
    [Tooltip("공격력에 더해지는 % 배율")]
    public float damageMultiplier;
    [Tooltip("공격 속도에 더해지는 % 배율")]
    public float attackSpeedMultiplier;
    [Tooltip("이동 속도에 더해지는 % 배율")]
    public float moveSpeedMultiplier;
    [Tooltip("최대 체력에 더해지는 % 배율")]
    public float healthMultiplier;
    [Tooltip("치명타 확률에 더해지는 % 배율")]
    public float critRateMultiplier;
    [Tooltip("치명타 피해량에 더해지는 % 배율")]
    public float critDamageMultiplier;
}

// ▲▲▲ 내부 클래스 정의 끝 ▲▲▲


[CreateAssetMenu(fileName = "CardData_", menuName = "GameData/CardData")]
public class CardDataSO : ScriptableObject
{
    [Header("1. 기본 정보")]
    [Tooltip("카드의 기본 정보를 담고 있습니다.")]
    public BasicInfo basicInfo;

    [Header("2. 행동 설계도 (뼈대)")]
    [Tooltip("이 카드가 한 번에 발사하는 투사체의 총 개수입니다.")]
    public int projectileCount = 1;
    [Tooltip("투사체가 퍼지는 총 각도입니다. 0이면 모든 투사체가 같은 방향으로 나갑니다.")]
    public float spreadAngle = 0f;
    [Tooltip("이 카드가 사용하는 모든 프리팹을 몇 개씩 미리 로드할지에 대한 권장 수량입니다.")]
    public int preloadCount = 50;

    [Header("3. 패시브 능력치")]
    [Tooltip("카드 장착 시 플레이어에게 적용되는 지속적인 스탯 보너스입니다.")]
    public StatModifiers statModifiers;

    [Header("4. 옵션 부품 조립 슬롯")]
    [Tooltip("이 카드에 장착할 '옵션(CardEffectSO)' 에셋들을 여기에 드래그 앤 드롭으로 등록합니다.")]
    public List<AssetReference> attachedEffectReferences;

    [Header("5. 메타 정보")]
    [Tooltip("게임 플레이 중 룰렛 등에서 이 카드가 선택될 확률 가중치입니다.")]
    public float selectionWeight = 1f;
    [Tooltip("라운드 종료 후 보상으로 등장할 확률 가중치입니다.")]
    public float rewardAppearanceWeight;
    [Tooltip("이 카드를 해금하기 위한 조건입니다. (미구현)")]
    public string unlockCondition;
}

==================== MonsterDataSo.cs (경로: ./TTttTT/Assets/1.Scripts/Data/MonsterDataSo.cs) ====================
// ϸ: MonsterDataSO.cs
// : Assets/1.Scripts/Data/MonsterDataSO.cs
using UnityEngine;

/// <summary>
///     ͸ ϴ ScriptableObjectԴϴ.
/// ü, ӵ, ݷ,     Ӽ   ϳ   ֽϴ.
/// </summary>
[CreateAssetMenu(fileName = "MonsterData_", menuName = "GameData/MonsterData")]
public class MonsterDataSO : ScriptableObject
{
    [Header("⺻ ")]
    [Tooltip("͸ ã   IDԴϴ. (: slime_normal, goblin_archer)")]
    public string monsterID;

    [Tooltip("  ǥõ ̸Դϴ.")]
    public string monsterName;

    [Header("ɷġ")]
    public float maxHealth = 100f;
    public float moveSpeed = 3f;
    public float contactDamage = 10f;

    [Header("")]
    [Tooltip(" Ͱ    ϼ.")]
    public GameObject prefab; // [] string ٽ GameObject 

    // [Ȯ ] ȹ ޵ پ  ൿ   
    // public enum MonsterBehaviorType { Chase, Flee, Patrol, ExplodeOnDeath }
    // public MonsterBehaviorType behaviorType;
}

==================== ArtifactDataSO.cs (경로: ./TTttTT/Assets/1.Scripts/Data/ArtifactDataSO.cs) ====================
using UnityEngine;

[CreateAssetMenu(fileName = "ArtifactData_", menuName = "GameData/ArtifactData")]
public class ArtifactDataSO : ScriptableObject
{
    [Header("기본 정보")]
    public string artifactID;
    public string artifactName;
    [TextArea(3, 5)]
    public string description;

    [Header("유물 속성")]
    public CardRarity rarity;

    [Header("효과 파라미터")]
    public float attackBoostRatio;
    public float healthBoostRatio;
    public float moveSpeedBoostRatio;
    public float critChanceBoostRatio;
    public float critDamageBoostRatio;
    public float lifestealBoostRatio;

    [Header("슬롯 및 확률 보너스")]
    public int ownedCardSlotBonus;
    public float specificCardTriggerChanceBonus;

    [Header("시각 정보")]
    public Sprite icon;
}

==================== JsonDataClasses.cs (경로: ./TTttTT/Assets/1.Scripts/Data/JsonDataClasses.cs) ====================
using System;
using System.Collections.Generic;
using UnityEngine; // For Sprite, though not directly used in JSON deserialization, useful for context

// 전체 게임 데이터를 담을 JSON 구조의 루트 클래스
[Serializable]
public class GameDataJson
{
    public List<CardDataJson> cards;
    public List<ArtifactDataJson> artifacts;
}

// CardDataSO와 필드를 일치시키는 JSON용 클래스
[Serializable]
public class CardDataJson
{
    public string cardID;
    public string cardName;
    public string iconPath; // Sprite를 대체할 리소스 경로
    public string type; // CardType enum을 string으로 매핑
    public string rarity; // CardRarity enum을 string으로 매핑

    public float damageMultiplier;
    public float attackSpeedMultiplier;
    public float moveSpeedMultiplier;
    public float healthMultiplier;
    public float critRateMultiplier;
    public float critDamageMultiplier;
    public float lifestealPercentage;
    public string effectDescription;

    public string effectType; // CardEffectType enum을 string으로 매핑
    public string triggerType; // TriggerType enum을 string으로 매핑

    public float rewardAppearanceWeight;
    public string unlockCondition;
}

// ArtifactDataSO와 필드를 일치시키는 JSON용 클래스
[Serializable]
public class ArtifactDataJson
{
    public string artifactID;
    public string artifactName;
    public string iconPath; // Sprite를 대체할 리소스 경로
    public string rarity; // CardRarity enum을 string으로 매핑

    public float attackBoostRatio;
    public float healthBoostRatio;
    public float moveSpeedBoostRatio;
    public float critChanceBoostRatio;
    public float critDamageBoostRatio;
    public float lifestealBoostRatio;
    
    // ArtifactDataSO에 추가된 필드들
    public int ownedCardSlotBonus;
    public float specificCardTriggerChanceBonus;
}

// ProgressionManager의 영구 데이터를 저장하기 위한 클래스
[Serializable]
public class ProgressionData
{
    public int knowledgeShards;
    public int genePoints;

    // JsonUtility는 Dictionary를 직접 직렬화할 수 없으므로 List 두 개로 변환하여 저장합니다.
    public List<string> achievementIDs = new List<string>();
    public List<bool> achievementStates = new List<bool>();

    public List<string> bossKillIDs = new List<string>();
    public List<bool> bossKillStates = new List<bool>();

    // 캐릭터별 영구 스탯 데이터
    public List<CharacterPermanentStats> characterPermanentStats = new List<CharacterPermanentStats>();
}

// CharacterPermanentStats 클래스의 Dictionary를 직렬화하기 위한 헬퍼 클래스
[Serializable]
public class StatDictionaryData
{
    public List<StatType> statTypes = new List<StatType>();
    public List<bool> unlockedStatuses = new List<bool>();
    public List<float> investedRatios = new List<float>();
}




==================== PrefabDB.cs (경로: ./TTttTT/Assets/1.Scripts/Data/PrefabDB.cs) ====================
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "PrefabDB", menuName = "GameData/PrefabDB")]
public class PrefabDB : ScriptableObject
{
    [Header("몬스터 프리팹")]
    public List<GameObject> monsterPrefabs;

    [Header("총알 프리팹")]
    public List<GameObject> bulletPrefabs;

    [Header("시각 효과 (VFX) 프리팹")]
    public List<GameObject> vfxPrefabs;
}


==================== AudioCollection.cs (경로: ./TTttTT/Assets/1.Scripts/Data/AudioCollection.cs) ====================
using UnityEngine;

/// <summary>
/// BGM, SFX 등 오디오 클립들을 그룹으로 묶어 관리하는 ScriptableObject.
/// 각 씬이나 상황에 맞는 오디오 세트를 구성하는 데 사용됩니다.
/// </summary>
[CreateAssetMenu(fileName = "NewAudioCollection", menuName = "9th/Audio/Audio Collection")]
public class AudioCollection : ScriptableObject
{
    [Header("배경음악 (BGM)")]
    public AudioClip[] bgmClips;

    [Header("효과음 (SFX)")]
    public AudioClip[] sfxClips;

    /// <summary>
    /// 이름으로 BGM 오디오 클립을 찾습니다.
    /// </summary>
    public AudioClip GetBgmClip(string clipName)
    {
        foreach (var clip in bgmClips)
        {
            if (clip.name == clipName)
            {
                return clip;
            }
        }
        Debug.LogWarning($"'{name}' 컬렉션에 '{clipName}' BGM이 없습니다.");
        return null;
    }

    /// <summary>
    /// 이름으로 SFX 오디오 클립을 찾습니다.
    /// </summary>
    public AudioClip GetSfxClip(string clipName)
    {
        foreach (var clip in sfxClips)
        {
            if (clip.name == clipName)
            {
                return clip;
            }
        }
        Debug.LogWarning($"'{name}' 컬렉션에 '{clipName}' SFX가 없습니다.");
        return null;
    }
}


==================== MapNode.cs (경로: ./TTttTT/Assets/1.Scripts/Data/MapNode.cs) ====================
using System.Collections.Generic;
using UnityEngine;

public enum NodeType { Monster, Elite, Shop, Rest, Boss, Event }

public class MapNode
{
    public NodeType NodeType;
    public Vector2Int Position; //  ڿ ġ (x, y)
    public List<MapNode> NextNodes = new List<MapNode>(); //  忡   ִ  
}

==================== StatusEffectDataSO.cs (경로: ./TTttTT/Assets/1.Scripts/Data/StatusEffectDataSO.cs) ====================
using UnityEngine;

[CreateAssetMenu(fileName = "StatusEffectData_", menuName = "GameData/StatusEffectData")]
public class StatusEffectDataSO : ScriptableObject
{
    [Header("기본 정보")]
    public string effectId;
    public string effectName;
    public Sprite icon;

    [Header("효과 속성")]
    public float duration;
    public bool isBuff;

    [Header("능력치 변경 효과 (백분율, %)")]
    public float damageRatioBonus;
    public float attackSpeedRatioBonus;
    public float moveSpeedRatioBonus;
    public float healthRatioBonus;
    public float critRateRatioBonus;
    public float critDamageRatioBonus;

    [Header("지속 피해/회복 효과")]
    public float damageOverTime;
    public float healOverTime;

    /// <summary>
    /// [리팩토링] 대상 캐릭터에게 이 상태 효과의 능력치 보너스를 적용합니다.
    /// </summary>
    public void ApplyEffect(CharacterStats targetStats)
    {
        if (targetStats == null) return;

        // 각 보너스 값이 0이 아닐 때만 Modifier를 추가합니다.
        if (damageRatioBonus != 0) targetStats.AddModifier(StatType.Attack, new StatModifier(damageRatioBonus, this));
        if (attackSpeedRatioBonus != 0) targetStats.AddModifier(StatType.AttackSpeed, new StatModifier(attackSpeedRatioBonus, this));
        if (moveSpeedRatioBonus != 0) targetStats.AddModifier(StatType.MoveSpeed, new StatModifier(moveSpeedRatioBonus, this));
        if (healthRatioBonus != 0) targetStats.AddModifier(StatType.Health, new StatModifier(healthRatioBonus, this));
        if (critRateRatioBonus != 0) targetStats.AddModifier(StatType.CritRate, new StatModifier(critRateRatioBonus, this));
        if (critDamageRatioBonus != 0) targetStats.AddModifier(StatType.CritMultiplier, new StatModifier(critDamageRatioBonus, this));
    }

    /// <summary>
    /// [리팩토링] 대상 캐릭터에게서 이 상태 효과의 능력치 보너스를 제거합니다.
    /// </summary>
    public void RemoveEffect(CharacterStats targetStats)
    {
        if (targetStats == null) return;

        targetStats.RemoveModifiersFromSource(this);
    }
}

==================== CampaignDataSO.cs (경로: ./TTttTT/Assets/1.Scripts/Data/CampaignDataSO.cs) ====================
// --- ϸ: CampaignDataSO.cs ---
// : Assets/1.Scripts/Data/CampaignDataSO.cs
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "CampaignData_", menuName = "GameData/CampaignData")]
public class CampaignDataSO : ScriptableObject
{
    [Tooltip(" ķ ϴ  Դϴ.  ˴ϴ.")]
    public List<RoundDataSO> rounds;
}

==================== UIGraphicsDB.cs (경로: ./TTttTT/Assets/1.Scripts/Data/UIGraphicsDB.cs) ====================
// UIGraphicsDB.cs
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "UIGraphicsDB", menuName = "GameData/UIGraphics Database")]
public class UIGraphicsDB : ScriptableObject
{
    // --- ̱(Singleton)  ---
    private static UIGraphicsDB _instance;
    public static UIGraphicsDB Instance
    {
        get
        {
            if (_instance == null)
            {
                _instance = Resources.Load<UIGraphicsDB>("UIGraphicsDB");
                if (_instance == null)
                    Debug.LogError("UIGraphicsDB could not be loaded from Resources!");
            }
            return _instance;
        }
    }

    // ---   ---
    [System.Serializable]
    public struct RaritySpriteEntry
    {
        public CardRarity rarity;
        public Sprite sprite;
    }

    public List<RaritySpriteEntry> raritySprites;

    // ---    Լ ---
    private Dictionary<CardRarity, Sprite> raritySpriteDict;

    private void OnEnable()
    {
        // Ʈ ųʸ ȯϿ ˻ ӵ Դϴ.
        raritySpriteDict = raritySprites.ToDictionary(x => x.rarity, x => x.sprite);
    }

    public Sprite GetRaritySprite(CardRarity rarity)
    {
        if (raritySpriteDict != null && raritySpriteDict.TryGetValue(rarity, out Sprite sprite))
        {
            return sprite;
        }
        return null; // شϴ Ʈ  
    }
}

==================== Wave.cs (경로: ./TTttTT/Assets/1.Scripts/Data/Wave.cs) ====================
// --- ���ϸ�: Wave.cs ---
using UnityEngine;

// [�߰�] ���� ����� �����ϴ� enum. �� �κ��� ��� ù ��° ������ �߻��߾�.
public enum SpawnType
{
    Spread, // ������ �ð� ���� ������ ����
    Burst   // �� ���� �͸��� ����
}

[System.Serializable]
public class Wave
{
    [Tooltip("�� ���̺꿡�� ������ ������ ������(SO)�� ���� ���⿡ �����ϼ���.")]
    // [����] string ��� MonsterDataSO�� ���� �����մϴ�.
    public MonsterDataSO monsterData;

    [Tooltip("������ ������ ��")]
    public int count;

    [Tooltip("SpawnType�� Spread�� ��, ù ���ͺ��� ������ ���ͱ��� �����Ǵ� �� �ɸ��� �� �ð��Դϴ�.")]
    public float duration = 10f;

    [Tooltip("�� ���̺갡 ���� �� ���� ���̺갡 ���۵Ǳ������ ��� �ð��Դϴ�.")]
    public float delayAfterWave;

    [Tooltip("���� ��� (Spread: �ð���, Burst: ����)")]
    public SpawnType spawnType;

    // ▼▼▼ [3] 이 줄을 추가하세요. ▼▼▼
    [Tooltip("이 웨이브의 몬스터를 몇 마리 미리 생성할지 정합니다. 0으로 두면 'Count' 값을 따릅니다.")]
    public int preloadCount = 50;
}

==================== CharacterDataSO.cs (경로: ./TTttTT/Assets/1.Scripts/Data/CharacterDataSO.cs) ====================
// --- 파일명: CharacterDataSO.cs ---
using UnityEngine;
using System.Collections.Generic; // List를 사용하기 위해 추가

[CreateAssetMenu(fileName = "CharacterData_", menuName = "GameData/CharacterData")]
public class CharacterDataSO : ScriptableObject
{
    [Header("기본 정보")]
    public string characterId;
    public string characterName;
    public Sprite illustration;
    [TextArea(3, 5)]
    public string description;

    [Header("기본 능력치")]
    public BaseStats baseStats;

    [Header("시작 아이템")]
    public CardDataSO startingCard;
    public List<ArtifactDataSO> startingArtifacts; // [추가] 시작 유물 목록

    [Header("초기 포인트")]
    public int initialAllocationPoints;
}

==================== RoundDataSO.cs (경로: ./TTttTT/Assets/1.Scripts/Data/RoundDataSO.cs) ====================
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "RoundData_", menuName = "GameData/RoundData")]
public class RoundDataSO : ScriptableObject
{
    public float roundDuration = 180f;
    public int killGoal = 100;
    public List<Wave> waves;

}

==================== StatModifier.cs (경로: ./TTttTT/Assets/1.Scripts/Data/StatModifier.cs) ====================
/// <summary>
/// 개별 스탯 보너스에 대한 정보를 담는 클래스입니다.
/// </summary>
public class StatModifier
{
    public readonly float Value; // 보너스 수치 (예: 0.1f는 10%)
    public readonly object Source; // 이 보너스를 제공한 객체 (CardDataSO, ArtifactDataSO 등)

    public StatModifier(float value, object source)
    {
        Value = value;
        Source = source;
    }
}

==================== BaseStats.cs (경로: ./TTttTT/Assets/1.Scripts/Data/BaseStats.cs) ====================
using UnityEngine;

[System.Serializable]
public class BaseStats
{
    public float baseDamage;
    public float baseAttackSpeed;
    public float baseMoveSpeed;
    public float baseHealth;
    public float baseCritRate;
    public float baseCritDamage;
}

==================== StatusEffectSO.cs (경로: ./TTttTT/Assets/1.Scripts/Data/CardEffects/StatusEffectSO.cs) ====================
using UnityEngine;

[CreateAssetMenu(fileName = "Status_", menuName = "GameData/Card Effects/Apply Status Effect")]
public class StatusEffectSO : CardEffectSO
{
    [Header("상태 이상 설정")]
    [Tooltip("적용할 상태 이상 데이터 에셋")]
    public StatusEffectDataSO statusToApply;

    public override void Execute(EffectContext context)
    {
        // 이 로직은 6단계(EffectExecutor)에서 최종 구현됩니다.
        Debug.Log($"<color=lime>[StatusEffect]</color> '{this.name}' 실행. (로직 구현 대기중)");
    }
}

==================== ProjectileEffectSO.cs (경로: ./TTttTT/Assets/1.Scripts/Data/CardEffects/ProjectileEffectSO.cs) ====================
using UnityEngine;
using System.Collections.Generic;
using System;
using UnityEngine.AddressableAssets;

[Serializable]
public class SequentialPayload
{
    [Tooltip("이 효과가 발동될 바운스 횟수. 0은 최초 피격, 1은 첫 번째 튕김을 의미합니다.")]
    public int onBounceNumber;
    [Tooltip("해당 순서에 발동시킬 CardEffectSO 에셋의 Addressable ID (에셋 파일명)")]
    public AssetReferenceT<CardEffectSO> effectReference;
}

[CreateAssetMenu(fileName = "Projectile_", menuName = "GameData/Card Effects/Projectile Effect")]
public class ProjectileEffectSO : CardEffectSO
{

    public enum TargetingType
    {
        Forward,        // 전방
        Nearest,        // 가장 가까운 적
        HighestHealth,  // 체력 가장 높은 적
        LowestHealth,   // 체력 가장 낮은 적
        HighestDamage,  // (미래 확장) 공격력 가장 높은 적
        Fastest         // (미래 확장) 이동 속도 가장 빠른 적
    }

    [Header("타겟팅 방식")]
    [Tooltip("투사체의 기본 발사 방향을 결정합니다.")]
    public TargetingType targetingType = TargetingType.Forward;

    [Header("투사체 기본 설정")]
    [Tooltip("발사할 투사체 프리팹")]
    public AssetReferenceGameObject bulletPrefabReference;
    [Tooltip("투사체 속도")]
    public float speed = 10f;
    [Tooltip("투사체 기본 피해량")]
    public float baseDamage = 10f;

    [Header("특수 기능")]
    [Tooltip("관통 횟수")]
    public int pierceCount = 0;
    [Tooltip("리코셰(튕김) 횟수")]
    public int ricochetCount = 0;
    [Tooltip("true이면 이미 맞춘 적에게 다시 튕길 수 있습니다 (단, 연속으로는 안됨)")]
    public bool canRicochetToSameTarget = false;
    [Tooltip("true이면 가장 가까운 적을 추적합니다.")]
    public bool isTracking = false;

    [Header("피격 시 연쇄 효과 (Payload)")]
    [Tooltip("투사체가 적에게 명중했을 때 순차적으로 발동할 효과 목록")]
    public List<SequentialPayload> sequentialPayloads;

    [Header("시각 효과 (VFX)")]
    [Tooltip("피격 시 재생할 VFX의 ID")]
    public AssetReferenceGameObject onHitVFXKey;
    [Tooltip("치명타 피격 시 재생할 VFX의 ID")]
    public AssetReferenceGameObject onCritVFXKey;
    [Tooltip("수명이 다해 소멸 시 재생할 VFX의 ID")]
    public AssetReferenceGameObject onExpireVFXKey;

    public override void Execute(EffectContext context)
    {
        // 이 로직은 6단계(EffectExecutor) 및 7단계(BulletController)에서 최종 구현됩니다.
        Debug.Log($"<color=lime>[ProjectileEffect]</color> '{this.name}' 실행. (로직 구현 대기중)");
    }
}

==================== ApplyBuffToCasterEffectSO.cs (경로: ./TTttTT/Assets/1.Scripts/Data/CardEffects/ApplyBuffToCasterEffectSO.cs) ====================
using UnityEngine;

[CreateAssetMenu(fileName = "Buff_", menuName = "GameData/Card Effects/Apply Buff to Caster")]
public class ApplyBuffToCasterEffectSO : CardEffectSO
{
    [Header("버프 설정")]
    [Tooltip("시전자에게 적용할 버프 데이터 에셋")]
    public StatusEffectDataSO buffToApply;

    [Header("시각 효과 (VFX)")]
    [Tooltip("버프가 적용되는 순간 시전자 위치에 재생할 VFX의 ID")]
    public string onBuffAppliedVFXKey;

    public override void Execute(EffectContext context)
    {
        // 이 로직은 6단계(EffectExecutor)에서 최종 구현됩니다.
        Debug.Log($"<color=lime>[ApplyBuffToCaster]</color> '{this.name}' 실행. (로직 구현 대기중)");
    }
}

==================== LifestealEffectSO.cs (경로: ./TTttTT/Assets/1.Scripts/Data/CardEffects/LifestealEffectSO.cs) ====================
using UnityEngine;

[CreateAssetMenu(fileName = "Lifesteal_", menuName = "GameData/Card Effects/Lifesteal")]
public class LifestealEffectSO : CardEffectSO
{
    [Header("흡혈 설정")]
    [Tooltip("입힌 피해량 대비 회복할 체력의 비율 (%)")]
    [Range(0, 100)]
    public float lifestealPercentage;

    public override void Execute(EffectContext context)
    {
        // 이 로직은 6단계(EffectExecutor)에서 최종 구현됩니다.
        Debug.Log($"<color=lime>[LifestealEffect]</color> '{this.name}' 실행. (로직 구현 대기중)");
    }
}

==================== AreaEffectSO.cs (경로: ./TTttTT/Assets/1.Scripts/Data/CardEffects/AreaEffectSO.cs) ====================
using UnityEngine;

[CreateAssetMenu(fileName = "AreaEffect_", menuName = "GameData/Card Effects/Area Effect")]
public class AreaEffectSO : CardEffectSO
{
    [Header("광역 효과 설정")]
    [Tooltip("생성할 장판/파동의 프리팹")]
    public GameObject effectPrefab;

    [Tooltip("이 효과가 단일 피해 파동(true)인지, 지속 피해 장판(false)인지 결정")]
    public bool isSingleHitWaveMode = true;

    [Header("단일 파동 설정")]
    [Tooltip("파동 모드일 때의 단일 피해량")]
    public float singleHitDamage = 50f;

    [Header("지속 장판 설정")]
    [Tooltip("장판의 총 지속 시간")]
    public float duration = 3f;
    [Tooltip("장판의 확장 속도")]
    public float expansionSpeed = 1f;
    [Tooltip("장판이 최대 크기까지 확장되는 데 걸리는 시간")]
    public float expansionDuration = 0.5f;
    [Tooltip("장판의 틱당 피해량")]
    public float damagePerTick = 5f;
    [Tooltip("피해를 주는 간격(초)")]
    public float tickInterval = 1f;
    
    public override void Execute(EffectContext context)
    {
        // 이 로직은 6단계(EffectExecutor)에서 최종 구현됩니다.
        Debug.Log($"<color=lime>[AreaEffect]</color> '{this.name}' 실행. (로직 구현 대기중)");
    }
}

==================== CardEffectSO.cs (경로: ./TTttTT/Assets/1.Scripts/Data/CardEffects/CardEffectSO.cs) ====================
using UnityEngine;

/// <summary>
/// 모든 카드 효과 '옵션'의 기반이 되는 추상 ScriptableObject입니다.
/// 각 효과는 이 클래스를 상속받아 자신만의 Execute 로직을 구현해야 합니다.
/// 자식 클래스의 Execute 메소드 최상단에는 자신의 실행을 알리는 디버그 로그를 반드시 추가해야 합니다.
/// 예: Debug.Log($"<color=lime>[{GetType().Name}]</color> '{this.name}' 실행.");
/// </summary>
public abstract class CardEffectSO : ScriptableObject
{
    /// <summary>
    /// 이 효과가 언제 발동될지를 정의합니다.
    /// </summary>
    public enum EffectTrigger
    {
        OnFire,           // 카드가 발사되는 즉시
        OnHit,            // 투사체가 무언가에 명중했을 때
        OnCrit,           // 치명타로 명중했을 때
        OnKill,           // 적을 처치했을 때
        OnLastRicochetHit // 마지막 리코셰(튕김)가 명중했을 때
    }

    [Header("효과 발동 조건")]
    [Tooltip("이 효과가 어떤 시점에 발동될지를 선택합니다.")]
    public EffectTrigger trigger;

    /// <summary>
    /// 이 효과의 실제 로직을 실행하는 메소드입니다.
    /// 자식 클래스에서 이 메소드를 반드시 재정의(override)해야 합니다.
    /// </summary>
    /// <param name="context">효과 실행에 필요한 모든 정보가 담긴 컨텍스트 객체</param>
    public abstract void Execute(EffectContext context);
}

==================== TestCardEffectSO.cs (경로: ./TTttTT/Assets/1.Scripts/Data/CardEffects/TestCardEffectSO.cs) ====================
using UnityEngine;

[CreateAssetMenu(fileName = "TestCardEffect", menuName = "Card/Effect/Test")]
public class TestCardEffectSO : CardEffectSO
{
    public override void Execute(EffectContext context)
    {
        Debug.Log($"<color=green>[TestCardEffectSO]</color> Test effect executed for {context.Caster.name}!");
    }
}


==================== RouteSelectionController.cs (경로: ./TTttTT/Assets/1.Scripts/UI/RouteSelectionController.cs) ====================
// 파일 경로: Assets/1/Scripts/UI/RouteSelectionController.cs

using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using System.Collections;
using System.Collections.Generic;

/// <summary>
/// 맵 경로 선택 씬의 전체적인 흐름을 제어하는 '조율자(Coordinator)' 클래스입니다.
/// MapManager로부터 맵 데이터를 받아 MapView에 그리도록 지시하고,
/// RewardManager의 상태에 따라 UI 포커스와 버튼 활성화 여부를 결정합니다.
/// </summary>
public class RouteSelectionController : MonoBehaviour
{
    // --- Inspector-Visible Fields --- //
    [Header("제어할 UI 패널")]
    [SerializeField] private GameObject routeSelectPanel;

    [Header("전문 컴포넌트 참조")]
    [SerializeField] private MapView mapView;
    [SerializeField] private AutoFocusScroller autoFocusScroller;

    [Header("포커스 대상 버튼")]
    public Button rewardPageButton;

    // --- Unity Lifecycle Methods --- //
    void Awake()
    {
        ServiceLocator.Register<RouteSelectionController>(this);
    }

    void Start()
    {
        if (routeSelectPanel == null || mapView == null || autoFocusScroller == null)
        {
            Debug.LogError($"[{GetType().Name}] 필요한 UI 컴포넌트가 Inspector에 연결되지 않았습니다!", this.gameObject);
            return;
        }
        mapView.OnNodeSelected += OnNodeClicked;
        routeSelectPanel.SetActive(false); // 시작 시에는 비활성화 상태
    }

    // --- Public Methods --- //

    /// <summary>
    /// 맵 선택 패널을 활성화하고 관련된 모든 UI를 최신 상태로 업데이트합니다.
    /// 다른 UI 관리자(예: CardRewardUIManager)에 의해 호출됩니다.
    /// </summary>
    public void Show()
    {
        Debug.Log($"[{GetType().Name}] Show()가 호출되었습니다. 맵 선택 UI를 활성화합니다.");

        // 맵 뷰를 생성하기 전에, MapManager가 유효한 맵 데이터를 가지고 있는지 다시 확인합니다.
        GenerateMapView();

        routeSelectPanel.SetActive(true);
        UpdateNodeInteractability();
        mapView.SetupAllNodeNavigations(rewardPageButton); // 컨트롤러 네비게이션 설정
        StartCoroutine(SetFocusRoutine()); // 포커스 설정
    }

    /// <summary>
    /// 맵 선택 패널을 비활성화합니다.
    /// </summary>
    public void Hide()
    {
        routeSelectPanel.SetActive(false);
    }

    /// <summary>
    /// '보상 페이지로' 버튼을 클릭했을 때, 다시 카드 보상 UI로 돌아갑니다.
    /// </summary>
    public void GoBackToCardReward()
    {
        Debug.Log($"[{GetType().Name}] '보상 페이지로' 버튼이 클릭되었습니다. 카드 보상 UI로 돌아갑니다.");
        Hide();

        var cardRewardUI = ServiceLocator.Get<CardRewardUIManager>();
        if (cardRewardUI != null)
        {
            cardRewardUI.Show();
        }
    }

    // --- Private Helper Methods --- //

    /// <summary>
    /// MapManager의 데이터를 기반으로 MapView에 맵을 그리도록 지시합니다.
    /// </summary>
    private void GenerateMapView()
    {
        var mapManager = ServiceLocator.Get<MapManager>();

        // [디버깅] 맵이 그려지지 않는 문제의 원인을 찾기 위한 핵심 확인 지점입니다.
        if (mapManager == null || !mapManager.IsMapInitialized)
        {
            Debug.LogError($"[{GetType().Name}] CRITICAL: MapManager를 찾을 수 없거나, 맵 데이터가 초기화되지 않았습니다! (IsMapInitialized: {(mapManager != null ? mapManager.IsMapInitialized.ToString() : "N/A")}). 맵이 그려지지 않을 것입니다.");
            return;
        }

        Debug.Log($"[{GetType().Name}] 유효한 MapManager를 찾았습니다. MapView 생성을 시작합니다.");
        mapView.GenerateMapView(mapManager.AllNodes, mapManager.MapWidth, mapManager.MapHeight);
    }

    /// <summary>
    /// MapView에서 특정 노드가 클릭되었을 때 호출되는 이벤트 핸들러입니다.
    /// </summary>
    // ▼▼▼▼▼ OnNodeClicked 함수를 아래 내용으로 교체 ▼▼▼▼▼
    private void OnNodeClicked(MapNode node)
    {
        // 실제 로직은 코루틴에서 처리하도록 변경
        StartCoroutine(SelectNodeAndPreload(node));
    }

    /// <summary>
    /// 노드 선택 후, 다음 라운드에 필요한 에셋을 프리로드하고 씬을 전환하는 코루틴입니다.
    /// </summary>
    private IEnumerator SelectNodeAndPreload(MapNode node)
    {
        Debug.Log($"[{GetType().Name}] 노드 {node.Position} 선택됨. 다음 라운드 프리로딩을 시작합니다.");

        // 다른 노드를 중복 클릭하는 것을 방지하기 위해 모든 노드 비활성화
        mapView.UpdateNodeInteractability(new List<MapNode>());

        // 필요한 매니저들 가져오기
        var gameManager = ServiceLocator.Get<GameManager>();
        var campaignManager = ServiceLocator.Get<CampaignManager>();
        var mapManager = ServiceLocator.Get<MapManager>();

        // 다음 라운드 데이터 가져오기
        RoundDataSO nextRoundData = campaignManager.GetRoundDataForNode(node);

        // GameManager의 새 프리로더를 호출하고 끝날 때까지 대기
        yield return StartCoroutine(gameManager.PreloadAssetsForRound(nextRoundData, null));

        // 프리로딩이 끝나면 맵 위치를 업데이트하고 씬 전환
        mapManager.MoveToNode(node);
        Hide();
        gameManager.ChangeState(GameManager.GameState.Gameplay);
    }
    // ▲▲▲▲▲ 여기까지 교체 및 추가 ▲▲▲▲▲


    /// <summary>
    /// 현재 플레이어가 이동할 수 있는 노드만 활성화하도록 MapView에 지시합니다.
    /// </summary>
    // ▼▼▼▼▼▼▼▼▼▼▼ [이 함수 전체를 아래 코드로 교체하세요] ▼▼▼▼▼▼▼▼▼▼▼
    private void UpdateNodeInteractability()
    {
        var mapManager = ServiceLocator.Get<MapManager>();
        if (mapManager == null) return;

        List<MapNode> reachableNodes = mapManager.GetReachableNodes();
        mapView.UpdateNodeInteractability(reachableNodes);
    }

    /// <summary>
    /// UI가 활성화된 후, 현재 상황에 맞는 버튼에 자동으로 포커스를 설정하는 코루틴입니다.
    /// </summary>
    private IEnumerator SetFocusRoutine()
    {
        yield return null; // UI가 완전히 활성화될 때까지 한 프레임 대기
        EventSystem.current.SetSelectedGameObject(null);
        GameObject targetObjectToFocus = null;

        // [핵심 로직] RewardManager의 상태를 직접 가져와 '보상 페이지로' 버튼의 활성화 여부를 결정합니다.
        var rewardManager = ServiceLocator.Get<RewardManager>();
        // RewardManager가 없거나, 있더라도 보상 선택이 완료된 상태라면 true가 됩니다.
        bool isRewardSelectionComplete = (rewardManager == null || rewardManager.IsRewardSelectionComplete);

        Debug.Log($"[{GetType().Name}] 포커스 설정 중... RewardManager의 보상 선택 완료 상태: {isRewardSelectionComplete}");

        if (rewardPageButton != null)
        {
            // 보상 선택이 완료되지 않았을 때만 '보상 페이지로' 버튼을 활성화합니다.
            rewardPageButton.gameObject.SetActive(!isRewardSelectionComplete);
        }

        if (isRewardSelectionComplete)
        {
            // 보상 선택이 끝났다면, 선택 가능한 맵 노드 중 가장 왼쪽에 있는 노드에 포커스를 줍니다.
            targetObjectToFocus = mapView.FindLeftmostAvailableNode(ServiceLocator.Get<MapManager>().GetReachableNodes());
            Debug.Log($"[{GetType().Name}] 포커스 대상: 맵 노드 ({(targetObjectToFocus != null ? targetObjectToFocus.name : "없음")})");
        }
        else
        {
            // 아직 보상 선택이 끝나지 않았다면, '보상 페이지로' 버튼에 포커스를 줍니다.
            if (rewardPageButton != null)
            {
                targetObjectToFocus = rewardPageButton.gameObject;
                Debug.Log($"[{GetType().Name}] 포커스 대상: '보상 페이지로' 버튼");
            }
        }

        // 최종적으로 결정된 대상에 포커스를 설정합니다.
        if (targetObjectToFocus != null)
        {
            EventSystem.current.SetSelectedGameObject(targetObjectToFocus);
        }
    }
}

==================== PopupController.cs (경로: ./TTttTT/Assets/1.Scripts/UI/PopupController.cs) ====================
using UnityEngine;
using TMPro;
using UnityEngine.UI;
using System.Collections;
using System; // Action 사용을 위해 필요

/// <summary>
/// 게임 전체에서 사용될 수 있는 범용 팝업 UI를 관리하는 싱글톤 클래스입니다.
/// 간단한 오류 메시지를 일정 시간 동안 보여주거나, 
/// 사용자에게 확인/취소 선택지를 제공하는 확인(Confirm) 팝업을 생성합니다.
/// </summary>
public class PopupController : MonoBehaviour
{
    [Header("오류 팝업 참조")]
    [SerializeField] private GameObject errorPopupPanel; // 오류 메시지 패널
    [SerializeField] private TextMeshProUGUI errorText; // 오류 메시지 텍스트

    [Header("확인 팝업 참조")]
    [SerializeField] private GameObject confirmPopupPanel; // 확인 팝업 패널
    [SerializeField] private TextMeshProUGUI confirmText; // 확인 메시지 텍스트
    [SerializeField] private Button confirmYesButton; // '예' 버튼
    [SerializeField] private Button confirmNoButton; // '아니오' 버튼

    private Action onConfirmYes; // '예' 버튼 클릭 시 실행될 콜백
    private Action onConfirmNo; // '아니오' 버튼 클릭 시 실행될 콜백

    void Awake()
    {
        if (!ServiceLocator.IsRegistered<PopupController>())
        {
            ServiceLocator.Register<PopupController>(this);
            DontDestroyOnLoad(gameObject);

            // 버튼 리스너 초기화
            confirmYesButton.onClick.AddListener(OnConfirmYesClicked);
            confirmNoButton.onClick.AddListener(OnConfirmNoClicked);

            // 초기에는 모든 팝업을 비활성화
            errorPopupPanel.SetActive(false);
            confirmPopupPanel.SetActive(false);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    /// <summary>
    /// 지정된 시간 동안 오류 메시지 팝업을 표시합니다.
    /// </summary>
    /// <param name="message">표시할 메시지</param>
    /// <param name="duration">표시 시간(초)</param>
    public void ShowError(string message, float duration = 2f)
    {
        errorText.text = message;
        StartCoroutine(ShowErrorRoutine(duration));
    }

    private IEnumerator ShowErrorRoutine(float duration)
    {
        errorPopupPanel.SetActive(true);
        yield return new WaitForSeconds(duration);
        errorPopupPanel.SetActive(false);
    }

    /// <summary>
    /// 확인/취소 버튼이 있는 확인 팝업을 표시합니다.
    /// </summary>
    /// <param name="message">표시할 메시지</param>
    /// <param name="onYes">'예'를 눌렀을 때 실행될 동작</param>
    /// <param name="onNo">'아니오'를 눌렀을 때 실행될 동작 (선택 사항)</param>
    public void ShowConfirm(string message, Action onYes, Action onNo = null)
    {
        confirmText.text = message;
        onConfirmYes = onYes;
        onConfirmNo = onNo;
        confirmPopupPanel.SetActive(true);
    }

    private void OnConfirmYesClicked()
    {
        // '예' 콜백이 있다면 실행
        onConfirmYes?.Invoke();
        confirmPopupPanel.SetActive(false);
    }

    private void OnConfirmNoClicked()
    {
        // '아니오' 콜백이 있다면 실행
        onConfirmNo?.Invoke();
        confirmPopupPanel.SetActive(false);
    }
}


==================== SynthesisPopup.cs (경로: ./TTttTT/Assets/1.Scripts/UI/SynthesisPopup.cs) ====================
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;
using System;
using TMPro;
using System.Collections; // <-- [1] Coroutine 사용을 위해 추가
using UnityEngine.EventSystems; // <-- [2] EventSystem 사용을 위해 추가

/// <summary>
/// 카드 합성에 사용할 재료를 선택하는 팝업 UI를 제어합니다.
/// </summary>
public class SynthesisPopup : MonoBehaviour
{
    [Header("UI 요소 참조")]
    [SerializeField] private GameObject contentPanel; // 카드들이 표시될 부모 오브젝트
    [SerializeField] private GameObject cardDisplayPrefab; // 재료 카드를 표시할 UI 프리팹 (CardDisplay.cs 포함)
    [SerializeField] private Button confirmButton;
    [SerializeField] private Button cancelButton;
    [SerializeField] private TextMeshProUGUI titleText;

    private Action<CardDataSO> onConfirm; // 확인 시 선택된 카드를 전달할 콜백
    private Action onCancel; // <-- [1] 취소 콜백을 저장할 변수 추가
    private CardDataSO selectedMaterialCard;
    private List<CardDisplay> spawnedCardDisplays = new List<CardDisplay>();

    void Awake()
    {
        confirmButton.onClick.AddListener(OnConfirmClicked);
        cancelButton.onClick.AddListener(OnCancelClicked);
    }

    /// <summary>
    /// 팝업을 초기화하고 재료 카드 목록을 표시합니다.
    /// </summary>
    /// <param name="baseCardName">합성의 기준이 되는 카드 이름</param>
    /// <param name="materialChoices">재료로 사용할 수 있는 카드 목록</param>
    /// <param name="confirmCallback">확인 버튼 클릭 시 실행될 콜백</param>
    public void Initialize(string baseCardName, List<CardDataSO> materialChoices, Action<CardDataSO> confirmCallback, Action onCancelCallback)
    {
        gameObject.SetActive(true);
        onConfirm = confirmCallback;
        onCancel = onCancelCallback; // <-- [3] 전달받은 취소 콜백 저장
        selectedMaterialCard = null;
        UpdateConfirmButton();

        if (titleText != null) titleText.text = $"Select '{baseCardName}' to use as your composite card.";

        // 기존 UI 삭제
        foreach (var display in spawnedCardDisplays) Destroy(display.gameObject);
        spawnedCardDisplays.Clear();
        
        // ▼▼▼▼▼ [3] 포커스 설정을 위한 코루틴을 시작하는 코드 추가 ▼▼▼▼▼
        StartCoroutine(SetInitialPopupFocus());

        // 재료 카드 목록 UI 생성
        foreach (var card in materialChoices)
        {
            GameObject cardUI = Instantiate(cardDisplayPrefab, contentPanel.transform);

            CardDisplay cardDisplay = cardUI.GetComponent<CardDisplay>();
            if (cardDisplay != null)
            {
                cardDisplay.Setup(card);
                // 팝업 내의 카드 클릭 시 OnMaterialCardSelected를 호출하도록 리스너 재설정
                cardDisplay.selectButton.onClick.RemoveAllListeners();
                cardDisplay.selectButton.onClick.AddListener(() => OnMaterialCardSelected(cardDisplay));
                spawnedCardDisplays.Add(cardDisplay);
            }
        }
    }

    /// <summary>
    /// 팝업 내에서 재료 카드가 선택되었을 때 호출됩니다.
    /// </summary>
    private void OnMaterialCardSelected(CardDisplay selectedDisplay)
    {
        selectedMaterialCard = selectedDisplay.GetCurrentCard();

        // 하이라이트 처리
        foreach (var display in spawnedCardDisplays)
        {
            display.SetHighlight(display == selectedDisplay);
        }
        UpdateConfirmButton();
    }

    private void UpdateConfirmButton()
    {
        confirmButton.interactable = (selectedMaterialCard != null);
    }

    private void OnConfirmClicked()
    {
        if (selectedMaterialCard != null)
        {
            onConfirm?.Invoke(selectedMaterialCard);
        }
        gameObject.SetActive(false);
    }

    private void OnCancelClicked()
    {
        onCancel?.Invoke(); // <-- [4] 저장해둔 취소 콜백 실행
        gameObject.SetActive(false);
    }

    // ▼▼▼▼▼ [4] 아래 코루틴 함수 전체를 새로 추가 ▼▼▼▼▼
    /// <summary>
    /// 팝업이 나타난 후, UI 포커스를 팝업 내부의 버튼으로 설정합니다.
    /// </summary>
    private IEnumerator SetInitialPopupFocus()
    {
        // UI 요소들이 완전히 활성화될 시간을 벌기 위해 한 프레임 대기합니다.
        yield return null;

        // EventSystem의 현재 선택된 오브젝트를 null로 초기화하여 이전 포커스를 지웁니다.
        EventSystem.current.SetSelectedGameObject(null);

        // '취소' 버튼이 존재하고 활성화 상태라면, 그곳에 포커스를 맞춥니다.
        if (cancelButton != null && cancelButton.interactable)
        {
            EventSystem.current.SetSelectedGameObject(cancelButton.gameObject);
            Debug.Log("[SynthesisPopup] UI 포커스를 '취소' 버튼으로 설정했습니다.");
        }
    }
}


==================== RewardSceneController.cs (경로: ./TTttTT/Assets/1.Scripts/UI/RewardSceneController.cs) ====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class RewardSceneController : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}


==================== GeneBoosterRoulette.cs (경로: ./TTttTT/Assets/1.Scripts/UI/GeneBoosterRoulette.cs) ====================
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;
using TMPro;
using System.Collections;

public class GeneBoosterRoulette : MonoBehaviour
{
    [Header("UI 요소 참조")]
    [SerializeField] private Button spinRouletteButton;
    [SerializeField] private TextMeshProUGUI genePointsText;
    [SerializeField] private TMP_InputField pointsToInvestInput;
    [SerializeField] private Button investButton;
    [SerializeField] private List<GameObject> statUIs;
    [SerializeField] private Image spinRouletteButtonImage;

    private const int ROULETTE_COST = 15;

    private CharacterPermanentStats permanentStats;

    // --- [추가] 서비스 로케이터를 통해 매니저 인스턴스를 저장할 변수 ---
    private ProgressionManager progressionManager;
    private PopupController popupController;

    void Start()
    {
        // --- [추가] 서비스 로케이터를 통해 필요한 매니저를 미리 찾아둡니다. ---
        progressionManager = ServiceLocator.Get<ProgressionManager>();
        popupController = ServiceLocator.Get<PopupController>();
        var gameManager = ServiceLocator.Get<GameManager>();

        string characterId = "warrior";
        if (gameManager != null && gameManager.SelectedCharacter != null)
        {
            characterId = gameManager.SelectedCharacter.characterId;
        }

        permanentStats = progressionManager.GetPermanentStatsFor(characterId);

        spinRouletteButton.onClick.AddListener(SpinRoulette);
        investButton.onClick.AddListener(InvestPoints);

        UpdateUI();
    }

    private void UpdateUI()
    {
        // --- [수정] 미리 찾아둔 progressionManager 변수를 사용합니다. ---
        genePointsText.text = $"보유 포인트: {progressionManager.GenePoints}";

        bool canSpin = progressionManager.GenePoints >= ROULETTE_COST && !permanentStats.AllStatsUnlocked();
        spinRouletteButton.interactable = canSpin;
        if (spinRouletteButtonImage != null)
        {
            spinRouletteButtonImage.color = canSpin ? Color.white : Color.gray;
        }

        investButton.interactable = progressionManager.GenePoints > 0;
    }

    private void SpinRoulette()
    {
        // --- [수정] 미리 찾아둔 변수들을 사용합니다. ---
        if (!progressionManager.SpendCurrency(MetaCurrencyType.GenePoints, ROULETTE_COST))
        {
            if (popupController != null) popupController.ShowError("유전자 포인트가 부족합니다.", 1.5f);
            return;
        }

        List<StatType> availableStats = permanentStats.GetLockedStats();
        if (availableStats.Count == 0)
        {
            if (popupController != null) popupController.ShowError("모든 스탯이 이미 해금되었습니다.", 1.5f);
            return;
        }

        StartCoroutine(SpinRouletteAnimation(availableStats));
    }

    private IEnumerator SpinRouletteAnimation(List<StatType> availableStats)
    {
        spinRouletteButton.interactable = false;
        Debug.Log("룰렛 애니메이션 시작...");

        yield return new WaitForSeconds(2f);

        StatType unlockedStat = availableStats[Random.Range(0, availableStats.Count)];
        permanentStats.UnlockStat(unlockedStat);
        Debug.Log($"룰렛 결과: {unlockedStat} 능력치 해금!");

        spinRouletteButton.interactable = true;
        UpdateUI();
    }

    private void InvestPoints()
    {
        if (!int.TryParse(pointsToInvestInput.text, out int points) || points <= 0)
        {
            // --- [수정] 미리 찾아둔 popupController 변수를 사용합니다. ---
            if (popupController != null) popupController.ShowError("유효한 투자 포인트를 입력하세요.", 1.5f);
            return;
        }

        // --- [수정] 미리 찾아둔 progressionManager 변수를 사용합니다. ---
        points = Mathf.Min(points, progressionManager.GenePoints);

        if (!progressionManager.SpendCurrency(MetaCurrencyType.GenePoints, points))
        {
            if (popupController != null) popupController.ShowError("투자에 필요한 유전자 포인트가 부족합니다.", 1.5f);
            return;
        }

        permanentStats.DistributePoints(points);
        Debug.Log($"{points} 포인트를 해금된 능력치에 랜덤하게 투자했습니다.");

        UpdateUI();
    }
}

==================== OptionsController.cs (경로: ./TTttTT/Assets/1.Scripts/UI/OptionsController.cs) ====================
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Collections.Generic;

public class OptionsController : MonoBehaviour
{
    [Header("그래픽 설정 참조")]
    [SerializeField] private TMP_Dropdown resolutionDropdown;
    [SerializeField] private Toggle fullscreenToggle;

    [Header("오디오 설정 참조")]
    [SerializeField] private Slider bgmVolumeSlider;
    [SerializeField] private Slider sfxVolumeSlider;

    [Header("언어 및 접근성 참조")]
    [SerializeField] private TMP_Dropdown languageDropdown;
    [SerializeField] private Slider fontSizeSlider;
    [SerializeField] private CanvasScaler mainCanvasScaler;

    private Resolution[] resolutions;

    // --- [추가] AudioManager 인스턴스를 저장할 변수 ---
    private AudioManager audioManager;

    void Start()
    {
        // --- [추가] ServiceLocator를 통해 AudioManager를 찾아옵니다. ---
        audioManager = ServiceLocator.Get<AudioManager>();

        resolutionDropdown.onValueChanged.AddListener(SetResolution);
        fullscreenToggle.onValueChanged.AddListener(SetFullscreen);
        bgmVolumeSlider.onValueChanged.AddListener(SetBgmVolume);
        sfxVolumeSlider.onValueChanged.AddListener(SetSfxVolume);
        languageDropdown.onValueChanged.AddListener(SetLanguage);
        fontSizeSlider.onValueChanged.AddListener(SetFontSize);

        InitializeGraphicsSettings();
        InitializeAudioSettings();
        InitializeAccessibilitySettings();
        LoadSettings();
    }

    private void InitializeGraphicsSettings()
    {
        resolutions = Screen.resolutions;
        resolutionDropdown.ClearOptions();
        List<string> options = new List<string>();
        int currentResolutionIndex = 0;
        for (int i = 0; i < resolutions.Length; i++)
        {
            string option = resolutions[i].width + " x " + resolutions[i].height;
            options.Add(option);
            if (resolutions[i].width == Screen.currentResolution.width &&
                resolutions[i].height == Screen.currentResolution.height)
            {
                currentResolutionIndex = i;
            }
        }
        resolutionDropdown.AddOptions(options);
        resolutionDropdown.value = currentResolutionIndex;
        resolutionDropdown.RefreshShownValue();

        fullscreenToggle.isOn = Screen.fullScreen;
    }

    private void InitializeAudioSettings()
    {
        // --- [수정] 찾아온 audioManager 인스턴스를 사용합니다. ---
        if (audioManager != null)
        {
            bgmVolumeSlider.value = audioManager.GetBgmVolume();
            sfxVolumeSlider.value = audioManager.GetSfxVolume();
        }
    }

    private void InitializeAccessibilitySettings()
    {
        languageDropdown.ClearOptions();
        languageDropdown.AddOptions(new List<string> { "한국어", "English" });
        languageDropdown.value = 0;
        languageDropdown.RefreshShownValue();

        fontSizeSlider.minValue = 0.5f;
        fontSizeSlider.maxValue = 1.5f;
        fontSizeSlider.value = 1.0f;
    }

    public void SetResolution(int resolutionIndex)
    {
        Resolution resolution = resolutions[resolutionIndex];
        Screen.SetResolution(resolution.width, resolution.height, Screen.fullScreen);
        Debug.Log($"해상도 변경: {resolution.width}x{resolution.height}");
        SaveSettings();
    }

    public void SetFullscreen(bool isFullscreen)
    {
        Screen.fullScreen = isFullscreen;
        Debug.Log($"전체화면 모드: {isFullscreen}");
        SaveSettings();
    }

    public void SetBgmVolume(float volume)
    {
        // --- [수정] 찾아온 audioManager 인스턴스를 사용합니다. ---
        if (audioManager != null)
        {
            audioManager.SetVolume(volume, sfxVolumeSlider.value);
        }
        SaveSettings();
    }

    public void SetSfxVolume(float volume)
    {
        // --- [수정] 찾아온 audioManager 인스턴스를 사용합니다. ---
        if (audioManager != null)
        {
            audioManager.SetVolume(bgmVolumeSlider.value, volume);
        }
        SaveSettings();
    }

    public void SetLanguage(int languageIndex)
    {
        string languageCode = languageDropdown.options[languageIndex].text;
        Debug.Log($"언어 변경: {languageCode}");
        SaveSettings();
    }

    public void SetFontSize(float scale)
    {
        if (mainCanvasScaler != null)
        {
            mainCanvasScaler.dynamicPixelsPerUnit = 1.0f * scale;
            Debug.Log($"폰트 크기 변경: {scale}");
        }
        else
        {
            Debug.LogWarning("mainCanvasScaler가 할당되지 않았습니다. 폰트 크기를 변경할 수 없습니다.");
        }
        SaveSettings();
    }

    public void SaveSettings()
    {
        PlayerPrefs.SetInt("ResolutionIndex", resolutionDropdown.value);
        PlayerPrefs.SetInt("Fullscreen", fullscreenToggle.isOn ? 1 : 0);
        PlayerPrefs.SetFloat("BGMVolume", bgmVolumeSlider.value);
        PlayerPrefs.SetFloat("SFXVolume", sfxVolumeSlider.value);
        PlayerPrefs.SetInt("LanguageIndex", languageDropdown.value);
        PlayerPrefs.SetFloat("FontSizeScale", fontSizeSlider.value);
        PlayerPrefs.Save();
        Debug.Log("설정이 저장되었습니다.");
    }

    private void LoadSettings()
    {
        if (PlayerPrefs.HasKey("ResolutionIndex"))
        {
            resolutionDropdown.value = PlayerPrefs.GetInt("ResolutionIndex");
            resolutionDropdown.RefreshShownValue();
            SetResolution(resolutionDropdown.value);
        }
        if (PlayerPrefs.HasKey("Fullscreen"))
        {
            fullscreenToggle.isOn = PlayerPrefs.GetInt("Fullscreen") == 1;
            SetFullscreen(fullscreenToggle.isOn);
        }
        if (PlayerPrefs.HasKey("BGMVolume"))
        {
            bgmVolumeSlider.value = PlayerPrefs.GetFloat("BGMVolume");
            SetBgmVolume(bgmVolumeSlider.value);
        }
        if (PlayerPrefs.HasKey("SFXVolume"))
        {
            sfxVolumeSlider.value = PlayerPrefs.GetFloat("SFXVolume");
            SetSfxVolume(sfxVolumeSlider.value);
        }
        if (PlayerPrefs.HasKey("LanguageIndex"))
        {
            languageDropdown.value = PlayerPrefs.GetInt("LanguageIndex");
            languageDropdown.RefreshShownValue();
            SetLanguage(languageDropdown.value);
        }
        if (PlayerPrefs.HasKey("FontSizeScale"))
        {
            fontSizeSlider.value = PlayerPrefs.GetFloat("FontSizeScale");
            SetFontSize(fontSizeSlider.value);
        }
        Debug.Log("설정을 불러왔습니다.");
    }
}

==================== CodexController.cs (경로: ./TTttTT/Assets/1.Scripts/UI/CodexController.cs) ====================
// 파일 경로: Assets/1.Scripts/UI/CodexController.cs
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

public class CodexController : MonoBehaviour
{
    [Header("UI 요소 참조")]
    [SerializeField] private GameObject cardCodexPanel;
    [SerializeField] private GameObject artifactCodexPanel;
    [SerializeField] private Button cardTabButton;
    [SerializeField] private Button artifactTabButton;
    [SerializeField] private ScrollRect cardScrollRect;
    [SerializeField] private ScrollRect artifactScrollRect;
    [SerializeField] private GameObject itemInfoPrefab;

    private List<CardDataSO> allCards;
    private List<ArtifactDataSO> allArtifacts;
    private Dictionary<string, CodexItemDisplay> displayedCodexItems = new Dictionary<string, CodexItemDisplay>();
    private ProgressionManager progressionManager;
    private PopupController popupController;
    private DataManager dataManager;
    void Awake()
    {
        cardTabButton.onClick.AddListener(ShowCardCodex);
        artifactTabButton.onClick.AddListener(ShowArtifactCodex);
        progressionManager = ServiceLocator.Get<ProgressionManager>();
        popupController = ServiceLocator.Get<PopupController>();
        dataManager = ServiceLocator.Get<DataManager>();
    }

    void OnEnable()
    {
        LoadData();
        PopulateCodex();
        ShowCardCodex();
    }

    private void LoadData()
    {
        allCards = dataManager.GetAllCards();
        allArtifacts = dataManager.GetAllArtifacts();
    }

    private void PopulateCodex()
    {
        displayedCodexItems.Clear();
        foreach (Transform child in cardScrollRect.content) Destroy(child.gameObject);
        cardScrollRect.content.DetachChildren();

        foreach (var card in allCards)
        {
            GameObject itemUI = Instantiate(itemInfoPrefab, cardScrollRect.content);
            CodexItemDisplay display = itemUI.GetComponent<CodexItemDisplay>();
            if (display != null)
            {
                bool isUnlocked = progressionManager.IsCodexItemUnlocked(card.basicInfo.cardID);
                display.SetupForCard(card, isUnlocked);
                display.SetHintButtonClickListener(card.basicInfo.cardID, PurchaseHint);
                displayedCodexItems[card.basicInfo.cardID] = display;
            }
        }

        foreach (Transform child in artifactScrollRect.content) Destroy(child.gameObject);
        artifactScrollRect.content.DetachChildren();

        if (allArtifacts != null)
        {
            foreach (var artifact in allArtifacts)
            {
                GameObject itemUI = Instantiate(itemInfoPrefab, artifactScrollRect.content);
                CodexItemDisplay display = itemUI.GetComponent<CodexItemDisplay>();
                if (display != null)
                {
                    bool isUnlocked = progressionManager.IsCodexItemUnlocked(artifact.artifactID);
                    display.SetupForArtifact(artifact, isUnlocked);
                    display.SetHintButtonClickListener(artifact.artifactID, PurchaseHint);
                    displayedCodexItems[artifact.artifactID] = display;
                }
            }
        }
        Debug.Log("도감 데이터를 기반으로 UI를 모두 생성했습니다.");
    }

    private void ShowCardCodex()
    {
        cardCodexPanel.SetActive(true);
        artifactCodexPanel.SetActive(false);
        cardTabButton.image.color = Color.white;
        artifactTabButton.image.color = Color.gray;
    }

    private void ShowArtifactCodex()
    {
        cardCodexPanel.SetActive(false);
        artifactCodexPanel.SetActive(true);
        cardTabButton.image.color = Color.gray;
        artifactTabButton.image.color = Color.white;
    }

    public void PurchaseHint(string itemId)
    {
        int hintCost = 10;
        if (progressionManager.SpendCurrency(MetaCurrencyType.KnowledgeShards, hintCost))
        {
            Debug.Log($"{itemId}의 힌트를 구매했습니다.");
            if (displayedCodexItems.TryGetValue(itemId, out CodexItemDisplay display))
            {
                display.ShowHint();
            }
            if (popupController != null) popupController.ShowError("힌트 구매 성공!", 1.5f);
        }
        else
        {
            Debug.LogWarning("힌트 구매에 필요한 지식의 파편이 부족합니다.");
            if (popupController != null) popupController.ShowError("지식의 파편이 부족합니다!", 1.5f);
        }
    }
}

==================== CardDisplay.cs (경로: ./TTttTT/Assets/1.Scripts/UI/CardDisplay.cs) ====================
// CardDisplay.cs (최종 수정본)
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using UnityEngine.Events;

// [수정] 이벤트가 CardDataSO 대신 CardDisplay 자신을 전달하도록 변경합니다.
[System.Serializable]
public class CardSelectedEvent : UnityEvent<CardDisplay> { }

public class CardDisplay : MonoBehaviour
{
    [Header("UI 요소 참조")]
    [SerializeField] private TextMeshProUGUI nameText;
    [SerializeField] private TextMeshProUGUI descriptionText;
    [SerializeField] private Image cardBackgroundImage;
    [SerializeField] private Image cardIconImage;
    [SerializeField] private Image rarityImage;
    [SerializeField] private Image highlightBorder;

    public Button selectButton;
    public CardSelectedEvent OnCardSelected;

    private CardDataSO currentCard;
    public CardDataSO CurrentCard => currentCard;

    public CardDataSO GetCurrentCard()
    {
        return currentCard;
    }

    public void Setup(CardDataSO cardData)
    {
        currentCard = cardData;

        if (nameText != null) nameText.text = cardData.basicInfo.cardName;
        if (descriptionText != null) descriptionText.text = cardData.basicInfo.effectDescription;
        if (cardIconImage != null && cardData.basicInfo.cardIcon != null)
        {
            cardIconImage.sprite = cardData.basicInfo.cardIcon;
        }
        if (rarityImage != null)
        {
            rarityImage.sprite = UIGraphicsDB.Instance.GetRaritySprite(cardData.basicInfo.rarity);
        }
        if (selectButton != null)
        {
            selectButton.onClick.RemoveAllListeners();
            // [수정] 이벤트 발생 시 카드 데이터(currentCard) 대신 CardDisplay 컴포넌트(this)를 전달합니다.
            selectButton.onClick.AddListener(() => OnCardSelected.Invoke(this));
        }
    }

    public void SetHighlight(bool isSelected)
    {
        if (highlightBorder != null)
        {
            highlightBorder.gameObject.SetActive(isSelected);
        }
    }
}

==================== CharacterSelectUI.cs (경로: ./TTttTT/Assets/1.Scripts/UI/CharacterSelectUI.cs) ====================
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class CharacterSelectUI : MonoBehaviour
{
    [Header("컨트롤러 참조")]
    [SerializeField] private CharacterSelectController controller;
    [Header("UI 요소 참조")]
    [SerializeField] private TextMeshProUGUI totalPointsText;
    [Header("캐릭터별 일러스트 오브젝트 참조")]
    [SerializeField] private GameObject warriorCharacterIllust;
    [SerializeField] private GameObject archerCharacterIllust;
    [SerializeField] private GameObject mageCharacterIllust;
    [Header("버튼 목록")]
    [SerializeField] private Button warriorButton;
    [SerializeField] private Button archerButton;
    [SerializeField] private Button mageButton;
    [SerializeField] private Button startButton;
    [Header("선택 상태 시각화")]
    [SerializeField] private Color selectedButtonColor = Color.yellow;
    [SerializeField] private Color unselectedButtonColor = Color.white;
    private Button currentlySelectedCharacterButton;

    void Awake()
    {
        warriorButton.onClick.AddListener(() => SelectCharacter(CharacterIDs.Warrior));
        archerButton.onClick.AddListener(() => SelectCharacter(CharacterIDs.Archer));
        mageButton.onClick.AddListener(() => SelectCharacter(CharacterIDs.Mage));
        startButton.onClick.AddListener(OnGameStartClicked);
    }

    void Start()
    {
        DeactivateAllCharacterIllustrations();
        if (totalPointsText != null) totalPointsText.text = "보유 포인트: --";
        ResetButtonColors();
    }

    private void ResetButtonColors()
    {
        warriorButton.image.color = unselectedButtonColor;
        archerButton.image.color = unselectedButtonColor;
        mageButton.image.color = unselectedButtonColor;
        currentlySelectedCharacterButton = null;
    }

    private void DeactivateAllCharacterIllustrations()
    {
        if (warriorCharacterIllust != null) warriorCharacterIllust.SetActive(false);
        if (archerCharacterIllust != null) archerCharacterIllust.SetActive(false);
        if (mageCharacterIllust != null) mageCharacterIllust.SetActive(false);
    }

    private void SelectCharacter(string characterId)
    {
        CharacterDataSO characterData = ServiceLocator.Get<DataManager>().GetCharacter(characterId);
        if (characterData == null) return;

        controller.OnCharacterSelected(characterData);
        UpdateCharacterInfo(characterData);
        DeactivateAllCharacterIllustrations();

        if (currentlySelectedCharacterButton != null)
        {
            currentlySelectedCharacterButton.image.color = unselectedButtonColor;
        }

        switch (characterId)
        {
            case CharacterIDs.Warrior:
                if (warriorCharacterIllust != null) warriorCharacterIllust.SetActive(true);
                currentlySelectedCharacterButton = warriorButton;
                break;
            case CharacterIDs.Archer:
                if (archerCharacterIllust != null) archerCharacterIllust.SetActive(true);
                currentlySelectedCharacterButton = archerButton;
                break;
            case CharacterIDs.Mage:
                if (mageCharacterIllust != null) mageCharacterIllust.SetActive(true);
                currentlySelectedCharacterButton = mageButton;
                break;
        }

        if (currentlySelectedCharacterButton != null)
        {
            currentlySelectedCharacterButton.image.color = selectedButtonColor;
        }
    }

    private void UpdateCharacterInfo(CharacterDataSO characterData)
    {
        if (totalPointsText != null)
        {
            totalPointsText.text = $"보유 포인트: {characterData.initialAllocationPoints}";
        }
    }

    private void OnGameStartClicked()
    {
        controller.ProceedToPointAllocation();
    }
}

==================== HUDController.cs (경로: ./TTttTT/Assets/1.Scripts/UI/HUDController.cs) ====================
// --- 파일명: HUDController.cs (추적 디버깅 버전) ---
// 역할: HUD의 전체 생명주기를 추적하여 문제의 원인을 찾습니다.
// 수정 내용: Awake, OnEnable, Start, OnDisable, OnDestroy 등 모든 주요 함수에
//           실행 시점을 알리는 디버그 로그를 추가했습니다.
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class HUDController : MonoBehaviour
{
    [SerializeField] private Slider healthBar;
    [SerializeField] private TextMeshProUGUI timerText;
    [SerializeField] private TextMeshProUGUI killCountText;

    private int instanceId;

    // 1. 스크립트 인스턴스가 처음 로드될 때 호출됩니다. (게임 오브젝트가 비활성화 상태여도 호출됨)
    private void Awake()
    {
        // Awake에서 고유한 ID를 생성합니다. GetInstanceID()는 모든 유니티 오브젝트가 가진 고유 번호입니다.
        instanceId = gameObject.GetInstanceID();
        Debug.Log($"[HUD 추적 ID: {instanceId}] {gameObject.name} - Awake() 호출됨. (Frame: {Time.frameCount})");
    }

    private void OnEnable()
    {
        Debug.Log($"[HUD 추적 ID: {instanceId}] {gameObject.name} - OnEnable() 호출됨. 이벤트 구독 시작. (Frame: {Time.frameCount})");
        RoundManager.OnRoundStarted += HandleRoundStarted;
        RoundManager.OnKillCountChanged += UpdateKillCount;
        RoundManager.OnTimerChanged += UpdateTimer;
        RoundManager.OnRoundEnded += HandleRoundEnd;
    }

    private void Start()
    {
        Debug.Log($"[HUD 추적 ID: {instanceId}] {gameObject.name} - Start() 호출됨. (Frame: {Time.frameCount})");
    }

    private void HandleRoundStarted(RoundDataSO roundData)
    {
        // [유령 추적 2] 어떤 HUD가 방송을 수신하는지 확인합니다.
        UpdateKillCount(0, roundData.killGoal);
        UpdateTimer(roundData.roundDuration);
    }

    private void OnDisable()
    {
        RoundManager.OnRoundStarted -= HandleRoundStarted;
        RoundManager.OnKillCountChanged -= UpdateKillCount;
        RoundManager.OnTimerChanged -= UpdateTimer;
        RoundManager.OnRoundEnded -= HandleRoundEnd;
    }

    private void OnDestroy()
    {
        Debug.LogWarning($"[HUD 추적 ID: {instanceId}] {gameObject.name} - OnDestroy() 호출됨! (Frame: {Time.frameCount})");
    }

    // --- UI 업데이트 함수 (변경 없음) ---
    public void UpdateTimer(float time)
    {
        if (timerText == null) return;
        time = Mathf.Max(0, time);
        int minutes = (int)time / 60;
        int seconds = (int)time % 60;
        timerText.text = $"Time : {minutes:00}:{seconds:00}";
    }

    public void UpdateKillCount(int currentKills, int goalKills)
    {
        if (killCountText != null)
        {
            killCountText.text = $"Kills: {currentKills} / {goalKills}";
        }
    }

    private void HandleRoundEnd(bool success)
    {
        Debug.Log($"[HUD 추적] {gameObject.name} - '라운드 종료' 방송 수신. (Frame: {Time.frameCount})");
    }
}


==================== CardRewardUIManager.cs (경로: ./TTttTT/Assets/1.Scripts/UI/CardRewardUIManager.cs) ====================
// 파일 경로: Assets/1.Scripts/UI/CardRewardUIManager.cs
using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.EventSystems;

public class CardRewardUIManager : MonoBehaviour
{
    [Header("UI 요소 및 부모")]
    [SerializeField] private GameObject cardDisplayPrefab;
    [SerializeField] private Transform cardSlotsParent;
    [SerializeField] private CanvasGroup cardRewardCanvasGroup;
    [Header("버튼 참조")]
    [SerializeField] private Button acquireButton;
    [SerializeField] private Button synthesizeButton;
    [SerializeField] private Button skipButton;
    [SerializeField] private Button mapButton;

    [Header("팝업 참조")]
    [SerializeField] private SynthesisPopup synthesisPopup;
    private CardDisplay selectedDisplay;
    private List<CardDisplay> spawnedCardDisplays = new List<CardDisplay>();
    private GameObject lastSelectedCardObject;

    void Awake()
    {
        ServiceLocator.Register<CardRewardUIManager>(this);
        acquireButton.onClick.AddListener(OnAcquireClicked);
        synthesizeButton.onClick.AddListener(OnSynthesizeClicked);
        skipButton.onClick.AddListener(OnSkipClicked);
        if (mapButton != null) { mapButton.onClick.AddListener(OnMapButtonClicked); }

        Debug.Log("[CardRewardUIManager] Awake: 이벤트 리스너가 성공적으로 연결되었습니다.");
    }

    void OnEnable()
    {
        RewardManager.OnCardRewardReady += Initialize;
        RewardManager.OnRewardSkipped += HandleRewardSkipped;
    }

    void OnDisable()
    {
        RewardManager.OnCardRewardReady -= Initialize;
        RewardManager.OnRewardSkipped -= HandleRewardSkipped;
    }

    void Start()
    {
        var rewardManager = ServiceLocator.Get<RewardManager>();
        if (rewardManager != null)
        {
            Debug.Log("[CardRewardUIManager] Start: RewardManager에게 보상 처리를 요청합니다.");
            rewardManager.ProcessNextReward();
        }
        else
        {
            Debug.LogError("[CardRewardUIManager] Start에서 RewardManager를 찾을 수 없습니다!");
        }
    }

    private void HandleRewardSkipped()
    {
        Debug.Log("[CardRewardUIManager] 보상 스킵 신호(OnRewardSkipped)를 감지했습니다. 맵 선택으로 즉시 이동합니다.");
        TransitionToMap();
    }

    public void Initialize(List<CardDataSO> cardChoices)
    {
        Debug.Log($"[CardRewardUIManager] Initialize: {cardChoices.Count}개의 카드 보상으로 UI를 초기화합니다.");
        foreach (Transform child in cardSlotsParent) { Destroy(child.gameObject); }
        spawnedCardDisplays.Clear();

        foreach (var cardData in cardChoices)
        {
            GameObject cardUI = Instantiate(cardDisplayPrefab, cardSlotsParent);
            CardDisplay cardDisplay = cardUI.GetComponent<CardDisplay>();
            if (cardDisplay != null)
            {
                cardDisplay.Setup(cardData);
                cardDisplay.OnCardSelected.AddListener(HandleCardSelection);
                spawnedCardDisplays.Add(cardDisplay);
            }
        }

        selectedDisplay = null;
        UpdateButtonsState();
        StartCoroutine(SetFocusToCardCoroutine());
    }

    private void HandleCardSelection(CardDisplay display)
    {
        selectedDisplay = display;
        Debug.Log($"[CardRewardUIManager] 카드 선택됨: {display.CurrentCard.basicInfo.cardName}");

        foreach (var d in spawnedCardDisplays)
        {
            bool isSelected = (d == selectedDisplay);
            d.SetHighlight(isSelected);
            if (isSelected) { lastSelectedCardObject = d.gameObject; }
        }
        UpdateButtonsState();
    }

    private void OnAcquireClicked()
    {
        if (selectedDisplay == null)
        {
            Debug.LogWarning("[CardRewardUIManager] OnAcquireClicked: 선택된 카드가 없어 아무것도 하지 않습니다.");
            return;
        }

        CardDataSO selectedCardData = selectedDisplay.CurrentCard;
        Debug.Log($"[CardRewardUIManager] '획득' 버튼 클릭됨. 선택된 카드: {selectedCardData.basicInfo.cardName}");
        var cardManager = ServiceLocator.Get<CardManager>();
        if (cardManager != null)
        {
            cardManager.AcquireNewCard(selectedCardData);
            Debug.Log($"[CardRewardUIManager] CardManager를 통해 '{selectedCardData.basicInfo.cardName}' 카드를 성공적으로 획득했습니다.");
        }
        else
        {
            Debug.LogError("[CardRewardUIManager] CRITICAL: CardManager를 찾을 수 없어 카드를 획득할 수 없습니다!");
        }

        ServiceLocator.Get<RewardManager>()?.CompleteRewardSelection();
        ServiceLocator.Get<CardManager>().SendMessage("PrintEquippedCards", "TransitionToMap 직전");
        TransitionToMap();
    }

    private void OnSynthesizeClicked()
    {
        if (selectedDisplay == null || !synthesizeButton.interactable) return;
        Debug.Log($"[CardRewardUIManager] '합성' 버튼 클릭됨. 선택된 카드: {selectedDisplay.CurrentCard.basicInfo.cardName}");

        var cardManager = ServiceLocator.Get<CardManager>();
        CardDataSO selectedCardData = selectedDisplay.CurrentCard;
        List<CardDataSO> materialChoices = cardManager.GetSynthesizablePairs(selectedCardData);
        if (materialChoices.Count > 0 && synthesisPopup != null)
        {
            if (cardRewardCanvasGroup != null)
            {
                cardRewardCanvasGroup.interactable = false;
            }

            synthesisPopup.gameObject.SetActive(true);
            synthesisPopup.Initialize(selectedCardData.basicInfo.cardName, materialChoices,
            (chosenMaterial) => {
                Debug.Log($"[CardRewardUIManager] 합성 재료 '{chosenMaterial.basicInfo.cardName}' 선택됨. 합성을 실행합니다.");
                if (cardRewardCanvasGroup != null) cardRewardCanvasGroup.interactable = true;

                cardManager.SynthesizeCards(selectedCardData, chosenMaterial);
                ServiceLocator.Get<RewardManager>()?.CompleteRewardSelection();
                TransitionToMap();
            },
            () => {
                Debug.Log("[CardRewardUIManager] 합성 취소됨.");
                if (cardRewardCanvasGroup != null) cardRewardCanvasGroup.interactable = true;
                EventSystem.current.SetSelectedGameObject(synthesizeButton.gameObject);
            });
        }
    }

    private void OnSkipClicked()
    {
        Debug.Log("[CardRewardUIManager] '스킵' 버튼 클릭됨.");
        ServiceLocator.Get<RewardManager>()?.CompleteRewardSelection();
        TransitionToMap();
    }

    private void OnMapButtonClicked()
    {
        Debug.Log("[CardRewardUIManager] '맵으로' 버튼 클릭됨.");
        TransitionToMap();
    }

    private void UpdateButtonsState()
    {
        acquireButton.interactable = (selectedDisplay != null);
        bool canSynthesize = false;
        if (selectedDisplay != null)
        {
            var cardManager = ServiceLocator.Get<CardManager>();
            if (cardManager != null)
            {
                canSynthesize = cardManager.HasSynthesizablePair(selectedDisplay.CurrentCard);
            }
        }
        synthesizeButton.interactable = canSynthesize;
    }

    private void TransitionToMap()
    {
        Debug.Log("[CardRewardUIManager] 맵 선택 화면으로 전환을 시작합니다...");
        var routeSelectionController = ServiceLocator.Get<RouteSelectionController>();
        if (routeSelectionController != null)
        {
            routeSelectionController.Show();
        }
        else
        {
            Debug.LogError("[CardRewardUIManager] CRITICAL: RouteSelectionController를 찾을 수 없어 맵 화면으로 전환할 수 없습니다!");
        }
        Hide();
    }

    private IEnumerator SetFocusToCardCoroutine()
    {
        yield return null;

        if (lastSelectedCardObject != null && lastSelectedCardObject.activeInHierarchy)
        {
            EventSystem.current.SetSelectedGameObject(lastSelectedCardObject);
        }
        else if (spawnedCardDisplays.Count > 0)
        {
            lastSelectedCardObject = spawnedCardDisplays[0].gameObject;
            EventSystem.current.SetSelectedGameObject(lastSelectedCardObject);
        }
    }

    public void Show()
    {
        gameObject.SetActive(true);
        StartCoroutine(SetFocusToCardCoroutine());
    }
    public void Hide() { gameObject.SetActive(false); }
}

==================== UIPanel.cs (경로: ./TTttTT/Assets/1.Scripts/UI/UIPanel.cs) ====================
using UnityEngine;

/// <summary>
/// UIManager г ڵ ϴ  ũƮԴϴ.
///  ũƮ  UI г Ʈ GameObject ߰ϼ.
/// </summary>
public class UIPanel : MonoBehaviour
{
    // UIManager г ĺ ̸. Inspector մϴ.
    public string panelName;

    void Awake()
    {
        if (string.IsNullOrEmpty(panelName))
        {
            Debug.LogWarning($"UIPanel ũƮ  '{gameObject.name}' Ʈ 'panelName'  ʾҽϴ. GameObject ̸ մϴ.");
            panelName = gameObject.name;
        }

        // --- [] ServiceLocator  UIManager νϽ ɴϴ. ---
        var uiManager = ServiceLocator.Get<UIManager>();
        if (uiManager != null)
        {
            uiManager.RegisterPanel(panelName, gameObject);
        }
    }

    void OnDestroy()
    {
        // --- [] ServiceLocator  UIManager νϽ ɴϴ. ---
        var uiManager = ServiceLocator.Get<UIManager>();
        if (uiManager != null && !string.IsNullOrEmpty(panelName))
        {
            uiManager.UnregisterPanel(panelName);
        }
    }
}

==================== CodexItemDisplay.cs (경로: ./TTttTT/Assets/1.Scripts/UI/CodexItemDisplay.cs) ====================
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System;

/// <summary>
/// 도감의 개별 항목(카드 또는 유물) 하나의 UI 표시를 담당합니다.
/// </summary>
public class CodexItemDisplay : MonoBehaviour
{
    [Header("UI 요소 참조")]
    [SerializeField] private TextMeshProUGUI nameText;
    [SerializeField] private TextMeshProUGUI typeText; // 카드의 속성(물리/마법) 또는 "유물" 텍스트
    [SerializeField] private TextMeshProUGUI rarityText; // 등급/희귀도
    [SerializeField] private TextMeshProUGUI descriptionText;
    [SerializeField] private Image itemIcon;
    [SerializeField] private GameObject lockedOverlay; // 잠금 상태일 때 표시할 오버레이
    [SerializeField] private Button hintButton; // 힌트 구매 버튼 (잠금 상태일 때만 활성화)

    private string currentItemId; // 현재 표시 중인 아이템의 ID
    private bool isCurrentlyUnlocked; // 현재 아이템의 해금 상태
    private string unlockedDescription; // 해금된 경우의 실제 설명

    /// <summary>
    /// 힌트 버튼 클릭 시 호출될 콜백을 설정합니다.
    /// </summary>
    public void SetHintButtonClickListener(string itemId, Action<string> onClick)
    {
        currentItemId = itemId;
        if (hintButton != null)
        {
            hintButton.onClick.RemoveAllListeners();
            hintButton.onClick.AddListener(() => onClick?.Invoke(currentItemId));
        }
    }

    /// <summary>
    /// 카드 데이터로 UI를 설정합니다.
    /// </summary>
    public void SetupForCard(CardDataSO card, bool isUnlocked)
    {
        isCurrentlyUnlocked = isUnlocked;
        unlockedDescription = card.basicInfo.effectDescription; // 실제 설명 저장

        if (hintButton != null) hintButton.gameObject.SetActive(!isUnlocked);
        if (lockedOverlay != null) lockedOverlay.SetActive(!isUnlocked);

        if (isUnlocked)
        {
            nameText.text = card.basicInfo.cardName;
            typeText.text = card.basicInfo.type.ToString();
            rarityText.text = card.basicInfo.rarity.ToString();
            descriptionText.text = card.basicInfo.effectDescription;
            // if (itemIcon != null && card.icon != null) itemIcon.sprite = card.icon;
        }
        else
        {
            nameText.text = "????????";
            typeText.text = "";
            rarityText.text = "";
            descriptionText.text = "";
            // if (itemIcon != null) itemIcon.sprite = null;
        }
    }

    /// <summary>
    /// 유물 데이터로 UI를 설정합니다.
    /// </summary>
    public void SetupForArtifact(ArtifactDataSO artifact, bool isUnlocked)
    {
        isCurrentlyUnlocked = isUnlocked;
        unlockedDescription = artifact.description; // 실제 설명 저장

        if (hintButton != null) hintButton.gameObject.SetActive(!isUnlocked);
        if (lockedOverlay != null) lockedOverlay.SetActive(!isUnlocked);

        if (isUnlocked)
        {
            nameText.text = artifact.artifactName;
            typeText.text = "유물";
            rarityText.text = artifact.rarity.ToString();
            descriptionText.text = artifact.description; 
            // if (itemIcon != null && artifact.icon != null) itemIcon.sprite = artifact.icon;
        }
        else
        {
            nameText.text = "????????";
            typeText.text = "";
            rarityText.text = "";
            descriptionText.text = "";
            // if (itemIcon != null) itemIcon.sprite = null;
        }
    }

    /// <summary>
    /// 힌트를 표시합니다. (잠금 상태에서만 호출)
    /// </summary>
    public void ShowHint()
    {
        if (!isCurrentlyUnlocked) // 잠금 상태일 때만 힌트 표시
        {
            descriptionText.text = unlockedDescription; // 실제 설명 표시
            if (hintButton != null) hintButton.gameObject.SetActive(false); // 힌트 버튼 비활성화
        }
    }
}


==================== MapNodeUI.cs (경로: ./TTttTT/Assets/1.Scripts/UI/MapNodeUI.cs) ====================
using UnityEngine;
using UnityEngine.UI;

// 이 스크립트는 UI 버튼 오브젝트가 어떤 맵 노드 데이터(위치)를
// 가지고 있는지 관리하는 스크립트입니다.
public class MapNodeUI : MonoBehaviour
{
    public MapNode nodeData; // 이 노드 UI가 나타내는 맵 노드 데이터
    
    // [수정됨] Inspector에서 Button 컴포넌트를 연결할 수 있도록 [HideInInspector]를 제거합니다.
    [SerializeField] public Button button; 

    void Awake()
    {
        // [수정됨] 자식 오브젝트에서도 Button 컴포넌트를 찾을 수 있도록 GetComponentInChildren를 사용합니다.
        if (button == null) // Inspector에서 연결되지 않았다면 코드로 찾습니다.
        {
            button = GetComponentInChildren<Button>();
            if (button == null)
            {
                Debug.LogError($"[MapNodeUI] {gameObject.name}에서 Button 컴포넌트를 찾을 수 없습니다! Inspector에서 연결하거나 자식 오브젝트에 Button이 있는지 확인하세요.");
            }
        }
    }
}


==================== MapView.cs (경로: ./TTttTT/Assets/1.Scripts/UI/MapView.cs) ====================
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;
using System.Linq;

public class MapView : MonoBehaviour
{
    [Header("UI 프리팹")]
    [SerializeField] private GameObject nodePrefab;
    [SerializeField] private GameObject pathPrefab;

    [Header("UI 부모 오브젝트")]
    [SerializeField] private Transform pathParent;
    [SerializeField] private Transform nodeParent;

    [Header("맵 시각화 설정")]
    [SerializeField] private float nodeSpacingX = 200f;
    [SerializeField] private float nodeSpacingY = 120f;
    [SerializeField] private ScrollRect mapScrollRect;

    private Dictionary<MapNode, GameObject> nodeUiMap = new Dictionary<MapNode, GameObject>();

    public event System.Action<MapNode> OnNodeSelected;

    public void GenerateMapView(List<MapNode> mapData, int mapWidth, int intMapHeight)
    {
        Debug.Log("[MapView] GenerateMapView 시작."); // [추가됨] 디버그 로그
        foreach (Transform child in nodeParent) Destroy(child.gameObject); // [수정됨] intMapHeight로 변수명 변경
        foreach (Transform child in pathParent) Destroy(child.gameObject);
        nodeUiMap.Clear();

        float horizontalOffset = (mapWidth - 1) * nodeSpacingX * 0.5f;

        foreach (var nodeData in mapData)
        {
            GameObject nodeObj = Instantiate(nodePrefab, nodeParent);
            RectTransform nodeRect = nodeObj.GetComponent<RectTransform>();
            if (nodeRect != null)
            {
                float posX = nodeData.Position.x * nodeSpacingX - horizontalOffset;
                float posY = nodeData.Position.y * nodeSpacingY;
                nodeRect.anchoredPosition = new Vector2(posX, posY);
            }

            MapNodeUI mapNodeUI = nodeObj.GetComponent<MapNodeUI>();
            if (mapNodeUI != null)
            {
                // [추가됨] MapNodeUI의 button 참조 확인
                if (mapNodeUI.button == null)
                {
                    Debug.LogError($"[MapView] MapNodeUI ({nodeObj.name})에 Button 컴포넌트가 연결되지 않았습니다!");
                }
                else
                {
                    mapNodeUI.nodeData = nodeData;
                    MapNode currentNodeData = nodeData;
                    mapNodeUI.button.onClick.AddListener(() => OnNodeClicked(currentNodeData));
                }
            }
            else
            {
                Debug.LogError($"[MapView] 노드 프리팹 ({nodePrefab.name})에 MapNodeUI 컴포넌트가 없습니다!"); // [추가됨] 디버그 로그
            }

            nodeUiMap.Add(nodeData, nodeObj);
        }

        foreach (var nodeData in mapData)
        {
            if (nodeData.NextNodes.Count > 0)
            {
                GameObject fromObj = nodeUiMap[nodeData];
                foreach (var childNode in nodeData.NextNodes)
                {
                    if (nodeUiMap.ContainsKey(childNode))
                    {
                        DrawPath(fromObj, nodeUiMap[childNode]);
                    }
                }
            }
        }

        RectTransform contentRect = mapScrollRect.content;
        float totalMapHeight = (intMapHeight - 1) * nodeSpacingY; // [수정됨] intMapHeight로 변수명 변경
        contentRect.sizeDelta = new Vector2(contentRect.sizeDelta.x, totalMapHeight + 8000f);
        Debug.Log("[MapView] GenerateMapView 완료."); // [추가됨] 디버그 로그
    }

    private void OnNodeClicked(MapNode node)
    {
        OnNodeSelected?.Invoke(node);
        Debug.Log($"[MapView] OnNodeSelected 이벤트 발생 시도.");
    }

    private void DrawPath(GameObject from, GameObject to)
    {
        GameObject pathObj = Instantiate(pathPrefab, pathParent);
        RectTransform pathRect = pathObj.GetComponent<RectTransform>();
        Image pathImage = pathObj.GetComponent<Image>();

        Vector2 dir = (to.transform.position - from.transform.position).normalized;
        float distance = Vector2.Distance(to.transform.position, from.transform.position);

        pathRect.sizeDelta = new Vector2(distance, pathRect.sizeDelta.y);
        pathRect.position = from.transform.position;
        pathRect.pivot = new Vector2(0, 0.5f);
        pathRect.rotation = Quaternion.FromToRotation(Vector3.right, dir);
        if (pathImage != null) pathImage.type = Image.Type.Tiled;
    }

    /// <summary>
    /// [변경됨] 모든 노드의 네비게이션을 요구사항에 맞게 설정합니다.
    /// </summary>
    public void SetupAllNodeNavigations(Button backButton)
    {
        Debug.Log("[MapView] SetupAllNodeNavigations 시작."); // [추가됨] 디버그 로그
        foreach (var pair in nodeUiMap)
        {
            MapNode currentNodeData = pair.Key;
            GameObject currentNodeObj = pair.Value;
            Button currentBtn = currentNodeObj.GetComponent<Button>();

            if (currentBtn == null)
            {
                Debug.LogError($"[MapView] 노드 오브젝트 {currentNodeObj.name}에 Button 컴포넌트가 없습니다!"); // [추가됨] 디버그 로그
                continue;
            }

            Navigation nav = new Navigation
            {
                mode = Navigation.Mode.Explicit
            };

            var upCandidates = nodeUiMap.Where(p => p.Key.Position.y == currentNodeData.Position.y + 1);
            if (upCandidates.Any()) 
            {
                var targetUp = upCandidates.OrderBy(p => Mathf.Abs(p.Value.transform.position.x - currentNodeObj.transform.position.x)).First();
                nav.selectOnUp = targetUp.Value.GetComponent<Button>();
            }

            var downCandidates = nodeUiMap.Where(p => p.Key.Position.y == currentNodeData.Position.y - 1);
            if (downCandidates.Any())
            {
                var targetDown = downCandidates.OrderBy(p => Mathf.Abs(p.Value.transform.position.x - currentNodeObj.transform.position.x)).First();
                nav.selectOnDown = targetDown.Value.GetComponent<Button>();
            }

            var leftCandidates = nodeUiMap.Where(p => p.Key.Position.y == currentNodeData.Position.y && p.Key.Position.x < currentNodeData.Position.x);
            if (leftCandidates.Any())
            {
                var targetLeft = leftCandidates.OrderByDescending(p => p.Key.Position.x).First();
                nav.selectOnLeft = targetLeft.Value.GetComponent<Button>();
            }
            else
            {
                if (backButton != null && backButton.interactable)
                {
                    nav.selectOnLeft = backButton;
                }
            }

            var rightCandidates = nodeUiMap.Where(p => p.Key.Position.y == currentNodeData.Position.y && p.Key.Position.x > currentNodeData.Position.x);
            if (rightCandidates.Any())
            {
                var targetRight = rightCandidates.OrderBy(p => p.Key.Position.x).First();
                nav.selectOnRight = targetRight.Value.GetComponent<Button>();
            }

            currentBtn.navigation = nav;
        }
        Debug.Log("[MapView] SetupAllNodeNavigations 완료."); // [추가됨] 디버그 로그
    }

    public void UpdateNodeInteractability(List<MapNode> reachableNodes)
    {
        Debug.Log($"[MapView] UpdateNodeInteractability 시작. 도달 가능한 노드 수: {reachableNodes.Count}"); // [추가됨] 디버그 로그
        foreach (var entry in nodeUiMap)
        {
            Button button = entry.Value.GetComponentInChildren<Button>();
            if (button != null)
            {
                bool isInteractable = reachableNodes.Contains(entry.Key);
                button.interactable = isInteractable;
            }
            else
            {
                Debug.LogWarning($"[MapView] 노드 {entry.Key.Position}의 자식에서 Button 컴포넌트를 찾을 수 없습니다."); // [추가됨] 디버그 로그
            }
        }
        Debug.Log("[MapView] UpdateNodeInteractability 완료."); // [추가됨] 디버그 로그
    }

    public GameObject FindClosestNodeTo(Vector3 position)
    {
        if (nodeUiMap.Count == 0) return null;
        return nodeUiMap.OrderBy(p => Vector3.Distance(p.Value.transform.position, position)).First().Value;
    }

    public GameObject FindLeftmostAvailableNode(List<MapNode> reachableNodes)
    {
        if (reachableNodes == null || reachableNodes.Count == 0) return null;

        MapNode leftmostNode = reachableNodes
            .OrderBy(n => n.Position.y)
            .ThenBy(n => n.Position.x)
            .FirstOrDefault();

        if (leftmostNode != null && nodeUiMap.ContainsKey(leftmostNode))
        {
            return nodeUiMap[leftmostNode];
        }
        return null;
    }
}

==================== PlayerHealthBar.cs (경로: ./TTttTT/Assets/1.Scripts/UI/PlayerHealthBar.cs) ====================
using UnityEngine;
using UnityEngine.UI;

public class PlayerHealthBar : MonoBehaviour
{
    [SerializeField]
    private Slider healthBarSlider;

    void LateUpdate()
    {
        transform.rotation = Quaternion.identity;
    }

    public void UpdateHealth(float currentHealth, float maxHealth)
    {
        if (healthBarSlider != null && maxHealth > 0)
        {
            healthBarSlider.value = currentHealth / maxHealth;
        }
    }
}

==================== MainMenuUI.cs (경로: ./TTttTT/Assets/1.Scripts/UI/MainMenuUI.cs) ====================
﻿using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class MainMenuUI : MonoBehaviour
{
    [Header("UI 요소 참조")]
    public Button optionsButton;
    public Button startButton;
    public Button codexButton;
    public Button exitButton;
    public TextMeshProUGUI versionInfoText;

    void Start()
    {
        startButton.onClick.AddListener(OnStartButtonClicked);
        optionsButton.onClick.AddListener(OnOptionsButtonClicked);
        codexButton.onClick.AddListener(OnCodexButtonClicked);
        exitButton.onClick.AddListener(OnExitButtonClicked);

        if (versionInfoText != null)
        {
            versionInfoText.text = "Version: " + Application.version;
        }
    }

    public void OnOptionsButtonClicked() { Debug.Log("옵션 버튼 클릭!"); }
    public void OnStartButtonClicked() { ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.CharacterSelect); }
    public void OnCodexButtonClicked() { ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.Codex); }
    public void OnExitButtonClicked() { Application.Quit(); }
}

==================== AutoFocusScroller.cs (경로: ./TTttTT/Assets/1.Scripts/UI/AutoFocusScroller.cs) ====================
// : Assets/1/Scripts/UI/AutoFocusScroller.cs

using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;

public class AutoFocusScroller : MonoBehaviour
{
    [Header(" ")]
    [SerializeField] private ScrollRect mapScrollRect;
    [SerializeField] private MapView mapView;

    [Header("ũ ")]
    [SerializeField] private float edgeScrollSpeed = 1.0f;
    [SerializeField] private float scrollBoundaryOffset = 50f;

    private Vector3[] viewportCorners = new Vector3[4];

    void Update()
    {
        if (!gameObject.activeInHierarchy) return;

        GameObject rawSelectedObject = EventSystem.current.currentSelectedGameObject;
        if (rawSelectedObject == null) return;


        GameObject closestNode = mapView.FindClosestNodeTo(rawSelectedObject.transform.position);
        if (closestNode == null) return;


        mapScrollRect.viewport.GetWorldCorners(viewportCorners);
        float viewportTopY = viewportCorners[1].y;
        float viewportBottomY = viewportCorners[0].y;

        float nodeY = closestNode.transform.position.y;

        float topBoundary = viewportTopY - scrollBoundaryOffset;
        float bottomBoundary = viewportBottomY + scrollBoundaryOffset;
        
        bool shouldScrollUp = nodeY > topBoundary;
        bool shouldScrollDown = nodeY < bottomBoundary;

        if (shouldScrollUp)
        {
            // --- [ DELTA:  ߵ] ---
            Scroll(1);
        }
        else if (shouldScrollDown)
        {
            // --- [ DELTA:  ߵ] ---
            Scroll(-1);
        }
    }

    private void Scroll(int direction)
    {
        float currentScrollPos = mapScrollRect.verticalNormalizedPosition;
        float newScrollPos = currentScrollPos + (direction * edgeScrollSpeed * Time.unscaledDeltaTime);
        newScrollPos = Mathf.Clamp01(newScrollPos);

        mapScrollRect.verticalNormalizedPosition = newScrollPos;
    }
}

==================== DamageText.cs (경로: ./TTttTT/Assets/1.Scripts/UI/DamageText.cs) ====================
using UnityEngine;
using System.Collections;
using TMPro;

public class DamageText : MonoBehaviour
{
    [Header("ִϸ̼ ")]
    [Tooltip("ؽƮ Ƣ  ִϸ̼ ü ũ⸦ մϴ. (1 = 100%)")]
    public float animationScale = 1.0f;
    [Tooltip("ִϸ̼ Ǵ ðԴϴ.")]
    public float animationDuration = 0.8f;
    [Tooltip("ؽƮ  ö󰡴 ŸԴϴ.")]
    public float moveUpDistance = 1.5f;

    private TextMeshProUGUI textMesh;
    private PoolManager poolManager;

    private void Awake()
    {
        textMesh = GetComponentInChildren<TextMeshProUGUI>();
        if (textMesh == null)
        {
            Debug.LogError("DamageText: ڽ Ʈ TextMeshProUGUI Ʈ ã  ϴ!");
        }
    }

    void Start()
    {
        // --- [] ServiceLocator  PoolManager ãƿɴϴ. ---
        poolManager = ServiceLocator.Get<PoolManager>();
    }

    public void ShowDamage(float damageAmount)
    {
        if (textMesh == null) return;

        textMesh.text = Mathf.RoundToInt(damageAmount).ToString();
        StartCoroutine(Animate());
    }

    private IEnumerator Animate()
    {
        transform.SetParent(null, true);
        transform.localScale = Vector3.zero;

        Color startColor = textMesh.color;
        startColor.a = 1f;
        textMesh.color = startColor;

        Color endColor = startColor;
        endColor.a = 0f;

        float timer = 0f;
        Vector3 startPosition = transform.position;
        Vector3 targetPosition = startPosition + (Vector3.up * moveUpDistance);

        float popupDuration = 0.1f;
        Vector3 targetScale = Vector3.one * animationScale;

        while (timer < popupDuration)
        {
            transform.localScale = Vector3.Lerp(Vector3.zero, targetScale, timer / popupDuration);
            timer += Time.deltaTime;
            yield return null;
        }
        transform.localScale = targetScale;

        timer = 0f;
        while (timer < animationDuration)
        {
            transform.position = Vector3.Lerp(startPosition, targetPosition, timer / animationDuration);
            textMesh.color = Color.Lerp(startColor, endColor, timer / animationDuration);
            timer += Time.deltaTime;
            yield return null;
        }

        if (poolManager != null)
        {
            poolManager.Release(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }
}

==================== PointAllocationResultUI.cs (경로: ./TTttTT/Assets/1.Scripts/UI/PointAllocationResultUI.cs) ====================
// --- 파일명: PointAllocationResultUI.cs (최종 수정본) ---

using UnityEngine;
using TMPro;
using System.Collections.Generic;

public class PointAllocationResultUI : MonoBehaviour
{
    // ... (UI 참조 변수들은 이전과 동일) ...
    [SerializeField] private TextMeshProUGUI damageText;
    [SerializeField] private TextMeshProUGUI attackSpeedText;
    [SerializeField] private TextMeshProUGUI moveSpeedText;
    [SerializeField] private TextMeshProUGUI healthText;
    [SerializeField] private TextMeshProUGUI critRateText;
    [SerializeField] private TextMeshProUGUI critDamageText;

    // ✨ [1번 문제 해결] 파라미터를 분배된 포인트 딕셔너리로 변경
    public void UpdateDisplay(BaseStats baseStats, Dictionary<StatType, int> distributedPoints)
    {
        if (distributedPoints == null) // Confirm 전
        {
            damageText.text = $"Base Damage ({baseStats.baseDamage:F0}) + Gene Boost (??) = ???";
            attackSpeedText.text = $"Base Attack Speed ({baseStats.baseAttackSpeed:F1}) + Gene Boost (??) = ???";
            moveSpeedText.text = $"Base Move Speed ({baseStats.baseMoveSpeed:F1}) + Gene Boost (??) = ???";
            healthText.text = $"Base Health ({baseStats.baseHealth:F0}) + Gene Boost (??) = ???";
            critRateText.text = $"Base Crit Rate ({baseStats.baseCritRate:F0}%) + Gene Boost (??) = ???";
            critDamageText.text = $"Base Crit Damage ({baseStats.baseCritDamage:F0}%) + Gene Boost (??) = ???";
        }
        else // Confirm 후
        {
            // 각 스탯에 실제 분배된 포인트 개수를 가져옴
            int attackPoints = distributedPoints[StatType.Attack];
            int attackSpeedPoints = distributedPoints[StatType.AttackSpeed];
            int moveSpeedPoints = distributedPoints[StatType.MoveSpeed];
            int healthPoints = distributedPoints[StatType.Health];
            float baseCritRatePercent = baseStats.baseCritRate / 100f;
            float baseCritDmgPercent = baseStats.baseCritDamage / 100f;
            int critDmgPoints = distributedPoints[StatType.CritMultiplier];

            int critRatePoints = distributedPoints[StatType.CritRate];
            float finalCritRate = baseStats.baseCritRate * (1 + critRatePoints * 0.01f);


            // 최종 능력치 계산
            float finalDamage = baseStats.baseDamage * (1 + attackPoints * 0.01f);
            float finalAttackSpeed = baseStats.baseAttackSpeed * (1 + attackSpeedPoints * 0.01f);
            float finalMoveSpeed = baseStats.baseMoveSpeed * (1 + moveSpeedPoints * 0.01f);
            float finalHealth = baseStats.baseHealth * (1 + healthPoints * 0.02f);
            float finalCritDamage = baseCritDmgPercent * (1 + critDmgPoints * 0.01f);

            // ✨ 실제 분배된 포인트 개수를 UI에 표시
            damageText.text = $"Base Damage ({baseStats.baseDamage:F0}) + Gene Boost ({attackPoints}) = {finalDamage:F2}";
            attackSpeedText.text = $"Base Attack Speed ({baseStats.baseAttackSpeed:F1}) + Gene Boost ({attackSpeedPoints}) = {finalAttackSpeed:F2}";
            moveSpeedText.text = $"Base Move Speed ({baseStats.baseMoveSpeed:F1}) + Gene Boost ({moveSpeedPoints}) = {finalMoveSpeed:F2}";
            healthText.text = $"Base Health ({baseStats.baseHealth:F0}) + Gene Boost ({healthPoints}) = {finalHealth:F2}";
            critRateText.text = $"Base Crit Rate ({baseStats.baseCritRate:F0}%) + Gene Boost ({critRatePoints}) = {finalCritRate:F2}%"; // 포맷을 F2로 변경
            critDamageText.text = $"Base Crit Damage ({baseStats.baseCritDamage:F0}%) + Gene Boost ({critDmgPoints}) = {finalCritDamage * 100:F0}%";
        }
    }
}

==================== CharacterSelectController.cs (경로: ./TTttTT/Assets/1.Scripts/UI/CharacterSelectController.cs) ====================
using UnityEngine;

/// <summary>
/// 캐릭터 선택 씬의 전체적인 흐름과 상태를 관리하는 컨트롤러입니다.
/// 각 UI 패널(캐릭터 선택, 포인트 분배, 결과)을 제어하고,
/// 선택된 캐릭터 데이터와 분배된 포인트를 다음 씬으로 전달할 준비를 합니다.
/// </summary>
public class CharacterSelectController : MonoBehaviour
{
    public CharacterDataSO SelectedCharacter { get; private set; }
    public int AllocatedPoints { get; private set; }

    void Start()
    {
        // 씬이 시작되면, CharacterSelectUI 스크립트가 붙어있는 패널이 활성화됩니다.
    }

    public void OnCharacterSelected(CharacterDataSO characterData)
    {
        SelectedCharacter = characterData;
        Debug.Log($"[CharSelectController] 캐릭터 선택됨: {SelectedCharacter.characterName}");
    }

    public void ProceedToPointAllocation()
    {
        if (SelectedCharacter == null)
        {
            Debug.LogWarning("[CharSelectController] 캐릭터가 선택되지 않았습니다. 포인트 분배를 진행할 수 없습니다.");
            return;
        }

        ServiceLocator.Get<GameManager>().SelectedCharacter = this.SelectedCharacter;
        // GameManager의 PointAllocation 상태로 전환하도록 수정
        ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.PointAllocation);
    }
}

==================== UIManager.cs (경로: ./TTttTT/Assets/1.Scripts/UI/UIManager.cs) ====================
// 파일명: UIManager.cs (리팩토링 완료)
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

/// <summary>
/// 게임 내 UI 패널들을 관리하는 클래스입니다.
/// </summary>
public class UIManager : MonoBehaviour
{
    private Dictionary<string, GameObject> uiPanels = new Dictionary<string, GameObject>();

    void Awake()
    {
        if (!ServiceLocator.IsRegistered<UIManager>())
        {
            ServiceLocator.Register<UIManager>(this);
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void ShowPanel(string panelName, bool isActive)
    {
        if (uiPanels.TryGetValue(panelName, out GameObject panel))
        {
            panel.SetActive(isActive);
            Debug.Log($"UI Panel '{panelName}' set to active: {isActive}");
        }
        else
        {
            Debug.LogWarning($"UI Panel '{panelName}' not found in UIManager.");
        }
    }

    public void ShowPanel(string panelName)
    {
        ShowPanel(panelName, true);
    }

    public void HideAllPanels()
    {
        foreach (var panel in uiPanels.Values)
        {
            panel.SetActive(false);
        }
        Debug.Log("All UI panels hidden.");
    }

    public void RegisterPanel(string panelName, GameObject panelGameObject)
    {
        if (!uiPanels.ContainsKey(panelName))
        {
            uiPanels.Add(panelName, panelGameObject);
            Debug.Log($"UI Panel '{panelName}' registered with UIManager.");
        }
        else
        {
            Debug.LogWarning($"UI Panel '{panelName}' is already registered.");
        }
    }

    public void UnregisterPanel(string panelName)
    {
        if (uiPanels.Remove(panelName))
        {
            Debug.Log($"UI Panel '{panelName}' unregistered from UIManager.");
        }
        else
        {
            Debug.LogWarning($"UI Panel '{panelName}' not found for unregistration.");
        }
    }
}

==================== GameInitiolizer.cs (경로: ./TTttTT/Assets/1.Scripts/UI/GameInitiolizer.cs) ====================
// ϸ: GameInitializer.cs
using System.Collections;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.SceneManagement;

public class GameInitializer : MonoBehaviour
{
    void Start()
    {
        StartCoroutine(LoadEssentialDataAndProceed());
    }

    private IEnumerator LoadEssentialDataAndProceed()
    {
        // 0. (û) ⿡ ε ȭ UI ǥϴ ڵ带   ֽϴ.
        Debug.Log("[GameInitializer] ʼ  ε մϴ...");

        // 1. Addressables ý ʱȭ (   )
        yield return Addressables.InitializeAsync();

        // 2. ٽ Ŵ յ 񵿱 νϽȭմϴ.
        yield return Addressables.InstantiateAsync(PrefabKeys.Managers);
        yield return Addressables.InstantiateAsync(PrefabKeys.GameplaySession);

        Debug.Log("[GameInitializer] ٽ Ŵ  Ϸ.");

        // 3. DataManager   ε   ٸϴ.
        var dataManager = ServiceLocator.Get<DataManager>();
        if (dataManager != null)
        {
            yield return dataManager.LoadAllDataAsync();
        }

        // 4.  ε  MainMenu  ̵մϴ.
        Debug.Log("[GameInitializer]   ε Ϸ.  ޴ ̵մϴ.");
        SceneManager.LoadScene(SceneNames.MainMenu);
    }
}

==================== UIFeedbackManager.cs (경로: ./TTttTT/Assets/1.Scripts/UI/UIFeedbackManager.cs) ====================
using UnityEngine;

public class UIFeedbackManager : MonoBehaviour
{
    void OnEnable()
    {
        MonsterController.OnMonsterDamaged += HandleMonsterDamaged;
    }

    void OnDisable()
    {
        MonsterController.OnMonsterDamaged -= HandleMonsterDamaged;
    }

    private void HandleMonsterDamaged(float damageAmount, Vector3 position)
    {

        // DataManager ��� PrefabProvider�� PoolManager�� ���� ����ϴ� ���� �� ȿ�����Դϴ�.
        if (ServiceLocator.Get<PoolManager>() == null || ServiceLocator.Get<PrefabProvider>() == null) return;

        GameObject damageTextPrefab = ServiceLocator.Get<PrefabProvider>().GetPrefab("DamageTextCanvas");
        if (damageTextPrefab == null) return;

        GameObject textGO = ServiceLocator.Get<PoolManager>().Get(damageTextPrefab);
        if (textGO == null) return;

        textGO.transform.position = position + Vector3.up * 0.5f;

        DamageText damageTextComponent = textGO.GetComponent<DamageText>();
        if (damageTextComponent != null)
        {
            damageTextComponent.ShowDamage(damageAmount);
        }
    }
}

==================== TMP_TextEventHandler.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_TextEventHandler.cs) ====================
﻿using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using System;


namespace TMPro
{

    public class TMP_TextEventHandler : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler
    {
        [Serializable]
        public class CharacterSelectionEvent : UnityEvent<char, int> { }

        [Serializable]
        public class SpriteSelectionEvent : UnityEvent<char, int> { }

        [Serializable]
        public class WordSelectionEvent : UnityEvent<string, int, int> { }

        [Serializable]
        public class LineSelectionEvent : UnityEvent<string, int, int> { }

        [Serializable]
        public class LinkSelectionEvent : UnityEvent<string, string, int> { }


        /// <summary>
        /// Event delegate triggered when pointer is over a character.
        /// </summary>
        public CharacterSelectionEvent onCharacterSelection
        {
            get { return m_OnCharacterSelection; }
            set { m_OnCharacterSelection = value; }
        }
        [SerializeField]
        private CharacterSelectionEvent m_OnCharacterSelection = new CharacterSelectionEvent();


        /// <summary>
        /// Event delegate triggered when pointer is over a sprite.
        /// </summary>
        public SpriteSelectionEvent onSpriteSelection
        {
            get { return m_OnSpriteSelection; }
            set { m_OnSpriteSelection = value; }
        }
        [SerializeField]
        private SpriteSelectionEvent m_OnSpriteSelection = new SpriteSelectionEvent();


        /// <summary>
        /// Event delegate triggered when pointer is over a word.
        /// </summary>
        public WordSelectionEvent onWordSelection
        {
            get { return m_OnWordSelection; }
            set { m_OnWordSelection = value; }
        }
        [SerializeField]
        private WordSelectionEvent m_OnWordSelection = new WordSelectionEvent();


        /// <summary>
        /// Event delegate triggered when pointer is over a line.
        /// </summary>
        public LineSelectionEvent onLineSelection
        {
            get { return m_OnLineSelection; }
            set { m_OnLineSelection = value; }
        }
        [SerializeField]
        private LineSelectionEvent m_OnLineSelection = new LineSelectionEvent();


        /// <summary>
        /// Event delegate triggered when pointer is over a link.
        /// </summary>
        public LinkSelectionEvent onLinkSelection
        {
            get { return m_OnLinkSelection; }
            set { m_OnLinkSelection = value; }
        }
        [SerializeField]
        private LinkSelectionEvent m_OnLinkSelection = new LinkSelectionEvent();



        private TMP_Text m_TextComponent;

        private Camera m_Camera;
        private Canvas m_Canvas;

        private int m_selectedLink = -1;
        private int m_lastCharIndex = -1;
        private int m_lastWordIndex = -1;
        private int m_lastLineIndex = -1;

        void Awake()
        {
            // Get a reference to the text component.
            m_TextComponent = gameObject.GetComponent<TMP_Text>();

            // Get a reference to the camera rendering the text taking into consideration the text component type.
            if (m_TextComponent.GetType() == typeof(TextMeshProUGUI))
            {
                m_Canvas = gameObject.GetComponentInParent<Canvas>();
                if (m_Canvas != null)
                {
                    if (m_Canvas.renderMode == RenderMode.ScreenSpaceOverlay)
                        m_Camera = null;
                    else
                        m_Camera = m_Canvas.worldCamera;
                }
            }
            else
            {
                m_Camera = Camera.main;
            }
        }


        void LateUpdate()
        {
            if (TMP_TextUtilities.IsIntersectingRectTransform(m_TextComponent.rectTransform, Input.mousePosition, m_Camera))
            {
                #region Example of Character or Sprite Selection
                int charIndex = TMP_TextUtilities.FindIntersectingCharacter(m_TextComponent, Input.mousePosition, m_Camera, true);
                if (charIndex != -1 && charIndex != m_lastCharIndex)
                {
                    m_lastCharIndex = charIndex;

                    TMP_TextElementType elementType = m_TextComponent.textInfo.characterInfo[charIndex].elementType;

                    // Send event to any event listeners depending on whether it is a character or sprite.
                    if (elementType == TMP_TextElementType.Character)
                        SendOnCharacterSelection(m_TextComponent.textInfo.characterInfo[charIndex].character, charIndex);
                    else if (elementType == TMP_TextElementType.Sprite)
                        SendOnSpriteSelection(m_TextComponent.textInfo.characterInfo[charIndex].character, charIndex);
                }
                #endregion


                #region Example of Word Selection
                // Check if Mouse intersects any words and if so assign a random color to that word.
                int wordIndex = TMP_TextUtilities.FindIntersectingWord(m_TextComponent, Input.mousePosition, m_Camera);
                if (wordIndex != -1 && wordIndex != m_lastWordIndex)
                {
                    m_lastWordIndex = wordIndex;

                    // Get the information about the selected word.
                    TMP_WordInfo wInfo = m_TextComponent.textInfo.wordInfo[wordIndex];

                    // Send the event to any listeners.
                    SendOnWordSelection(wInfo.GetWord(), wInfo.firstCharacterIndex, wInfo.characterCount);
                }
                #endregion


                #region Example of Line Selection
                // Check if Mouse intersects any words and if so assign a random color to that word.
                int lineIndex = TMP_TextUtilities.FindIntersectingLine(m_TextComponent, Input.mousePosition, m_Camera);
                if (lineIndex != -1 && lineIndex != m_lastLineIndex)
                {
                    m_lastLineIndex = lineIndex;

                    // Get the information about the selected word.
                    TMP_LineInfo lineInfo = m_TextComponent.textInfo.lineInfo[lineIndex];

                    // Send the event to any listeners.
                    char[] buffer = new char[lineInfo.characterCount];
                    for (int i = 0; i < lineInfo.characterCount && i < m_TextComponent.textInfo.characterInfo.Length; i++)
                    {
                        buffer[i] = m_TextComponent.textInfo.characterInfo[i + lineInfo.firstCharacterIndex].character;
                    }

                    string lineText = new string(buffer);
                    SendOnLineSelection(lineText, lineInfo.firstCharacterIndex, lineInfo.characterCount);
                }
                #endregion


                #region Example of Link Handling
                // Check if mouse intersects with any links.
                int linkIndex = TMP_TextUtilities.FindIntersectingLink(m_TextComponent, Input.mousePosition, m_Camera);

                // Handle new Link selection.
                if (linkIndex != -1 && linkIndex != m_selectedLink)
                {
                    m_selectedLink = linkIndex;

                    // Get information about the link.
                    TMP_LinkInfo linkInfo = m_TextComponent.textInfo.linkInfo[linkIndex];

                    // Send the event to any listeners.
                    SendOnLinkSelection(linkInfo.GetLinkID(), linkInfo.GetLinkText(), linkIndex);
                }
                #endregion
            }
            else
            {
                // Reset all selections given we are hovering outside the text container bounds.
                m_selectedLink = -1;
                m_lastCharIndex = -1;
                m_lastWordIndex = -1;
                m_lastLineIndex = -1;
            }
        }


        public void OnPointerEnter(PointerEventData eventData)
        {
            //Debug.Log("OnPointerEnter()");
        }


        public void OnPointerExit(PointerEventData eventData)
        {
            //Debug.Log("OnPointerExit()");
        }


        private void SendOnCharacterSelection(char character, int characterIndex)
        {
            if (onCharacterSelection != null)
                onCharacterSelection.Invoke(character, characterIndex);
        }

        private void SendOnSpriteSelection(char character, int characterIndex)
        {
            if (onSpriteSelection != null)
                onSpriteSelection.Invoke(character, characterIndex);
        }

        private void SendOnWordSelection(string word, int charIndex, int length)
        {
            if (onWordSelection != null)
                onWordSelection.Invoke(word, charIndex, length);
        }

        private void SendOnLineSelection(string line, int charIndex, int length)
        {
            if (onLineSelection != null)
                onLineSelection.Invoke(line, charIndex, length);
        }

        private void SendOnLinkSelection(string linkID, string linkText, int linkIndex)
        {
            if (onLinkSelection != null)
                onLinkSelection.Invoke(linkID, linkText, linkIndex);
        }

    }
}


==================== CameraController.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/CameraController.cs) ====================
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class CameraController : MonoBehaviour
    {
        public enum CameraModes { Follow, Isometric, Free }

        private Transform cameraTransform;
        private Transform dummyTarget;

        public Transform CameraTarget;

        public float FollowDistance = 30.0f;
        public float MaxFollowDistance = 100.0f;
        public float MinFollowDistance = 2.0f;

        public float ElevationAngle = 30.0f;
        public float MaxElevationAngle = 85.0f;
        public float MinElevationAngle = 0f;

        public float OrbitalAngle = 0f;

        public CameraModes CameraMode = CameraModes.Follow;

        public bool MovementSmoothing = true;
        public bool RotationSmoothing = false;
        private bool previousSmoothing;

        public float MovementSmoothingValue = 25f;
        public float RotationSmoothingValue = 5.0f;

        public float MoveSensitivity = 2.0f;

        private Vector3 currentVelocity = Vector3.zero;
        private Vector3 desiredPosition;
        private float mouseX;
        private float mouseY;
        private Vector3 moveVector;
        private float mouseWheel;

        // Controls for Touches on Mobile devices
        //private float prev_ZoomDelta;


        private const string event_SmoothingValue = "Slider - Smoothing Value";
        private const string event_FollowDistance = "Slider - Camera Zoom";


        void Awake()
        {
            if (QualitySettings.vSyncCount > 0)
                Application.targetFrameRate = 60;
            else
                Application.targetFrameRate = -1;

            if (Application.platform == RuntimePlatform.IPhonePlayer || Application.platform == RuntimePlatform.Android)
                Input.simulateMouseWithTouches = false;

            cameraTransform = transform;
            previousSmoothing = MovementSmoothing;
        }


        // Use this for initialization
        void Start()
        {
            if (CameraTarget == null)
            {
                // If we don't have a target (assigned by the player, create a dummy in the center of the scene).
                dummyTarget = new GameObject("Camera Target").transform;
                CameraTarget = dummyTarget;
            }
        }

        // Update is called once per frame
        void LateUpdate()
        {
            GetPlayerInput();


            // Check if we still have a valid target
            if (CameraTarget != null)
            {
                if (CameraMode == CameraModes.Isometric)
                {
                    desiredPosition = CameraTarget.position + Quaternion.Euler(ElevationAngle, OrbitalAngle, 0f) * new Vector3(0, 0, -FollowDistance);
                }
                else if (CameraMode == CameraModes.Follow)
                {
                    desiredPosition = CameraTarget.position + CameraTarget.TransformDirection(Quaternion.Euler(ElevationAngle, OrbitalAngle, 0f) * (new Vector3(0, 0, -FollowDistance)));
                }
                else
                {
                    // Free Camera implementation
                }

                if (MovementSmoothing == true)
                {
                    // Using Smoothing
                    cameraTransform.position = Vector3.SmoothDamp(cameraTransform.position, desiredPosition, ref currentVelocity, MovementSmoothingValue * Time.fixedDeltaTime);
                    //cameraTransform.position = Vector3.Lerp(cameraTransform.position, desiredPosition, Time.deltaTime * 5.0f);
                }
                else
                {
                    // Not using Smoothing
                    cameraTransform.position = desiredPosition;
                }

                if (RotationSmoothing == true)
                    cameraTransform.rotation = Quaternion.Lerp(cameraTransform.rotation, Quaternion.LookRotation(CameraTarget.position - cameraTransform.position), RotationSmoothingValue * Time.deltaTime);
                else
                {
                    cameraTransform.LookAt(CameraTarget);
                }

            }

        }



        void GetPlayerInput()
        {
            moveVector = Vector3.zero;

            // Check Mouse Wheel Input prior to Shift Key so we can apply multiplier on Shift for Scrolling
            mouseWheel = Input.GetAxis("Mouse ScrollWheel");

            float touchCount = Input.touchCount;

            if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift) || touchCount > 0)
            {
                mouseWheel *= 10;

                if (Input.GetKeyDown(KeyCode.I))
                    CameraMode = CameraModes.Isometric;

                if (Input.GetKeyDown(KeyCode.F))
                    CameraMode = CameraModes.Follow;

                if (Input.GetKeyDown(KeyCode.S))
                    MovementSmoothing = !MovementSmoothing;


                // Check for right mouse button to change camera follow and elevation angle
                if (Input.GetMouseButton(1))
                {
                    mouseY = Input.GetAxis("Mouse Y");
                    mouseX = Input.GetAxis("Mouse X");

                    if (mouseY > 0.01f || mouseY < -0.01f)
                    {
                        ElevationAngle -= mouseY * MoveSensitivity;
                        // Limit Elevation angle between min & max values.
                        ElevationAngle = Mathf.Clamp(ElevationAngle, MinElevationAngle, MaxElevationAngle);
                    }

                    if (mouseX > 0.01f || mouseX < -0.01f)
                    {
                        OrbitalAngle += mouseX * MoveSensitivity;
                        if (OrbitalAngle > 360)
                            OrbitalAngle -= 360;
                        if (OrbitalAngle < 0)
                            OrbitalAngle += 360;
                    }
                }

                // Get Input from Mobile Device
                if (touchCount == 1 && Input.GetTouch(0).phase == TouchPhase.Moved)
                {
                    Vector2 deltaPosition = Input.GetTouch(0).deltaPosition;

                    // Handle elevation changes
                    if (deltaPosition.y > 0.01f || deltaPosition.y < -0.01f)
                    {
                        ElevationAngle -= deltaPosition.y * 0.1f;
                        // Limit Elevation angle between min & max values.
                        ElevationAngle = Mathf.Clamp(ElevationAngle, MinElevationAngle, MaxElevationAngle);
                    }


                    // Handle left & right 
                    if (deltaPosition.x > 0.01f || deltaPosition.x < -0.01f)
                    {
                        OrbitalAngle += deltaPosition.x * 0.1f;
                        if (OrbitalAngle > 360)
                            OrbitalAngle -= 360;
                        if (OrbitalAngle < 0)
                            OrbitalAngle += 360;
                    }

                }

                // Check for left mouse button to select a new CameraTarget or to reset Follow position
                if (Input.GetMouseButton(0))
                {
                    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
                    RaycastHit hit;

                    if (Physics.Raycast(ray, out hit, 300, 1 << 10 | 1 << 11 | 1 << 12 | 1 << 14))
                    {
                        if (hit.transform == CameraTarget)
                        {
                            // Reset Follow Position
                            OrbitalAngle = 0;
                        }
                        else
                        {
                            CameraTarget = hit.transform;
                            OrbitalAngle = 0;
                            MovementSmoothing = previousSmoothing;
                        }

                    }
                }


                if (Input.GetMouseButton(2))
                {
                    if (dummyTarget == null)
                    {
                        // We need a Dummy Target to anchor the Camera
                        dummyTarget = new GameObject("Camera Target").transform;
                        dummyTarget.position = CameraTarget.position;
                        dummyTarget.rotation = CameraTarget.rotation;
                        CameraTarget = dummyTarget;
                        previousSmoothing = MovementSmoothing;
                        MovementSmoothing = false;
                    }
                    else if (dummyTarget != CameraTarget)
                    {
                        // Move DummyTarget to CameraTarget
                        dummyTarget.position = CameraTarget.position;
                        dummyTarget.rotation = CameraTarget.rotation;
                        CameraTarget = dummyTarget;
                        previousSmoothing = MovementSmoothing;
                        MovementSmoothing = false;
                    }


                    mouseY = Input.GetAxis("Mouse Y");
                    mouseX = Input.GetAxis("Mouse X");

                    moveVector = cameraTransform.TransformDirection(mouseX, mouseY, 0);

                    dummyTarget.Translate(-moveVector, Space.World);

                }

            }

            // Check Pinching to Zoom in - out on Mobile device
            if (touchCount == 2)
            {
                Touch touch0 = Input.GetTouch(0);
                Touch touch1 = Input.GetTouch(1);

                Vector2 touch0PrevPos = touch0.position - touch0.deltaPosition;
                Vector2 touch1PrevPos = touch1.position - touch1.deltaPosition;

                float prevTouchDelta = (touch0PrevPos - touch1PrevPos).magnitude;
                float touchDelta = (touch0.position - touch1.position).magnitude;

                float zoomDelta = prevTouchDelta - touchDelta;

                if (zoomDelta > 0.01f || zoomDelta < -0.01f)
                {
                    FollowDistance += zoomDelta * 0.25f;
                    // Limit FollowDistance between min & max values.
                    FollowDistance = Mathf.Clamp(FollowDistance, MinFollowDistance, MaxFollowDistance);
                }


            }

            // Check MouseWheel to Zoom in-out
            if (mouseWheel < -0.01f || mouseWheel > 0.01f)
            {

                FollowDistance -= mouseWheel * 5.0f;
                // Limit FollowDistance between min & max values.
                FollowDistance = Mathf.Clamp(FollowDistance, MinFollowDistance, MaxFollowDistance);
            }


        }
    }
}

==================== VertexZoom.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/VertexZoom.cs) ====================
﻿using UnityEngine;
using System.Linq;
using System.Collections;
using System.Collections.Generic;


namespace TMPro.Examples
{

    public class VertexZoom : MonoBehaviour
    {
        public float AngleMultiplier = 1.0f;
        public float SpeedMultiplier = 1.0f;
        public float CurveScale = 1.0f;

        private TMP_Text m_TextComponent;
        private bool hasTextChanged;


        void Awake()
        {
            m_TextComponent = GetComponent<TMP_Text>();
        }

        void OnEnable()
        {
            // Subscribe to event fired when text object has been regenerated.
            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
        }

        void OnDisable()
        {
            // UnSubscribe to event fired when text object has been regenerated.
            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
        }


        void Start()
        {
            StartCoroutine(AnimateVertexColors());
        }


        void ON_TEXT_CHANGED(Object obj)
        {
            if (obj == m_TextComponent)
                hasTextChanged = true;
        }

        /// <summary>
        /// Method to animate vertex colors of a TMP Text object.
        /// </summary>
        /// <returns></returns>
        IEnumerator AnimateVertexColors()
        {

            // We force an update of the text object since it would only be updated at the end of the frame. Ie. before this code is executed on the first frame.
            // Alternatively, we could yield and wait until the end of the frame when the text object will be generated.
            m_TextComponent.ForceMeshUpdate();

            TMP_TextInfo textInfo = m_TextComponent.textInfo;

            Matrix4x4 matrix;
            TMP_MeshInfo[] cachedMeshInfoVertexData = textInfo.CopyMeshInfoVertexData();

            // Allocations for sorting of the modified scales
            List<float> modifiedCharScale = new List<float>();
            List<int> scaleSortingOrder = new List<int>();

            hasTextChanged = true;

            while (true)
            {
                // Allocate new vertices 
                if (hasTextChanged)
                {
                    // Get updated vertex data
                    cachedMeshInfoVertexData = textInfo.CopyMeshInfoVertexData();

                    hasTextChanged = false;
                }

                int characterCount = textInfo.characterCount;

                // If No Characters then just yield and wait for some text to be added
                if (characterCount == 0)
                {
                    yield return new WaitForSeconds(0.25f);
                    continue;
                }

                // Clear list of character scales
                modifiedCharScale.Clear();
                scaleSortingOrder.Clear();

                for (int i = 0; i < characterCount; i++)
                {
                    TMP_CharacterInfo charInfo = textInfo.characterInfo[i];

                    // Skip characters that are not visible and thus have no geometry to manipulate.
                    if (!charInfo.isVisible)
                        continue;

                    // Get the index of the material used by the current character.
                    int materialIndex = textInfo.characterInfo[i].materialReferenceIndex;

                    // Get the index of the first vertex used by this text element.
                    int vertexIndex = textInfo.characterInfo[i].vertexIndex;

                    // Get the cached vertices of the mesh used by this text element (character or sprite).
                    Vector3[] sourceVertices = cachedMeshInfoVertexData[materialIndex].vertices;

                    // Determine the center point of each character at the baseline.
                    //Vector2 charMidBasline = new Vector2((sourceVertices[vertexIndex + 0].x + sourceVertices[vertexIndex + 2].x) / 2, charInfo.baseLine);
                    // Determine the center point of each character.
                    Vector2 charMidBasline = (sourceVertices[vertexIndex + 0] + sourceVertices[vertexIndex + 2]) / 2;

                    // Need to translate all 4 vertices of each quad to aligned with middle of character / baseline.
                    // This is needed so the matrix TRS is applied at the origin for each character.
                    Vector3 offset = charMidBasline;

                    Vector3[] destinationVertices = textInfo.meshInfo[materialIndex].vertices;

                    destinationVertices[vertexIndex + 0] = sourceVertices[vertexIndex + 0] - offset;
                    destinationVertices[vertexIndex + 1] = sourceVertices[vertexIndex + 1] - offset;
                    destinationVertices[vertexIndex + 2] = sourceVertices[vertexIndex + 2] - offset;
                    destinationVertices[vertexIndex + 3] = sourceVertices[vertexIndex + 3] - offset;

                    //Vector3 jitterOffset = new Vector3(Random.Range(-.25f, .25f), Random.Range(-.25f, .25f), 0);

                    // Determine the random scale change for each character.
                    float randomScale = Random.Range(1f, 1.5f);
                    
                    // Add modified scale and index
                    modifiedCharScale.Add(randomScale);
                    scaleSortingOrder.Add(modifiedCharScale.Count - 1);

                    // Setup the matrix for the scale change.
                    //matrix = Matrix4x4.TRS(jitterOffset, Quaternion.Euler(0, 0, Random.Range(-5f, 5f)), Vector3.one * randomScale);
                    matrix = Matrix4x4.TRS(new Vector3(0, 0, 0), Quaternion.identity, Vector3.one * randomScale);

                    destinationVertices[vertexIndex + 0] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 0]);
                    destinationVertices[vertexIndex + 1] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 1]);
                    destinationVertices[vertexIndex + 2] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 2]);
                    destinationVertices[vertexIndex + 3] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 3]);

                    destinationVertices[vertexIndex + 0] += offset;
                    destinationVertices[vertexIndex + 1] += offset;
                    destinationVertices[vertexIndex + 2] += offset;
                    destinationVertices[vertexIndex + 3] += offset;

                    // Restore Source UVS which have been modified by the sorting
                    Vector2[] sourceUVs0 = cachedMeshInfoVertexData[materialIndex].uvs0;
                    Vector2[] destinationUVs0 = textInfo.meshInfo[materialIndex].uvs0;

                    destinationUVs0[vertexIndex + 0] = sourceUVs0[vertexIndex + 0];
                    destinationUVs0[vertexIndex + 1] = sourceUVs0[vertexIndex + 1];
                    destinationUVs0[vertexIndex + 2] = sourceUVs0[vertexIndex + 2];
                    destinationUVs0[vertexIndex + 3] = sourceUVs0[vertexIndex + 3];

                    // Restore Source Vertex Colors
                    Color32[] sourceColors32 = cachedMeshInfoVertexData[materialIndex].colors32;
                    Color32[] destinationColors32 = textInfo.meshInfo[materialIndex].colors32;

                    destinationColors32[vertexIndex + 0] = sourceColors32[vertexIndex + 0];
                    destinationColors32[vertexIndex + 1] = sourceColors32[vertexIndex + 1];
                    destinationColors32[vertexIndex + 2] = sourceColors32[vertexIndex + 2];
                    destinationColors32[vertexIndex + 3] = sourceColors32[vertexIndex + 3];
                }

                // Push changes into meshes
                for (int i = 0; i < textInfo.meshInfo.Length; i++)
                {
                    //// Sort Quads based modified scale
                    scaleSortingOrder.Sort((a, b) => modifiedCharScale[a].CompareTo(modifiedCharScale[b]));

                    textInfo.meshInfo[i].SortGeometry(scaleSortingOrder);

                    // Updated modified vertex attributes
                    textInfo.meshInfo[i].mesh.vertices = textInfo.meshInfo[i].vertices;
                    textInfo.meshInfo[i].mesh.uv = textInfo.meshInfo[i].uvs0;
                    textInfo.meshInfo[i].mesh.colors32 = textInfo.meshInfo[i].colors32;

                    m_TextComponent.UpdateGeometry(textInfo.meshInfo[i].mesh, i);
                }

                yield return new WaitForSeconds(0.1f);
            }
        }

    }
}

==================== TextMeshProFloatingText.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/TextMeshProFloatingText.cs) ====================
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{

    public class TextMeshProFloatingText : MonoBehaviour
    {
        public Font TheFont;

        private GameObject m_floatingText;
        private TextMeshPro m_textMeshPro;
        private TextMesh m_textMesh;

        private Transform m_transform;
        private Transform m_floatingText_Transform;
        private Transform m_cameraTransform;

        Vector3 lastPOS = Vector3.zero;
        Quaternion lastRotation = Quaternion.identity;

        public int SpawnType;
        public bool IsTextObjectScaleStatic;

        //private int m_frame = 0;

        static WaitForEndOfFrame k_WaitForEndOfFrame = new WaitForEndOfFrame();
        static WaitForSeconds[] k_WaitForSecondsRandom = new WaitForSeconds[]
        {
            new WaitForSeconds(0.05f), new WaitForSeconds(0.1f), new WaitForSeconds(0.15f), new WaitForSeconds(0.2f), new WaitForSeconds(0.25f),
            new WaitForSeconds(0.3f), new WaitForSeconds(0.35f), new WaitForSeconds(0.4f), new WaitForSeconds(0.45f), new WaitForSeconds(0.5f),
            new WaitForSeconds(0.55f), new WaitForSeconds(0.6f), new WaitForSeconds(0.65f), new WaitForSeconds(0.7f), new WaitForSeconds(0.75f),
            new WaitForSeconds(0.8f), new WaitForSeconds(0.85f), new WaitForSeconds(0.9f), new WaitForSeconds(0.95f), new WaitForSeconds(1.0f),
        };

        void Awake()
        {
            m_transform = transform;
            m_floatingText = new GameObject(this.name + " floating text");

            // Reference to Transform is lost when TMP component is added since it replaces it by a RectTransform.
            //m_floatingText_Transform = m_floatingText.transform;
            //m_floatingText_Transform.position = m_transform.position + new Vector3(0, 15f, 0);

            m_cameraTransform = Camera.main.transform;
        }

        void Start()
        {
            if (SpawnType == 0)
            {
                // TextMesh Pro Implementation
                m_textMeshPro = m_floatingText.AddComponent<TextMeshPro>();
                m_textMeshPro.rectTransform.sizeDelta = new Vector2(3, 3);

                m_floatingText_Transform = m_floatingText.transform;
                m_floatingText_Transform.position = m_transform.position + new Vector3(0, 15f, 0);

                //m_textMeshPro.fontAsset = Resources.Load("Fonts & Materials/JOKERMAN SDF", typeof(TextMeshProFont)) as TextMeshProFont; // User should only provide a string to the resource.
                //m_textMeshPro.fontSharedMaterial = Resources.Load("Fonts & Materials/LiberationSans SDF", typeof(Material)) as Material;

                m_textMeshPro.alignment = TextAlignmentOptions.Center;
                m_textMeshPro.color = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255);
                m_textMeshPro.fontSize = 24;
                //m_textMeshPro.enableExtraPadding = true;
                //m_textMeshPro.enableShadows = false;
                m_textMeshPro.enableKerning = false;
                m_textMeshPro.text = string.Empty;
                m_textMeshPro.isTextObjectScaleStatic = IsTextObjectScaleStatic;

                StartCoroutine(DisplayTextMeshProFloatingText());
            }
            else if (SpawnType == 1)
            {
                //Debug.Log("Spawning TextMesh Objects.");

                m_floatingText_Transform = m_floatingText.transform;
                m_floatingText_Transform.position = m_transform.position + new Vector3(0, 15f, 0);

                m_textMesh = m_floatingText.AddComponent<TextMesh>();
                m_textMesh.font = Resources.Load<Font>("Fonts/ARIAL");
                m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material;
                m_textMesh.color = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255);
                m_textMesh.anchor = TextAnchor.LowerCenter;
                m_textMesh.fontSize = 24;

                StartCoroutine(DisplayTextMeshFloatingText());
            }
            else if (SpawnType == 2)
            {

            }

        }


        //void Update()
        //{
        //    if (SpawnType == 0)
        //    {
        //        m_textMeshPro.SetText("{0}", m_frame);
        //    }
        //    else
        //    {
        //        m_textMesh.text = m_frame.ToString();
        //    }
        //    m_frame = (m_frame + 1) % 1000;

        //}


        public IEnumerator DisplayTextMeshProFloatingText()
        {
            float CountDuration = 2.0f; // How long is the countdown alive.
            float starting_Count = Random.Range(5f, 20f); // At what number is the counter starting at.
            float current_Count = starting_Count;

            Vector3 start_pos = m_floatingText_Transform.position;
            Color32 start_color = m_textMeshPro.color;
            float alpha = 255;
            int int_counter = 0;


            float fadeDuration = 3 / starting_Count * CountDuration;

            while (current_Count > 0)
            {
                current_Count -= (Time.deltaTime / CountDuration) * starting_Count;

                if (current_Count <= 3)
                {
                    //Debug.Log("Fading Counter ... " + current_Count.ToString("f2"));
                    alpha = Mathf.Clamp(alpha - (Time.deltaTime / fadeDuration) * 255, 0, 255);
                }

                int_counter = (int)current_Count;
                m_textMeshPro.text = int_counter.ToString();
                //m_textMeshPro.SetText("{0}", (int)current_Count);

                m_textMeshPro.color = new Color32(start_color.r, start_color.g, start_color.b, (byte)alpha);

                // Move the floating text upward each update
                m_floatingText_Transform.position += new Vector3(0, starting_Count * Time.deltaTime, 0);

                // Align floating text perpendicular to Camera.
                if (!lastPOS.Compare(m_cameraTransform.position, 1000) || !lastRotation.Compare(m_cameraTransform.rotation, 1000))
                {
                    lastPOS = m_cameraTransform.position;
                    lastRotation = m_cameraTransform.rotation;
                    m_floatingText_Transform.rotation = lastRotation;
                    Vector3 dir = m_transform.position - lastPOS;
                    m_transform.forward = new Vector3(dir.x, 0, dir.z);
                }

                yield return k_WaitForEndOfFrame;
            }

            //Debug.Log("Done Counting down.");

            yield return k_WaitForSecondsRandom[Random.Range(0, 19)];

            m_floatingText_Transform.position = start_pos;

            StartCoroutine(DisplayTextMeshProFloatingText());
        }


        public IEnumerator DisplayTextMeshFloatingText()
        {
            float CountDuration = 2.0f; // How long is the countdown alive.
            float starting_Count = Random.Range(5f, 20f); // At what number is the counter starting at.
            float current_Count = starting_Count;

            Vector3 start_pos = m_floatingText_Transform.position;
            Color32 start_color = m_textMesh.color;
            float alpha = 255;
            int int_counter = 0;

            float fadeDuration = 3 / starting_Count * CountDuration;

            while (current_Count > 0)
            {
                current_Count -= (Time.deltaTime / CountDuration) * starting_Count;

                if (current_Count <= 3)
                {
                    //Debug.Log("Fading Counter ... " + current_Count.ToString("f2"));
                    alpha = Mathf.Clamp(alpha - (Time.deltaTime / fadeDuration) * 255, 0, 255);
                }

                int_counter = (int)current_Count;
                m_textMesh.text = int_counter.ToString();
                //Debug.Log("Current Count:" + current_Count.ToString("f2"));

                m_textMesh.color = new Color32(start_color.r, start_color.g, start_color.b, (byte)alpha);

                // Move the floating text upward each update
                m_floatingText_Transform.position += new Vector3(0, starting_Count * Time.deltaTime, 0);

                // Align floating text perpendicular to Camera.
                if (!lastPOS.Compare(m_cameraTransform.position, 1000) || !lastRotation.Compare(m_cameraTransform.rotation, 1000))
                {
                    lastPOS = m_cameraTransform.position;
                    lastRotation = m_cameraTransform.rotation;
                    m_floatingText_Transform.rotation = lastRotation;
                    Vector3 dir = m_transform.position - lastPOS;
                    m_transform.forward = new Vector3(dir.x, 0, dir.z);
                }

                yield return k_WaitForEndOfFrame;
            }

            //Debug.Log("Done Counting down.");

            yield return k_WaitForSecondsRandom[Random.Range(0, 20)];

            m_floatingText_Transform.position = start_pos;

            StartCoroutine(DisplayTextMeshFloatingText());
        }
    }
}


==================== Benchmark03.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/Benchmark03.cs) ====================
﻿using UnityEngine;
using System.Collections;
using UnityEngine.TextCore.LowLevel;


namespace TMPro.Examples
{

    public class Benchmark03 : MonoBehaviour
    {
        public enum BenchmarkType { TMP_SDF_MOBILE = 0, TMP_SDF__MOBILE_SSD = 1, TMP_SDF = 2, TMP_BITMAP_MOBILE = 3, TEXTMESH_BITMAP = 4 }

        public int NumberOfSamples = 100;
        public BenchmarkType Benchmark;

        public Font SourceFont;


        void Awake()
        {

        }


        void Start()
        {
            TMP_FontAsset fontAsset = null;

            // Create Dynamic Font Asset for the given font file.
            switch (Benchmark)
            {
                case BenchmarkType.TMP_SDF_MOBILE:
                    fontAsset = TMP_FontAsset.CreateFontAsset(SourceFont, 90, 9, GlyphRenderMode.SDFAA, 256, 256, AtlasPopulationMode.Dynamic);
                    break;
                case BenchmarkType.TMP_SDF__MOBILE_SSD:
                    fontAsset = TMP_FontAsset.CreateFontAsset(SourceFont, 90, 9, GlyphRenderMode.SDFAA, 256, 256, AtlasPopulationMode.Dynamic);
                    fontAsset.material.shader = Shader.Find("TextMeshPro/Mobile/Distance Field SSD");
                    break;
                case BenchmarkType.TMP_SDF:
                    fontAsset = TMP_FontAsset.CreateFontAsset(SourceFont, 90, 9, GlyphRenderMode.SDFAA, 256, 256, AtlasPopulationMode.Dynamic);
                    fontAsset.material.shader = Shader.Find("TextMeshPro/Distance Field");
                    break;
                case BenchmarkType.TMP_BITMAP_MOBILE:
                    fontAsset = TMP_FontAsset.CreateFontAsset(SourceFont, 90, 9, GlyphRenderMode.SMOOTH, 256, 256, AtlasPopulationMode.Dynamic);
                    break;
            }

            for (int i = 0; i < NumberOfSamples; i++)
            {
                switch (Benchmark)
                {
                    case BenchmarkType.TMP_SDF_MOBILE:
                    case BenchmarkType.TMP_SDF__MOBILE_SSD:
                    case BenchmarkType.TMP_SDF:
                    case BenchmarkType.TMP_BITMAP_MOBILE:
                        {
                            GameObject go = new GameObject();
                            go.transform.position = new Vector3(0, 1.2f, 0);

                            TextMeshPro textComponent = go.AddComponent<TextMeshPro>();
                            textComponent.font = fontAsset;
                            textComponent.fontSize = 128;
                            textComponent.text = "@";
                            textComponent.alignment = TextAlignmentOptions.Center;
                            textComponent.color = new Color32(255, 255, 0, 255);

                            if (Benchmark == BenchmarkType.TMP_BITMAP_MOBILE)
                                textComponent.fontSize = 132;

                        }
                        break;
                    case BenchmarkType.TEXTMESH_BITMAP:
                        {
                            GameObject go = new GameObject();
                            go.transform.position = new Vector3(0, 1.2f, 0);

                            TextMesh textMesh = go.AddComponent<TextMesh>();
                            textMesh.GetComponent<Renderer>().sharedMaterial = SourceFont.material;
                            textMesh.font = SourceFont;
                            textMesh.anchor = TextAnchor.MiddleCenter;
                            textMesh.fontSize = 130;

                            textMesh.color = new Color32(255, 255, 0, 255);
                            textMesh.text = "@";
                        }
                        break;
                }
            }
        }

    }
}


==================== VertexShakeB.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/VertexShakeB.cs) ====================
﻿using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{

    public class VertexShakeB : MonoBehaviour
    {

        public float AngleMultiplier = 1.0f;
        public float SpeedMultiplier = 1.0f;
        public float CurveScale = 1.0f;

        private TMP_Text m_TextComponent;
        private bool hasTextChanged;


        void Awake()
        {
            m_TextComponent = GetComponent<TMP_Text>();
        }

        void OnEnable()
        {
            // Subscribe to event fired when text object has been regenerated.
            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
        }

        void OnDisable()
        {
            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
        }


        void Start()
        {
            StartCoroutine(AnimateVertexColors());
        }


        void ON_TEXT_CHANGED(Object obj)
        {
            if (obj = m_TextComponent)
                hasTextChanged = true;
        }

        /// <summary>
        /// Method to animate vertex colors of a TMP Text object.
        /// </summary>
        /// <returns></returns>
        IEnumerator AnimateVertexColors()
        {

            // We force an update of the text object since it would only be updated at the end of the frame. Ie. before this code is executed on the first frame.
            // Alternatively, we could yield and wait until the end of the frame when the text object will be generated.
            m_TextComponent.ForceMeshUpdate();

            TMP_TextInfo textInfo = m_TextComponent.textInfo;

            Matrix4x4 matrix;
            Vector3[][] copyOfVertices = new Vector3[0][];

            hasTextChanged = true;

            while (true)
            {
                // Allocate new vertices 
                if (hasTextChanged)
                {
                    if (copyOfVertices.Length < textInfo.meshInfo.Length)
                        copyOfVertices = new Vector3[textInfo.meshInfo.Length][];

                    for (int i = 0; i < textInfo.meshInfo.Length; i++)
                    {
                        int length = textInfo.meshInfo[i].vertices.Length;
                        copyOfVertices[i] = new Vector3[length];
                    }

                    hasTextChanged = false;
                }

                int characterCount = textInfo.characterCount;

                // If No Characters then just yield and wait for some text to be added
                if (characterCount == 0)
                {
                    yield return new WaitForSeconds(0.25f);
                    continue;
                }

                int lineCount = textInfo.lineCount;

                // Iterate through each line of the text.
                for (int i = 0; i < lineCount; i++)
                {

                    int first = textInfo.lineInfo[i].firstCharacterIndex;
                    int last = textInfo.lineInfo[i].lastCharacterIndex;

                    // Determine the center of each line
                    Vector3 centerOfLine = (textInfo.characterInfo[first].bottomLeft + textInfo.characterInfo[last].topRight) / 2;
                    Quaternion rotation = Quaternion.Euler(0, 0, Random.Range(-0.25f, 0.25f));

                    // Iterate through each character of the line.
                    for (int j = first; j <= last; j++)
                    {
                        // Skip characters that are not visible and thus have no geometry to manipulate.
                        if (!textInfo.characterInfo[j].isVisible)
                            continue;

                        // Get the index of the material used by the current character.
                        int materialIndex = textInfo.characterInfo[j].materialReferenceIndex;

                        // Get the index of the first vertex used by this text element.
                        int vertexIndex = textInfo.characterInfo[j].vertexIndex;

                        // Get the vertices of the mesh used by this text element (character or sprite).
                        Vector3[] sourceVertices = textInfo.meshInfo[materialIndex].vertices;

                        // Determine the center point of each character at the baseline.
                        Vector3 charCenter = (sourceVertices[vertexIndex + 0] + sourceVertices[vertexIndex + 2]) / 2;

                        // Need to translate all 4 vertices of each quad to aligned with center of character.
                        // This is needed so the matrix TRS is applied at the origin for each character.
                        copyOfVertices[materialIndex][vertexIndex + 0] = sourceVertices[vertexIndex + 0] - charCenter;
                        copyOfVertices[materialIndex][vertexIndex + 1] = sourceVertices[vertexIndex + 1] - charCenter;
                        copyOfVertices[materialIndex][vertexIndex + 2] = sourceVertices[vertexIndex + 2] - charCenter;
                        copyOfVertices[materialIndex][vertexIndex + 3] = sourceVertices[vertexIndex + 3] - charCenter;

                        // Determine the random scale change for each character.
                        float randomScale = Random.Range(0.95f, 1.05f);

                        // Setup the matrix for the scale change.
                        matrix = Matrix4x4.TRS(Vector3.one, Quaternion.identity, Vector3.one * randomScale);

                        // Apply the scale change relative to the center of each character.
                        copyOfVertices[materialIndex][vertexIndex + 0] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 0]);
                        copyOfVertices[materialIndex][vertexIndex + 1] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 1]);
                        copyOfVertices[materialIndex][vertexIndex + 2] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 2]);
                        copyOfVertices[materialIndex][vertexIndex + 3] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 3]);

                        // Revert the translation change.
                        copyOfVertices[materialIndex][vertexIndex + 0] += charCenter;
                        copyOfVertices[materialIndex][vertexIndex + 1] += charCenter;
                        copyOfVertices[materialIndex][vertexIndex + 2] += charCenter;
                        copyOfVertices[materialIndex][vertexIndex + 3] += charCenter;

                        // Need to translate all 4 vertices of each quad to aligned with the center of the line.
                        // This is needed so the matrix TRS is applied from the center of the line.
                        copyOfVertices[materialIndex][vertexIndex + 0] -= centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 1] -= centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 2] -= centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 3] -= centerOfLine;

                        // Setup the matrix rotation.
                        matrix = Matrix4x4.TRS(Vector3.one, rotation, Vector3.one);

                        // Apply the matrix TRS to the individual characters relative to the center of the current line.
                        copyOfVertices[materialIndex][vertexIndex + 0] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 0]);
                        copyOfVertices[materialIndex][vertexIndex + 1] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 1]);
                        copyOfVertices[materialIndex][vertexIndex + 2] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 2]);
                        copyOfVertices[materialIndex][vertexIndex + 3] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 3]);

                        // Revert the translation change.
                        copyOfVertices[materialIndex][vertexIndex + 0] += centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 1] += centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 2] += centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 3] += centerOfLine;
                    }
                }

                // Push changes into meshes
                for (int i = 0; i < textInfo.meshInfo.Length; i++)
                {
                    textInfo.meshInfo[i].mesh.vertices = copyOfVertices[i];
                    m_TextComponent.UpdateGeometry(textInfo.meshInfo[i].mesh, i);
                }

                yield return new WaitForSeconds(0.1f);
            }
        }

    }
}

==================== TeleType.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/TeleType.cs) ====================
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class TeleType : MonoBehaviour
    {


        //[Range(0, 100)]
        //public int RevealSpeed = 50;

        private string label01 = "Example <sprite=2> of using <sprite=7> <#ffa000>Graphics Inline</color> <sprite=5> with Text in <font=\"Bangers SDF\" material=\"Bangers SDF - Drop Shadow\">TextMesh<#40a0ff>Pro</color></font><sprite=0> and Unity<sprite=1>";
        private string label02 = "Example <sprite=2> of using <sprite=7> <#ffa000>Graphics Inline</color> <sprite=5> with Text in <font=\"Bangers SDF\" material=\"Bangers SDF - Drop Shadow\">TextMesh<#40a0ff>Pro</color></font><sprite=0> and Unity<sprite=2>";


        private TMP_Text m_textMeshPro;


        void Awake()
        {
            // Get Reference to TextMeshPro Component
            m_textMeshPro = GetComponent<TMP_Text>();
            m_textMeshPro.text = label01;
            m_textMeshPro.enableWordWrapping = true;
            m_textMeshPro.alignment = TextAlignmentOptions.Top;



            //if (GetComponentInParent(typeof(Canvas)) as Canvas == null)
            //{
            //    GameObject canvas = new GameObject("Canvas", typeof(Canvas));
            //    gameObject.transform.SetParent(canvas.transform);
            //    canvas.GetComponent<Canvas>().renderMode = RenderMode.ScreenSpaceOverlay;

            //    // Set RectTransform Size
            //    gameObject.GetComponent<RectTransform>().sizeDelta = new Vector2(500, 300);
            //    m_textMeshPro.fontSize = 48;
            //}


        }


        IEnumerator Start()
        {

            // Force and update of the mesh to get valid information.
            m_textMeshPro.ForceMeshUpdate();


            int totalVisibleCharacters = m_textMeshPro.textInfo.characterCount; // Get # of Visible Character in text object
            int counter = 0;
            int visibleCount = 0;

            while (true)
            {
                visibleCount = counter % (totalVisibleCharacters + 1);

                m_textMeshPro.maxVisibleCharacters = visibleCount; // How many characters should TextMeshPro display?

                // Once the last character has been revealed, wait 1.0 second and start over.
                if (visibleCount >= totalVisibleCharacters)
                {
                    yield return new WaitForSeconds(1.0f);
                    m_textMeshPro.text = label02;
                    yield return new WaitForSeconds(1.0f);
                    m_textMeshPro.text = label01;
                    yield return new WaitForSeconds(1.0f);
                }

                counter += 1;

                yield return new WaitForSeconds(0.05f);
            }

            //Debug.Log("Done revealing the text.");
        }

    }
}

==================== TMP_ExampleScript_01.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_ExampleScript_01.cs) ====================
﻿using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using TMPro;


namespace TMPro.Examples
{

    public class TMP_ExampleScript_01 : MonoBehaviour
    {
        public enum objectType { TextMeshPro = 0, TextMeshProUGUI = 1 };

        public objectType ObjectType;
        public bool isStatic;

        private TMP_Text m_text;

        //private TMP_InputField m_inputfield;


        private const string k_label = "The count is <#0080ff>{0}</color>";
        private int count;

        void Awake()
        {
            // Get a reference to the TMP text component if one already exists otherwise add one.
            // This example show the convenience of having both TMP components derive from TMP_Text. 
            if (ObjectType == 0)
                m_text = GetComponent<TextMeshPro>() ?? gameObject.AddComponent<TextMeshPro>();
            else
                m_text = GetComponent<TextMeshProUGUI>() ?? gameObject.AddComponent<TextMeshProUGUI>();

            // Load a new font asset and assign it to the text object.
            m_text.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/Anton SDF");

            // Load a new material preset which was created with the context menu duplicate.
            m_text.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/Anton SDF - Drop Shadow");

            // Set the size of the font.
            m_text.fontSize = 120;

            // Set the text
            m_text.text = "A <#0080ff>simple</color> line of text.";

            // Get the preferred width and height based on the supplied width and height as opposed to the actual size of the current text container.
            Vector2 size = m_text.GetPreferredValues(Mathf.Infinity, Mathf.Infinity);

            // Set the size of the RectTransform based on the new calculated values.
            m_text.rectTransform.sizeDelta = new Vector2(size.x, size.y);
        }


        void Update()
        {
            if (!isStatic)
            {
                m_text.SetText(k_label, count % 1000);
                count += 1;
            }
        }

    }
}


==================== TMP_TextSelector_B.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_TextSelector_B.cs) ====================
﻿using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using System.Collections;
using System.Collections.Generic;


#pragma warning disable 0618 // Disabled warning due to SetVertices being deprecated until new release with SetMesh() is available.

namespace TMPro.Examples
{

    public class TMP_TextSelector_B : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerClickHandler, IPointerUpHandler
    {
        public RectTransform TextPopup_Prefab_01;

        private RectTransform m_TextPopup_RectTransform;
        private TextMeshProUGUI m_TextPopup_TMPComponent;
        private const string k_LinkText = "You have selected link <#ffff00>";
        private const string k_WordText = "Word Index: <#ffff00>";


        private TextMeshProUGUI m_TextMeshPro;
        private Canvas m_Canvas;
        private Camera m_Camera;

        // Flags
        private bool isHoveringObject;
        private int m_selectedWord = -1;
        private int m_selectedLink = -1;
        private int m_lastIndex = -1;

        private Matrix4x4 m_matrix;

        private TMP_MeshInfo[] m_cachedMeshInfoVertexData;

        void Awake()
        {
            m_TextMeshPro = gameObject.GetComponent<TextMeshProUGUI>();


            m_Canvas = gameObject.GetComponentInParent<Canvas>();

            // Get a reference to the camera if Canvas Render Mode is not ScreenSpace Overlay.
            if (m_Canvas.renderMode == RenderMode.ScreenSpaceOverlay)
                m_Camera = null;
            else
                m_Camera = m_Canvas.worldCamera;

            // Create pop-up text object which is used to show the link information.
            m_TextPopup_RectTransform = Instantiate(TextPopup_Prefab_01) as RectTransform;
            m_TextPopup_RectTransform.SetParent(m_Canvas.transform, false);
            m_TextPopup_TMPComponent = m_TextPopup_RectTransform.GetComponentInChildren<TextMeshProUGUI>();
            m_TextPopup_RectTransform.gameObject.SetActive(false);
        }


        void OnEnable()
        {
            // Subscribe to event fired when text object has been regenerated.
            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
        }

        void OnDisable()
        {
            // UnSubscribe to event fired when text object has been regenerated.
            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
        }


        void ON_TEXT_CHANGED(Object obj)
        {
            if (obj == m_TextMeshPro)
            {
                // Update cached vertex data.
                m_cachedMeshInfoVertexData = m_TextMeshPro.textInfo.CopyMeshInfoVertexData();
            }
        }


        void LateUpdate()
        {
            if (isHoveringObject)
            {
                // Check if Mouse Intersects any of the characters. If so, assign a random color.
                #region Handle Character Selection
                int charIndex = TMP_TextUtilities.FindIntersectingCharacter(m_TextMeshPro, Input.mousePosition, m_Camera, true);

                // Undo Swap and Vertex Attribute changes.
                if (charIndex == -1 || charIndex != m_lastIndex)
                {
                    RestoreCachedVertexAttributes(m_lastIndex);
                    m_lastIndex = -1;
                }

                if (charIndex != -1 && charIndex != m_lastIndex && (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)))
                {
                    m_lastIndex = charIndex;

                    // Get the index of the material / sub text object used by this character.
                    int materialIndex = m_TextMeshPro.textInfo.characterInfo[charIndex].materialReferenceIndex;

                    // Get the index of the first vertex of the selected character.
                    int vertexIndex = m_TextMeshPro.textInfo.characterInfo[charIndex].vertexIndex;

                    // Get a reference to the vertices array.
                    Vector3[] vertices = m_TextMeshPro.textInfo.meshInfo[materialIndex].vertices;

                    // Determine the center point of the character.
                    Vector2 charMidBasline = (vertices[vertexIndex + 0] + vertices[vertexIndex + 2]) / 2;

                    // Need to translate all 4 vertices of the character to aligned with middle of character / baseline.
                    // This is needed so the matrix TRS is applied at the origin for each character.
                    Vector3 offset = charMidBasline;

                    // Translate the character to the middle baseline.
                    vertices[vertexIndex + 0] = vertices[vertexIndex + 0] - offset;
                    vertices[vertexIndex + 1] = vertices[vertexIndex + 1] - offset;
                    vertices[vertexIndex + 2] = vertices[vertexIndex + 2] - offset;
                    vertices[vertexIndex + 3] = vertices[vertexIndex + 3] - offset;

                    float zoomFactor = 1.5f;

                    // Setup the Matrix for the scale change.
                    m_matrix = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, Vector3.one * zoomFactor);

                    // Apply Matrix operation on the given character.
                    vertices[vertexIndex + 0] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 0]);
                    vertices[vertexIndex + 1] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 1]);
                    vertices[vertexIndex + 2] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 2]);
                    vertices[vertexIndex + 3] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 3]);

                    // Translate the character back to its original position.
                    vertices[vertexIndex + 0] = vertices[vertexIndex + 0] + offset;
                    vertices[vertexIndex + 1] = vertices[vertexIndex + 1] + offset;
                    vertices[vertexIndex + 2] = vertices[vertexIndex + 2] + offset;
                    vertices[vertexIndex + 3] = vertices[vertexIndex + 3] + offset;

                    // Change Vertex Colors of the highlighted character
                    Color32 c = new Color32(255, 255, 192, 255);

                    // Get a reference to the vertex color
                    Color32[] vertexColors = m_TextMeshPro.textInfo.meshInfo[materialIndex].colors32;

                    vertexColors[vertexIndex + 0] = c;
                    vertexColors[vertexIndex + 1] = c;
                    vertexColors[vertexIndex + 2] = c;
                    vertexColors[vertexIndex + 3] = c;


                    // Get a reference to the meshInfo of the selected character.
                    TMP_MeshInfo meshInfo = m_TextMeshPro.textInfo.meshInfo[materialIndex];

                    // Get the index of the last character's vertex attributes.
                    int lastVertexIndex = vertices.Length - 4;

                    // Swap the current character's vertex attributes with those of the last element in the vertex attribute arrays.
                    // We do this to make sure this character is rendered last and over other characters.
                    meshInfo.SwapVertexData(vertexIndex, lastVertexIndex);

                    // Need to update the appropriate 
                    m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);
                }
                #endregion


                #region Word Selection Handling
                //Check if Mouse intersects any words and if so assign a random color to that word.
                int wordIndex = TMP_TextUtilities.FindIntersectingWord(m_TextMeshPro, Input.mousePosition, m_Camera);

                // Clear previous word selection.
                if (m_TextPopup_RectTransform != null && m_selectedWord != -1 && (wordIndex == -1 || wordIndex != m_selectedWord))
                {
                    TMP_WordInfo wInfo = m_TextMeshPro.textInfo.wordInfo[m_selectedWord];

                    // Iterate through each of the characters of the word.
                    for (int i = 0; i < wInfo.characterCount; i++)
                    {
                        int characterIndex = wInfo.firstCharacterIndex + i;

                        // Get the index of the material / sub text object used by this character.
                        int meshIndex = m_TextMeshPro.textInfo.characterInfo[characterIndex].materialReferenceIndex;

                        // Get the index of the first vertex of this character.
                        int vertexIndex = m_TextMeshPro.textInfo.characterInfo[characterIndex].vertexIndex;

                        // Get a reference to the vertex color
                        Color32[] vertexColors = m_TextMeshPro.textInfo.meshInfo[meshIndex].colors32;

                        Color32 c = vertexColors[vertexIndex + 0].Tint(1.33333f);

                        vertexColors[vertexIndex + 0] = c;
                        vertexColors[vertexIndex + 1] = c;
                        vertexColors[vertexIndex + 2] = c;
                        vertexColors[vertexIndex + 3] = c;
                    }

                    // Update Geometry
                    m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);

                    m_selectedWord = -1;
                }


                // Word Selection Handling
                if (wordIndex != -1 && wordIndex != m_selectedWord && !(Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)))
                {
                    m_selectedWord = wordIndex;

                    TMP_WordInfo wInfo = m_TextMeshPro.textInfo.wordInfo[wordIndex];

                    // Iterate through each of the characters of the word.
                    for (int i = 0; i < wInfo.characterCount; i++)
                    {
                        int characterIndex = wInfo.firstCharacterIndex + i;

                        // Get the index of the material / sub text object used by this character.
                        int meshIndex = m_TextMeshPro.textInfo.characterInfo[characterIndex].materialReferenceIndex;

                        int vertexIndex = m_TextMeshPro.textInfo.characterInfo[characterIndex].vertexIndex;

                        // Get a reference to the vertex color
                        Color32[] vertexColors = m_TextMeshPro.textInfo.meshInfo[meshIndex].colors32;

                        Color32 c = vertexColors[vertexIndex + 0].Tint(0.75f);

                        vertexColors[vertexIndex + 0] = c;
                        vertexColors[vertexIndex + 1] = c;
                        vertexColors[vertexIndex + 2] = c;
                        vertexColors[vertexIndex + 3] = c;
                    }

                    // Update Geometry
                    m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);

                }
                #endregion


                #region Example of Link Handling
                // Check if mouse intersects with any links.
                int linkIndex = TMP_TextUtilities.FindIntersectingLink(m_TextMeshPro, Input.mousePosition, m_Camera);

                // Clear previous link selection if one existed.
                if ((linkIndex == -1 && m_selectedLink != -1) || linkIndex != m_selectedLink)
                {
                    m_TextPopup_RectTransform.gameObject.SetActive(false);
                    m_selectedLink = -1;
                }

                // Handle new Link selection.
                if (linkIndex != -1 && linkIndex != m_selectedLink)
                {
                    m_selectedLink = linkIndex;

                    TMP_LinkInfo linkInfo = m_TextMeshPro.textInfo.linkInfo[linkIndex];

                    // Debug.Log("Link ID: \"" + linkInfo.GetLinkID() + "\"   Link Text: \"" + linkInfo.GetLinkText() + "\""); // Example of how to retrieve the Link ID and Link Text.

                    Vector3 worldPointInRectangle;
                    RectTransformUtility.ScreenPointToWorldPointInRectangle(m_TextMeshPro.rectTransform, Input.mousePosition, m_Camera, out worldPointInRectangle);

                    switch (linkInfo.GetLinkID())
                    {
                        case "id_01": // 100041637: // id_01
                            m_TextPopup_RectTransform.position = worldPointInRectangle;
                            m_TextPopup_RectTransform.gameObject.SetActive(true);
                            m_TextPopup_TMPComponent.text = k_LinkText + " ID 01";
                            break;
                        case "id_02": // 100041638: // id_02
                            m_TextPopup_RectTransform.position = worldPointInRectangle;
                            m_TextPopup_RectTransform.gameObject.SetActive(true);
                            m_TextPopup_TMPComponent.text = k_LinkText + " ID 02";
                            break;
                    }
                }
                #endregion

            }
            else
            {
                // Restore any character that may have been modified
                if (m_lastIndex != -1)
                {
                    RestoreCachedVertexAttributes(m_lastIndex);
                    m_lastIndex = -1;
                }
            }
            
        }


        public void OnPointerEnter(PointerEventData eventData)
        {
            //Debug.Log("OnPointerEnter()");
            isHoveringObject = true;
        }


        public void OnPointerExit(PointerEventData eventData)
        {
            //Debug.Log("OnPointerExit()");
            isHoveringObject = false;
        }


        public void OnPointerClick(PointerEventData eventData)
        {
            //Debug.Log("Click at POS: " + eventData.position + "  World POS: " + eventData.worldPosition);

            // Check if Mouse Intersects any of the characters. If so, assign a random color.
            #region Character Selection Handling
            /*
            int charIndex = TMP_TextUtilities.FindIntersectingCharacter(m_TextMeshPro, Input.mousePosition, m_Camera, true);
            if (charIndex != -1 && charIndex != m_lastIndex)
            {
                //Debug.Log("Character [" + m_TextMeshPro.textInfo.characterInfo[index].character + "] was selected at POS: " + eventData.position);
                m_lastIndex = charIndex;

                Color32 c = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255);
                int vertexIndex = m_TextMeshPro.textInfo.characterInfo[charIndex].vertexIndex;

                UIVertex[] uiVertices = m_TextMeshPro.textInfo.meshInfo.uiVertices;

                uiVertices[vertexIndex + 0].color = c;
                uiVertices[vertexIndex + 1].color = c;
                uiVertices[vertexIndex + 2].color = c;
                uiVertices[vertexIndex + 3].color = c;

                m_TextMeshPro.canvasRenderer.SetVertices(uiVertices, uiVertices.Length);
            }
            */
            #endregion


            #region Word Selection Handling
            //Check if Mouse intersects any words and if so assign a random color to that word.
            /*
            int wordIndex = TMP_TextUtilities.FindIntersectingWord(m_TextMeshPro, Input.mousePosition, m_Camera);

            // Clear previous word selection.
            if (m_TextPopup_RectTransform != null && m_selectedWord != -1 && (wordIndex == -1 || wordIndex != m_selectedWord))
            {
                TMP_WordInfo wInfo = m_TextMeshPro.textInfo.wordInfo[m_selectedWord];

                // Get a reference to the uiVertices array.
                UIVertex[] uiVertices = m_TextMeshPro.textInfo.meshInfo.uiVertices;

                // Iterate through each of the characters of the word.
                for (int i = 0; i < wInfo.characterCount; i++)
                {
                    int vertexIndex = m_TextMeshPro.textInfo.characterInfo[wInfo.firstCharacterIndex + i].vertexIndex;

                    Color32 c = uiVertices[vertexIndex + 0].color.Tint(1.33333f);

                    uiVertices[vertexIndex + 0].color = c;
                    uiVertices[vertexIndex + 1].color = c;
                    uiVertices[vertexIndex + 2].color = c;
                    uiVertices[vertexIndex + 3].color = c;
                }

                m_TextMeshPro.canvasRenderer.SetVertices(uiVertices, uiVertices.Length);

                m_selectedWord = -1;
            }

            // Handle word selection
            if (wordIndex != -1 && wordIndex != m_selectedWord)
            {
                m_selectedWord = wordIndex;

                TMP_WordInfo wInfo = m_TextMeshPro.textInfo.wordInfo[wordIndex];

                // Get a reference to the uiVertices array.
                UIVertex[] uiVertices = m_TextMeshPro.textInfo.meshInfo.uiVertices;

                // Iterate through each of the characters of the word.
                for (int i = 0; i < wInfo.characterCount; i++)
                {
                    int vertexIndex = m_TextMeshPro.textInfo.characterInfo[wInfo.firstCharacterIndex + i].vertexIndex;

                    Color32 c = uiVertices[vertexIndex + 0].color.Tint(0.75f);

                    uiVertices[vertexIndex + 0].color = c;
                    uiVertices[vertexIndex + 1].color = c;
                    uiVertices[vertexIndex + 2].color = c;
                    uiVertices[vertexIndex + 3].color = c;
                }

                m_TextMeshPro.canvasRenderer.SetVertices(uiVertices, uiVertices.Length);
            }
            */
            #endregion


            #region Link Selection Handling
            /*
            // Check if Mouse intersects any words and if so assign a random color to that word.
            int linkIndex = TMP_TextUtilities.FindIntersectingLink(m_TextMeshPro, Input.mousePosition, m_Camera);
            if (linkIndex != -1)
            {
                TMP_LinkInfo linkInfo = m_TextMeshPro.textInfo.linkInfo[linkIndex];
                int linkHashCode = linkInfo.hashCode;

                //Debug.Log(TMP_TextUtilities.GetSimpleHashCode("id_02"));

                switch (linkHashCode)
                {
                    case 291445: // id_01
                        if (m_LinkObject01 == null)
                            m_LinkObject01 = Instantiate(Link_01_Prefab);
                        else
                        {
                            m_LinkObject01.gameObject.SetActive(true);
                        }

                        break;
                    case 291446: // id_02
                        break;

                }

                // Example of how to modify vertex attributes like colors
                #region Vertex Attribute Modification Example
                UIVertex[] uiVertices = m_TextMeshPro.textInfo.meshInfo.uiVertices;

                Color32 c = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255);
                for (int i = 0; i < linkInfo.characterCount; i++)
                {
                    TMP_CharacterInfo cInfo = m_TextMeshPro.textInfo.characterInfo[linkInfo.firstCharacterIndex + i];

                    if (!cInfo.isVisible) continue; // Skip invisible characters.

                    int vertexIndex = cInfo.vertexIndex;

                    uiVertices[vertexIndex + 0].color = c;
                    uiVertices[vertexIndex + 1].color = c;
                    uiVertices[vertexIndex + 2].color = c;
                    uiVertices[vertexIndex + 3].color = c;
                }

                m_TextMeshPro.canvasRenderer.SetVertices(uiVertices, uiVertices.Length);
                #endregion
            }
            */
            #endregion
        }


        public void OnPointerUp(PointerEventData eventData)
        {
            //Debug.Log("OnPointerUp()");
        }


        void RestoreCachedVertexAttributes(int index)
        {
            if (index == -1 || index > m_TextMeshPro.textInfo.characterCount - 1) return;

            // Get the index of the material / sub text object used by this character.
            int materialIndex = m_TextMeshPro.textInfo.characterInfo[index].materialReferenceIndex;

            // Get the index of the first vertex of the selected character.
            int vertexIndex = m_TextMeshPro.textInfo.characterInfo[index].vertexIndex;

            // Restore Vertices
            // Get a reference to the cached / original vertices.
            Vector3[] src_vertices = m_cachedMeshInfoVertexData[materialIndex].vertices;

            // Get a reference to the vertices that we need to replace.
            Vector3[] dst_vertices = m_TextMeshPro.textInfo.meshInfo[materialIndex].vertices;

            // Restore / Copy vertices from source to destination
            dst_vertices[vertexIndex + 0] = src_vertices[vertexIndex + 0];
            dst_vertices[vertexIndex + 1] = src_vertices[vertexIndex + 1];
            dst_vertices[vertexIndex + 2] = src_vertices[vertexIndex + 2];
            dst_vertices[vertexIndex + 3] = src_vertices[vertexIndex + 3];

            // Restore Vertex Colors
            // Get a reference to the vertex colors we need to replace.
            Color32[] dst_colors = m_TextMeshPro.textInfo.meshInfo[materialIndex].colors32;

            // Get a reference to the cached / original vertex colors.
            Color32[] src_colors = m_cachedMeshInfoVertexData[materialIndex].colors32;

            // Copy the vertex colors from source to destination.
            dst_colors[vertexIndex + 0] = src_colors[vertexIndex + 0];
            dst_colors[vertexIndex + 1] = src_colors[vertexIndex + 1];
            dst_colors[vertexIndex + 2] = src_colors[vertexIndex + 2];
            dst_colors[vertexIndex + 3] = src_colors[vertexIndex + 3];

            // Restore UV0S
            // UVS0
            Vector2[] src_uv0s = m_cachedMeshInfoVertexData[materialIndex].uvs0;
            Vector2[] dst_uv0s = m_TextMeshPro.textInfo.meshInfo[materialIndex].uvs0;
            dst_uv0s[vertexIndex + 0] = src_uv0s[vertexIndex + 0];
            dst_uv0s[vertexIndex + 1] = src_uv0s[vertexIndex + 1];
            dst_uv0s[vertexIndex + 2] = src_uv0s[vertexIndex + 2];
            dst_uv0s[vertexIndex + 3] = src_uv0s[vertexIndex + 3];

            // UVS2
            Vector2[] src_uv2s = m_cachedMeshInfoVertexData[materialIndex].uvs2;
            Vector2[] dst_uv2s = m_TextMeshPro.textInfo.meshInfo[materialIndex].uvs2;
            dst_uv2s[vertexIndex + 0] = src_uv2s[vertexIndex + 0];
            dst_uv2s[vertexIndex + 1] = src_uv2s[vertexIndex + 1];
            dst_uv2s[vertexIndex + 2] = src_uv2s[vertexIndex + 2];
            dst_uv2s[vertexIndex + 3] = src_uv2s[vertexIndex + 3];


            // Restore last vertex attribute as we swapped it as well
            int lastIndex = (src_vertices.Length / 4 - 1) * 4;

            // Vertices
            dst_vertices[lastIndex + 0] = src_vertices[lastIndex + 0];
            dst_vertices[lastIndex + 1] = src_vertices[lastIndex + 1];
            dst_vertices[lastIndex + 2] = src_vertices[lastIndex + 2];
            dst_vertices[lastIndex + 3] = src_vertices[lastIndex + 3];

            // Vertex Colors
            src_colors = m_cachedMeshInfoVertexData[materialIndex].colors32;
            dst_colors = m_TextMeshPro.textInfo.meshInfo[materialIndex].colors32;
            dst_colors[lastIndex + 0] = src_colors[lastIndex + 0];
            dst_colors[lastIndex + 1] = src_colors[lastIndex + 1];
            dst_colors[lastIndex + 2] = src_colors[lastIndex + 2];
            dst_colors[lastIndex + 3] = src_colors[lastIndex + 3];

            // UVS0
            src_uv0s = m_cachedMeshInfoVertexData[materialIndex].uvs0;
            dst_uv0s = m_TextMeshPro.textInfo.meshInfo[materialIndex].uvs0;
            dst_uv0s[lastIndex + 0] = src_uv0s[lastIndex + 0];
            dst_uv0s[lastIndex + 1] = src_uv0s[lastIndex + 1];
            dst_uv0s[lastIndex + 2] = src_uv0s[lastIndex + 2];
            dst_uv0s[lastIndex + 3] = src_uv0s[lastIndex + 3];

            // UVS2
            src_uv2s = m_cachedMeshInfoVertexData[materialIndex].uvs2;
            dst_uv2s = m_TextMeshPro.textInfo.meshInfo[materialIndex].uvs2;
            dst_uv2s[lastIndex + 0] = src_uv2s[lastIndex + 0];
            dst_uv2s[lastIndex + 1] = src_uv2s[lastIndex + 1];
            dst_uv2s[lastIndex + 2] = src_uv2s[lastIndex + 2];
            dst_uv2s[lastIndex + 3] = src_uv2s[lastIndex + 3];

            // Need to update the appropriate 
            m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);
        }
    }
}


==================== VertexShakeA.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/VertexShakeA.cs) ====================
﻿using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{

    public class VertexShakeA : MonoBehaviour
    {

        public float AngleMultiplier = 1.0f;
        public float SpeedMultiplier = 1.0f;
        public float ScaleMultiplier = 1.0f;
        public float RotationMultiplier = 1.0f;

        private TMP_Text m_TextComponent;
        private bool hasTextChanged;


        void Awake()
        {
            m_TextComponent = GetComponent<TMP_Text>();
        }

        void OnEnable()
        {
            // Subscribe to event fired when text object has been regenerated.
            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
        }

        void OnDisable()
        {
            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
        }


        void Start()
        {
            StartCoroutine(AnimateVertexColors());
        }


        void ON_TEXT_CHANGED(Object obj)
        {
            if (obj = m_TextComponent)
                hasTextChanged = true;
        }

        /// <summary>
        /// Method to animate vertex colors of a TMP Text object.
        /// </summary>
        /// <returns></returns>
        IEnumerator AnimateVertexColors()
        {

            // We force an update of the text object since it would only be updated at the end of the frame. Ie. before this code is executed on the first frame.
            // Alternatively, we could yield and wait until the end of the frame when the text object will be generated.
            m_TextComponent.ForceMeshUpdate();

            TMP_TextInfo textInfo = m_TextComponent.textInfo;

            Matrix4x4 matrix;
            Vector3[][] copyOfVertices = new Vector3[0][];

            hasTextChanged = true;

            while (true)
            {
                // Allocate new vertices 
                if (hasTextChanged)
                {
                    if (copyOfVertices.Length < textInfo.meshInfo.Length)
                        copyOfVertices = new Vector3[textInfo.meshInfo.Length][];

                    for (int i = 0; i < textInfo.meshInfo.Length; i++)
                    {
                        int length = textInfo.meshInfo[i].vertices.Length;
                        copyOfVertices[i] = new Vector3[length];
                    }

                    hasTextChanged = false;
                }

                int characterCount = textInfo.characterCount;

                // If No Characters then just yield and wait for some text to be added
                if (characterCount == 0)
                {
                    yield return new WaitForSeconds(0.25f);
                    continue;
                }

                int lineCount = textInfo.lineCount;

                // Iterate through each line of the text.
                for (int i = 0; i < lineCount; i++)
                {

                    int first = textInfo.lineInfo[i].firstCharacterIndex;
                    int last = textInfo.lineInfo[i].lastCharacterIndex;

                    // Determine the center of each line
                    Vector3 centerOfLine = (textInfo.characterInfo[first].bottomLeft + textInfo.characterInfo[last].topRight) / 2;
                    Quaternion rotation = Quaternion.Euler(0, 0, Random.Range(-0.25f, 0.25f) * RotationMultiplier);

                    // Iterate through each character of the line.
                    for (int j = first; j <= last; j++)
                    {
                        // Skip characters that are not visible and thus have no geometry to manipulate.
                        if (!textInfo.characterInfo[j].isVisible)
                            continue;

                        // Get the index of the material used by the current character.
                        int materialIndex = textInfo.characterInfo[j].materialReferenceIndex;

                        // Get the index of the first vertex used by this text element.
                        int vertexIndex = textInfo.characterInfo[j].vertexIndex;

                        // Get the vertices of the mesh used by this text element (character or sprite).
                        Vector3[] sourceVertices = textInfo.meshInfo[materialIndex].vertices;

                        // Need to translate all 4 vertices of each quad to aligned with center of character.
                        // This is needed so the matrix TRS is applied at the origin for each character.
                        copyOfVertices[materialIndex][vertexIndex + 0] = sourceVertices[vertexIndex + 0] - centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 1] = sourceVertices[vertexIndex + 1] - centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 2] = sourceVertices[vertexIndex + 2] - centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 3] = sourceVertices[vertexIndex + 3] - centerOfLine;

                        // Determine the random scale change for each character.
                        float randomScale = Random.Range(0.995f - 0.001f * ScaleMultiplier, 1.005f + 0.001f * ScaleMultiplier);

                        // Setup the matrix rotation.
                        matrix = Matrix4x4.TRS(Vector3.one, rotation, Vector3.one * randomScale);

                        // Apply the matrix TRS to the individual characters relative to the center of the current line.
                        copyOfVertices[materialIndex][vertexIndex + 0] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 0]);
                        copyOfVertices[materialIndex][vertexIndex + 1] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 1]);
                        copyOfVertices[materialIndex][vertexIndex + 2] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 2]);
                        copyOfVertices[materialIndex][vertexIndex + 3] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 3]);

                        // Revert the translation change.
                        copyOfVertices[materialIndex][vertexIndex + 0] += centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 1] += centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 2] += centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 3] += centerOfLine;
                    }
                }

                // Push changes into meshes
                for (int i = 0; i < textInfo.meshInfo.Length; i++)
                {
                    textInfo.meshInfo[i].mesh.vertices = copyOfVertices[i];
                    m_TextComponent.UpdateGeometry(textInfo.meshInfo[i].mesh, i);
                }

                yield return new WaitForSeconds(0.1f);
            }
        }

    }
}

==================== VertexJitter.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/VertexJitter.cs) ====================
﻿using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{

    public class VertexJitter : MonoBehaviour
    {

        public float AngleMultiplier = 1.0f;
        public float SpeedMultiplier = 1.0f;
        public float CurveScale = 1.0f;

        private TMP_Text m_TextComponent;
        private bool hasTextChanged;

        /// <summary>
        /// Structure to hold pre-computed animation data.
        /// </summary>
        private struct VertexAnim
        {
            public float angleRange;
            public float angle;
            public float speed;
        }

        void Awake()
        {
            m_TextComponent = GetComponent<TMP_Text>();
        }

        void OnEnable()
        {
            // Subscribe to event fired when text object has been regenerated.
            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
        }

        void OnDisable()
        {
            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
        }


        void Start()
        {
            StartCoroutine(AnimateVertexColors());
        }


        void ON_TEXT_CHANGED(Object obj)
        {
            if (obj == m_TextComponent)
                hasTextChanged = true;
        }

        /// <summary>
        /// Method to animate vertex colors of a TMP Text object.
        /// </summary>
        /// <returns></returns>
        IEnumerator AnimateVertexColors()
        {

            // We force an update of the text object since it would only be updated at the end of the frame. Ie. before this code is executed on the first frame.
            // Alternatively, we could yield and wait until the end of the frame when the text object will be generated.
            m_TextComponent.ForceMeshUpdate();

            TMP_TextInfo textInfo = m_TextComponent.textInfo;

            Matrix4x4 matrix;

            int loopCount = 0;
            hasTextChanged = true;

            // Create an Array which contains pre-computed Angle Ranges and Speeds for a bunch of characters.
            VertexAnim[] vertexAnim = new VertexAnim[1024];
            for (int i = 0; i < 1024; i++)
            {
                vertexAnim[i].angleRange = Random.Range(10f, 25f);
                vertexAnim[i].speed = Random.Range(1f, 3f);
            }

            // Cache the vertex data of the text object as the Jitter FX is applied to the original position of the characters.
            TMP_MeshInfo[] cachedMeshInfo = textInfo.CopyMeshInfoVertexData();

            while (true)
            {
                // Get new copy of vertex data if the text has changed.
                if (hasTextChanged)
                {
                    // Update the copy of the vertex data for the text object.
                    cachedMeshInfo = textInfo.CopyMeshInfoVertexData();

                    hasTextChanged = false;
                }

                int characterCount = textInfo.characterCount;

                // If No Characters then just yield and wait for some text to be added
                if (characterCount == 0)
                {
                    yield return new WaitForSeconds(0.25f);
                    continue;
                }


                for (int i = 0; i < characterCount; i++)
                {
                    TMP_CharacterInfo charInfo = textInfo.characterInfo[i];

                    // Skip characters that are not visible and thus have no geometry to manipulate.
                    if (!charInfo.isVisible)
                        continue;

                    // Retrieve the pre-computed animation data for the given character.
                    VertexAnim vertAnim = vertexAnim[i];

                    // Get the index of the material used by the current character.
                    int materialIndex = textInfo.characterInfo[i].materialReferenceIndex;

                    // Get the index of the first vertex used by this text element.
                    int vertexIndex = textInfo.characterInfo[i].vertexIndex;

                    // Get the cached vertices of the mesh used by this text element (character or sprite).
                    Vector3[] sourceVertices = cachedMeshInfo[materialIndex].vertices;

                    // Determine the center point of each character at the baseline.
                    //Vector2 charMidBasline = new Vector2((sourceVertices[vertexIndex + 0].x + sourceVertices[vertexIndex + 2].x) / 2, charInfo.baseLine);
                    // Determine the center point of each character.
                    Vector2 charMidBasline = (sourceVertices[vertexIndex + 0] + sourceVertices[vertexIndex + 2]) / 2;

                    // Need to translate all 4 vertices of each quad to aligned with middle of character / baseline.
                    // This is needed so the matrix TRS is applied at the origin for each character.
                    Vector3 offset = charMidBasline;

                    Vector3[] destinationVertices = textInfo.meshInfo[materialIndex].vertices;

                    destinationVertices[vertexIndex + 0] = sourceVertices[vertexIndex + 0] - offset;
                    destinationVertices[vertexIndex + 1] = sourceVertices[vertexIndex + 1] - offset;
                    destinationVertices[vertexIndex + 2] = sourceVertices[vertexIndex + 2] - offset;
                    destinationVertices[vertexIndex + 3] = sourceVertices[vertexIndex + 3] - offset;

                    vertAnim.angle = Mathf.SmoothStep(-vertAnim.angleRange, vertAnim.angleRange, Mathf.PingPong(loopCount / 25f * vertAnim.speed, 1f));
                    Vector3 jitterOffset = new Vector3(Random.Range(-.25f, .25f), Random.Range(-.25f, .25f), 0);

                    matrix = Matrix4x4.TRS(jitterOffset * CurveScale, Quaternion.Euler(0, 0, Random.Range(-5f, 5f) * AngleMultiplier), Vector3.one);

                    destinationVertices[vertexIndex + 0] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 0]);
                    destinationVertices[vertexIndex + 1] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 1]);
                    destinationVertices[vertexIndex + 2] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 2]);
                    destinationVertices[vertexIndex + 3] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 3]);

                    destinationVertices[vertexIndex + 0] += offset;
                    destinationVertices[vertexIndex + 1] += offset;
                    destinationVertices[vertexIndex + 2] += offset;
                    destinationVertices[vertexIndex + 3] += offset;

                    vertexAnim[i] = vertAnim;
                }

                // Push changes into meshes
                for (int i = 0; i < textInfo.meshInfo.Length; i++)
                {
                    textInfo.meshInfo[i].mesh.vertices = textInfo.meshInfo[i].vertices;
                    m_TextComponent.UpdateGeometry(textInfo.meshInfo[i].mesh, i);
                }

                loopCount += 1;

                yield return new WaitForSeconds(0.1f);
            }
        }

    }
}

==================== TMP_PhoneNumberValidator.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_PhoneNumberValidator.cs) ====================
﻿using UnityEngine;
using System.Collections;
using System;

namespace TMPro
{
    /// <summary>
    /// Example of a Custom Character Input Validator to only allow phone number in the (800) 555-1212 format.
    /// </summary>
    [Serializable]
    //[CreateAssetMenu(fileName = "InputValidator - Phone Numbers.asset", menuName = "TextMeshPro/Input Validators/Phone Numbers")]
    public class TMP_PhoneNumberValidator : TMP_InputValidator
    {
        // Custom text input validation function
        public override char Validate(ref string text, ref int pos, char ch)
        {
            Debug.Log("Trying to validate...");
            
            // Return unless the character is a valid digit
            if (ch < '0' && ch > '9') return (char)0;

            int length = text.Length;

            // Enforce Phone Number format for every character input.
            for (int i = 0; i < length + 1; i++)
            {
                switch (i)
                {
                    case 0:
                        if (i == length)
                            text = "(" + ch;
                        pos = 2;
                        break;
                    case 1:
                        if (i == length)
                            text += ch;
                        pos = 2;
                        break;
                    case 2:
                        if (i == length)
                            text += ch;
                        pos = 3;
                        break;
                    case 3:
                        if (i == length)
                            text += ch + ") ";
                        pos = 6;
                        break;
                    case 4:
                        if (i == length)
                            text += ") " + ch;
                        pos = 7;
                        break;
                    case 5:
                        if (i == length)
                            text += " " + ch;
                        pos = 7;
                        break;
                    case 6:
                        if (i == length)
                            text += ch;
                        pos = 7;
                        break;
                    case 7:
                        if (i == length)
                            text += ch;
                        pos = 8;
                        break;
                    case 8:
                        if (i == length)
                            text += ch + "-";
                        pos = 10;
                        break;
                    case 9:
                        if (i == length)
                            text += "-" + ch;
                        pos = 11;
                        break;
                    case 10:
                        if (i == length)
                            text += ch;
                        pos = 11;
                        break;
                    case 11:
                        if (i == length)
                            text += ch;
                        pos = 12;
                        break;
                    case 12:
                        if (i == length)
                            text += ch;
                        pos = 13;
                        break;
                    case 13:
                        if (i == length)
                            text += ch;
                        pos = 14;
                        break;
                }
            }

            return ch;
        }
    }
}


==================== TMPro_InstructionOverlay.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/TMPro_InstructionOverlay.cs) ====================
﻿using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class TMPro_InstructionOverlay : MonoBehaviour
    {

        public enum FpsCounterAnchorPositions { TopLeft, BottomLeft, TopRight, BottomRight };

        public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.BottomLeft;

        private const string instructions = "Camera Control - <#ffff00>Shift + RMB\n</color>Zoom - <#ffff00>Mouse wheel.";

        private TextMeshPro m_TextMeshPro;
        private TextContainer m_textContainer;
        private Transform m_frameCounter_transform;
        private Camera m_camera;

        //private FpsCounterAnchorPositions last_AnchorPosition;

        void Awake()
        {
            if (!enabled)
                return;

            m_camera = Camera.main;

            GameObject frameCounter = new GameObject("Frame Counter");
            m_frameCounter_transform = frameCounter.transform;
            m_frameCounter_transform.parent = m_camera.transform;
            m_frameCounter_transform.localRotation = Quaternion.identity;


            m_TextMeshPro = frameCounter.AddComponent<TextMeshPro>();
            m_TextMeshPro.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/LiberationSans SDF");
            m_TextMeshPro.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Overlay");

            m_TextMeshPro.fontSize = 30;

            m_TextMeshPro.isOverlay = true;
            m_textContainer = frameCounter.GetComponent<TextContainer>();

            Set_FrameCounter_Position(AnchorPosition);
            //last_AnchorPosition = AnchorPosition;

            m_TextMeshPro.text = instructions;

        }




        void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position)
        {

            switch (anchor_position)
            {
                case FpsCounterAnchorPositions.TopLeft:
                    //m_TextMeshPro.anchor = AnchorPositions.TopLeft;
                    m_textContainer.anchorPosition = TextContainerAnchors.TopLeft;
                    m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0, 1, 100.0f));
                    break;
                case FpsCounterAnchorPositions.BottomLeft:
                    //m_TextMeshPro.anchor = AnchorPositions.BottomLeft;
                    m_textContainer.anchorPosition = TextContainerAnchors.BottomLeft;
                    m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0, 0, 100.0f));
                    break;
                case FpsCounterAnchorPositions.TopRight:
                    //m_TextMeshPro.anchor = AnchorPositions.TopRight;
                    m_textContainer.anchorPosition = TextContainerAnchors.TopRight;
                    m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1, 1, 100.0f));
                    break;
                case FpsCounterAnchorPositions.BottomRight:
                    //m_TextMeshPro.anchor = AnchorPositions.BottomRight;
                    m_textContainer.anchorPosition = TextContainerAnchors.BottomRight;
                    m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1, 0, 100.0f));
                    break;
            }
        }
    }
}


==================== ChatController.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/ChatController.cs) ====================
﻿using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class ChatController : MonoBehaviour {


    public TMP_InputField ChatInputField;

    public TMP_Text ChatDisplayOutput;

    public Scrollbar ChatScrollbar;

    void OnEnable()
    {
        ChatInputField.onSubmit.AddListener(AddToChatOutput);
    }

    void OnDisable()
    {
        ChatInputField.onSubmit.RemoveListener(AddToChatOutput);
    }


    void AddToChatOutput(string newText)
    {
        // Clear Input Field
        ChatInputField.text = string.Empty;

        var timeNow = System.DateTime.Now;

        string formattedInput = "[<#FFFF80>" + timeNow.Hour.ToString("d2") + ":" + timeNow.Minute.ToString("d2") + ":" + timeNow.Second.ToString("d2") + "</color>] " + newText;

        if (ChatDisplayOutput != null)
        {
            // No special formatting for first entry
            // Add line feed before each subsequent entries
            if (ChatDisplayOutput.text == string.Empty)
                ChatDisplayOutput.text = formattedInput;
            else
                ChatDisplayOutput.text += "\n" + formattedInput;
        }

        // Keep Chat input field active
        ChatInputField.ActivateInputField();

        // Set the scrollbar to the bottom when next text is submitted.
        ChatScrollbar.value = 0;
    }

}


==================== TextConsoleSimulator.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/TextConsoleSimulator.cs) ====================
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    public class TextConsoleSimulator : MonoBehaviour
    {
        private TMP_Text m_TextComponent;
        private bool hasTextChanged;

        void Awake()
        {
            m_TextComponent = gameObject.GetComponent<TMP_Text>();
        }


        void Start()
        {
            StartCoroutine(RevealCharacters(m_TextComponent));
            //StartCoroutine(RevealWords(m_TextComponent));
        }


        void OnEnable()
        {
            // Subscribe to event fired when text object has been regenerated.
            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
        }

        void OnDisable()
        {
            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
        }


        // Event received when the text object has changed.
        void ON_TEXT_CHANGED(Object obj)
        {
            hasTextChanged = true;
        }


        /// <summary>
        /// Method revealing the text one character at a time.
        /// </summary>
        /// <returns></returns>
        IEnumerator RevealCharacters(TMP_Text textComponent)
        {
            textComponent.ForceMeshUpdate();

            TMP_TextInfo textInfo = textComponent.textInfo;

            int totalVisibleCharacters = textInfo.characterCount; // Get # of Visible Character in text object
            int visibleCount = 0;

            while (true)
            {
                if (hasTextChanged)
                {
                    totalVisibleCharacters = textInfo.characterCount; // Update visible character count.
                    hasTextChanged = false; 
                }

                if (visibleCount > totalVisibleCharacters)
                {
                    yield return new WaitForSeconds(1.0f);
                    visibleCount = 0;
                }

                textComponent.maxVisibleCharacters = visibleCount; // How many characters should TextMeshPro display?

                visibleCount += 1;

                yield return null;
            }
        }


        /// <summary>
        /// Method revealing the text one word at a time.
        /// </summary>
        /// <returns></returns>
        IEnumerator RevealWords(TMP_Text textComponent)
        {
            textComponent.ForceMeshUpdate();

            int totalWordCount = textComponent.textInfo.wordCount;
            int totalVisibleCharacters = textComponent.textInfo.characterCount; // Get # of Visible Character in text object
            int counter = 0;
            int currentWord = 0;
            int visibleCount = 0;

            while (true)
            {
                currentWord = counter % (totalWordCount + 1);

                // Get last character index for the current word.
                if (currentWord == 0) // Display no words.
                    visibleCount = 0;
                else if (currentWord < totalWordCount) // Display all other words with the exception of the last one.
                    visibleCount = textComponent.textInfo.wordInfo[currentWord - 1].lastCharacterIndex + 1;
                else if (currentWord == totalWordCount) // Display last word and all remaining characters.
                    visibleCount = totalVisibleCharacters;

                textComponent.maxVisibleCharacters = visibleCount; // How many characters should TextMeshPro display?

                // Once the last character has been revealed, wait 1.0 second and start over.
                if (visibleCount >= totalVisibleCharacters)
                {
                    yield return new WaitForSeconds(1.0f);
                }

                counter += 1;

                yield return new WaitForSeconds(0.1f);
            }
        }

    }
}

==================== TMP_FrameRateCounter.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_FrameRateCounter.cs) ====================
﻿using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class TMP_FrameRateCounter : MonoBehaviour
    {
        public float UpdateInterval = 5.0f;
        private float m_LastInterval = 0;
        private int m_Frames = 0;

        public enum FpsCounterAnchorPositions { TopLeft, BottomLeft, TopRight, BottomRight };

        public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.TopRight;

        private string htmlColorTag;
        private const string fpsLabel = "{0:2}</color> <#8080ff>FPS \n<#FF8000>{1:2} <#8080ff>MS";

        private TextMeshPro m_TextMeshPro;
        private Transform m_frameCounter_transform;
        private Camera m_camera;

        private FpsCounterAnchorPositions last_AnchorPosition;

        void Awake()
        {
            if (!enabled)
                return;

            m_camera = Camera.main;
            Application.targetFrameRate = 9999;

            GameObject frameCounter = new GameObject("Frame Counter");

            m_TextMeshPro = frameCounter.AddComponent<TextMeshPro>();
            m_TextMeshPro.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/LiberationSans SDF");
            m_TextMeshPro.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Overlay");


            m_frameCounter_transform = frameCounter.transform;
            m_frameCounter_transform.SetParent(m_camera.transform);
            m_frameCounter_transform.localRotation = Quaternion.identity;

            m_TextMeshPro.enableWordWrapping = false;
            m_TextMeshPro.fontSize = 24;
            //m_TextMeshPro.FontColor = new Color32(255, 255, 255, 128);
            //m_TextMeshPro.edgeWidth = .15f;
            //m_TextMeshPro.isOverlay = true;

            //m_TextMeshPro.FaceColor = new Color32(255, 128, 0, 0);
            //m_TextMeshPro.EdgeColor = new Color32(0, 255, 0, 255);
            //m_TextMeshPro.FontMaterial.renderQueue = 4000;

            //m_TextMeshPro.CreateSoftShadowClone(new Vector2(1f, -1f));

            Set_FrameCounter_Position(AnchorPosition);
            last_AnchorPosition = AnchorPosition;


        }

        void Start()
        {
            m_LastInterval = Time.realtimeSinceStartup;
            m_Frames = 0;
        }

        void Update()
        {
            if (AnchorPosition != last_AnchorPosition)
                Set_FrameCounter_Position(AnchorPosition);

            last_AnchorPosition = AnchorPosition;

            m_Frames += 1;
            float timeNow = Time.realtimeSinceStartup;

            if (timeNow > m_LastInterval + UpdateInterval)
            {
                // display two fractional digits (f2 format)
                float fps = m_Frames / (timeNow - m_LastInterval);
                float ms = 1000.0f / Mathf.Max(fps, 0.00001f);

                if (fps < 30)
                    htmlColorTag = "<color=yellow>";
                else if (fps < 10)
                    htmlColorTag = "<color=red>";
                else
                    htmlColorTag = "<color=green>";

                //string format = System.String.Format(htmlColorTag + "{0:F2} </color>FPS \n{1:F2} <#8080ff>MS",fps, ms);
                //m_TextMeshPro.text = format;

                m_TextMeshPro.SetText(htmlColorTag + fpsLabel, fps, ms);

                m_Frames = 0;
                m_LastInterval = timeNow;
            }
        }


        void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position)
        {
            //Debug.Log("Changing frame counter anchor position.");
            m_TextMeshPro.margin = new Vector4(1f, 1f, 1f, 1f);

            switch (anchor_position)
            {
                case FpsCounterAnchorPositions.TopLeft:
                    m_TextMeshPro.alignment = TextAlignmentOptions.TopLeft;
                    m_TextMeshPro.rectTransform.pivot = new Vector2(0, 1);
                    m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0, 1, 100.0f));
                    break;
                case FpsCounterAnchorPositions.BottomLeft:
                    m_TextMeshPro.alignment = TextAlignmentOptions.BottomLeft;
                    m_TextMeshPro.rectTransform.pivot = new Vector2(0, 0);
                    m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0, 0, 100.0f));
                    break;
                case FpsCounterAnchorPositions.TopRight:
                    m_TextMeshPro.alignment = TextAlignmentOptions.TopRight;
                    m_TextMeshPro.rectTransform.pivot = new Vector2(1, 1);
                    m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1, 1, 100.0f));
                    break;
                case FpsCounterAnchorPositions.BottomRight:
                    m_TextMeshPro.alignment = TextAlignmentOptions.BottomRight;
                    m_TextMeshPro.rectTransform.pivot = new Vector2(1, 0);
                    m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1, 0, 100.0f));
                    break;
            }
        }
    }
}


==================== VertexColorCycler.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/VertexColorCycler.cs) ====================
﻿using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{

    public class VertexColorCycler : MonoBehaviour
    {

        private TMP_Text m_TextComponent;

        void Awake()
        {
            m_TextComponent = GetComponent<TMP_Text>();
        }


        void Start()
        {
            StartCoroutine(AnimateVertexColors());
        }


        /// <summary>
        /// Method to animate vertex colors of a TMP Text object.
        /// </summary>
        /// <returns></returns>
        IEnumerator AnimateVertexColors()
        {
            // Force the text object to update right away so we can have geometry to modify right from the start.
            m_TextComponent.ForceMeshUpdate();

            TMP_TextInfo textInfo = m_TextComponent.textInfo;
            int currentCharacter = 0;

            Color32[] newVertexColors;
            Color32 c0 = m_TextComponent.color;

            while (true)
            {
                int characterCount = textInfo.characterCount;

                // If No Characters then just yield and wait for some text to be added
                if (characterCount == 0)
                {
                    yield return new WaitForSeconds(0.25f);
                    continue;
                }

                // Get the index of the material used by the current character.
                int materialIndex = textInfo.characterInfo[currentCharacter].materialReferenceIndex;

                // Get the vertex colors of the mesh used by this text element (character or sprite).
                newVertexColors = textInfo.meshInfo[materialIndex].colors32;

                // Get the index of the first vertex used by this text element.
                int vertexIndex = textInfo.characterInfo[currentCharacter].vertexIndex;

                // Only change the vertex color if the text element is visible.
                if (textInfo.characterInfo[currentCharacter].isVisible)
                {
                    c0 = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255);

                    newVertexColors[vertexIndex + 0] = c0;
                    newVertexColors[vertexIndex + 1] = c0;
                    newVertexColors[vertexIndex + 2] = c0;
                    newVertexColors[vertexIndex + 3] = c0;

                    // New function which pushes (all) updated vertex data to the appropriate meshes when using either the Mesh Renderer or CanvasRenderer.
                    m_TextComponent.UpdateVertexData(TMP_VertexDataUpdateFlags.Colors32);

                    // This last process could be done to only update the vertex data that has changed as opposed to all of the vertex data but it would require extra steps and knowing what type of renderer is used.
                    // These extra steps would be a performance optimization but it is unlikely that such optimization will be necessary.
                }

                currentCharacter = (currentCharacter + 1) % characterCount;

                yield return new WaitForSeconds(0.05f);
            }
        }

    }
}


==================== Benchmark02.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/Benchmark02.cs) ====================
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{

    public class Benchmark02 : MonoBehaviour
    {

        public int SpawnType = 0;
        public int NumberOfNPC = 12;

        public bool IsTextObjectScaleStatic;
        private TextMeshProFloatingText floatingText_Script;


        void Start()
        {

            for (int i = 0; i < NumberOfNPC; i++)
            {


                if (SpawnType == 0)
                {
                    // TextMesh Pro Implementation
                    GameObject go = new GameObject();
                    go.transform.position = new Vector3(Random.Range(-95f, 95f), 0.25f, Random.Range(-95f, 95f));

                    TextMeshPro textMeshPro = go.AddComponent<TextMeshPro>();

                    textMeshPro.autoSizeTextContainer = true;
                    textMeshPro.rectTransform.pivot = new Vector2(0.5f, 0);

                    textMeshPro.alignment = TextAlignmentOptions.Bottom;
                    textMeshPro.fontSize = 96;
                    textMeshPro.enableKerning = false;

                    textMeshPro.color = new Color32(255, 255, 0, 255);
                    textMeshPro.text = "!";
                    textMeshPro.isTextObjectScaleStatic = IsTextObjectScaleStatic;

                    // Spawn Floating Text
                    floatingText_Script = go.AddComponent<TextMeshProFloatingText>();
                    floatingText_Script.SpawnType = 0;
                    floatingText_Script.IsTextObjectScaleStatic = IsTextObjectScaleStatic;
                }
                else if (SpawnType == 1)
                {
                    // TextMesh Implementation
                    GameObject go = new GameObject();
                    go.transform.position = new Vector3(Random.Range(-95f, 95f), 0.25f, Random.Range(-95f, 95f));

                    TextMesh textMesh = go.AddComponent<TextMesh>();
                    textMesh.font = Resources.Load<Font>("Fonts/ARIAL");
                    textMesh.GetComponent<Renderer>().sharedMaterial = textMesh.font.material;

                    textMesh.anchor = TextAnchor.LowerCenter;
                    textMesh.fontSize = 96;

                    textMesh.color = new Color32(255, 255, 0, 255);
                    textMesh.text = "!";

                    // Spawn Floating Text
                    floatingText_Script = go.AddComponent<TextMeshProFloatingText>();
                    floatingText_Script.SpawnType = 1;
                }
                else if (SpawnType == 2)
                {
                    // Canvas WorldSpace Camera
                    GameObject go = new GameObject();
                    Canvas canvas = go.AddComponent<Canvas>();
                    canvas.worldCamera = Camera.main;

                    go.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f);
                    go.transform.position = new Vector3(Random.Range(-95f, 95f), 5f, Random.Range(-95f, 95f));

                    TextMeshProUGUI textObject = new GameObject().AddComponent<TextMeshProUGUI>();
                    textObject.rectTransform.SetParent(go.transform, false);

                    textObject.color = new Color32(255, 255, 0, 255);
                    textObject.alignment = TextAlignmentOptions.Bottom;
                    textObject.fontSize = 96;
                    textObject.text = "!";

                    // Spawn Floating Text
                    floatingText_Script = go.AddComponent<TextMeshProFloatingText>();
                    floatingText_Script.SpawnType = 0;
                }



            }
        }
    }
}


==================== TMP_TextEventCheck.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_TextEventCheck.cs) ====================
﻿using UnityEngine;


namespace TMPro.Examples
{
    public class TMP_TextEventCheck : MonoBehaviour
    {

        public TMP_TextEventHandler TextEventHandler;

        private TMP_Text m_TextComponent;

        void OnEnable()
        {
            if (TextEventHandler != null)
            {
                // Get a reference to the text component
                m_TextComponent = TextEventHandler.GetComponent<TMP_Text>();
                
                TextEventHandler.onCharacterSelection.AddListener(OnCharacterSelection);
                TextEventHandler.onSpriteSelection.AddListener(OnSpriteSelection);
                TextEventHandler.onWordSelection.AddListener(OnWordSelection);
                TextEventHandler.onLineSelection.AddListener(OnLineSelection);
                TextEventHandler.onLinkSelection.AddListener(OnLinkSelection);
            }
        }


        void OnDisable()
        {
            if (TextEventHandler != null)
            {
                TextEventHandler.onCharacterSelection.RemoveListener(OnCharacterSelection);
                TextEventHandler.onSpriteSelection.RemoveListener(OnSpriteSelection);
                TextEventHandler.onWordSelection.RemoveListener(OnWordSelection);
                TextEventHandler.onLineSelection.RemoveListener(OnLineSelection);
                TextEventHandler.onLinkSelection.RemoveListener(OnLinkSelection);
            }
        }


        void OnCharacterSelection(char c, int index)
        {
            Debug.Log("Character [" + c + "] at Index: " + index + " has been selected.");
        }

        void OnSpriteSelection(char c, int index)
        {
            Debug.Log("Sprite [" + c + "] at Index: " + index + " has been selected.");
        }

        void OnWordSelection(string word, int firstCharacterIndex, int length)
        {
            Debug.Log("Word [" + word + "] with first character index of " + firstCharacterIndex + " and length of " + length + " has been selected.");
        }

        void OnLineSelection(string lineText, int firstCharacterIndex, int length)
        {
            Debug.Log("Line [" + lineText + "] with first character index of " + firstCharacterIndex + " and length of " + length + " has been selected.");
        }

        void OnLinkSelection(string linkID, string linkText, int linkIndex)
        {
            if (m_TextComponent != null)
            {
                TMP_LinkInfo linkInfo = m_TextComponent.textInfo.linkInfo[linkIndex];
            }
            
            Debug.Log("Link Index: " + linkIndex + " with ID [" + linkID + "] and Text \"" + linkText + "\" has been selected.");
        }

    }
}


==================== SimpleScript.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/SimpleScript.cs) ====================
﻿using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class SimpleScript : MonoBehaviour
    {

        private TextMeshPro m_textMeshPro;
        //private TMP_FontAsset m_FontAsset;

        private const string label = "The <#0050FF>count is: </color>{0:2}";
        private float m_frame;


        void Start()
        {
            // Add new TextMesh Pro Component
            m_textMeshPro = gameObject.AddComponent<TextMeshPro>();

            m_textMeshPro.autoSizeTextContainer = true;

            // Load the Font Asset to be used.
            //m_FontAsset = Resources.Load("Fonts & Materials/LiberationSans SDF", typeof(TMP_FontAsset)) as TMP_FontAsset;
            //m_textMeshPro.font = m_FontAsset;

            // Assign Material to TextMesh Pro Component
            //m_textMeshPro.fontSharedMaterial = Resources.Load("Fonts & Materials/LiberationSans SDF - Bevel", typeof(Material)) as Material;
            //m_textMeshPro.fontSharedMaterial.EnableKeyword("BEVEL_ON");
            
            // Set various font settings.
            m_textMeshPro.fontSize = 48;

            m_textMeshPro.alignment = TextAlignmentOptions.Center;
            
            //m_textMeshPro.anchorDampening = true; // Has been deprecated but under consideration for re-implementation.
            //m_textMeshPro.enableAutoSizing = true;

            //m_textMeshPro.characterSpacing = 0.2f;
            //m_textMeshPro.wordSpacing = 0.1f;

            //m_textMeshPro.enableCulling = true;
            m_textMeshPro.enableWordWrapping = false;

            //textMeshPro.fontColor = new Color32(255, 255, 255, 255);
        }


        void Update()
        {
            m_textMeshPro.SetText(label, m_frame % 1000);
            m_frame += 1 * Time.deltaTime;
        }

    }
}


==================== Benchmark01_UGUI.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/Benchmark01_UGUI.cs) ====================
using UnityEngine;
using System.Collections;
using UnityEngine.UI;


namespace TMPro.Examples
{
    
    public class Benchmark01_UGUI : MonoBehaviour
    {

        public int BenchmarkType = 0;

        public Canvas canvas;
        public TMP_FontAsset TMProFont;
        public Font TextMeshFont;

        private TextMeshProUGUI m_textMeshPro;
        //private TextContainer m_textContainer;
        private Text m_textMesh;

        private const string label01 = "The <#0050FF>count is: </color>";
        private const string label02 = "The <color=#0050FF>count is: </color>";

        //private const string label01 = "TextMesh <#0050FF>Pro!</color>  The count is: {0}";
        //private const string label02 = "Text Mesh<color=#0050FF>        The count is: </color>";

        //private string m_string;
        //private int m_frame;

        private Material m_material01;
        private Material m_material02;



        IEnumerator Start()
        {



            if (BenchmarkType == 0) // TextMesh Pro Component
            {
                m_textMeshPro = gameObject.AddComponent<TextMeshProUGUI>();
                //m_textContainer = GetComponent<TextContainer>();


                //m_textMeshPro.anchorDampening = true;

                if (TMProFont != null)
                    m_textMeshPro.font = TMProFont;

                //m_textMeshPro.font = Resources.Load("Fonts & Materials/Anton SDF", typeof(TextMeshProFont)) as TextMeshProFont; // Make sure the Anton SDF exists before calling this...           
                //m_textMeshPro.fontSharedMaterial = Resources.Load("Fonts & Materials/Anton SDF", typeof(Material)) as Material; // Same as above make sure this material exists.

                m_textMeshPro.fontSize = 48;
                m_textMeshPro.alignment = TextAlignmentOptions.Center;
                //m_textMeshPro.anchor = AnchorPositions.Center;
                m_textMeshPro.extraPadding = true;
                //m_textMeshPro.outlineWidth = 0.25f;
                //m_textMeshPro.fontSharedMaterial.SetFloat("_OutlineWidth", 0.2f);
                //m_textMeshPro.fontSharedMaterial.EnableKeyword("UNDERLAY_ON");
                //m_textMeshPro.lineJustification = LineJustificationTypes.Center;
                //m_textMeshPro.enableWordWrapping = true;    
                //m_textMeshPro.lineLength = 60;          
                //m_textMeshPro.characterSpacing = 0.2f;
                //m_textMeshPro.fontColor = new Color32(255, 255, 255, 255);

                m_material01 = m_textMeshPro.font.material;
                m_material02 = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - BEVEL"); // Make sure the LiberationSans SDF exists before calling this...  


            }
            else if (BenchmarkType == 1) // TextMesh
            {
                m_textMesh = gameObject.AddComponent<Text>();

                if (TextMeshFont != null)
                {
                    m_textMesh.font = TextMeshFont;
                    //m_textMesh.renderer.sharedMaterial = m_textMesh.font.material;
                }
                else
                {
                    //m_textMesh.font = Resources.Load("Fonts/ARIAL", typeof(Font)) as Font;
                    //m_textMesh.renderer.sharedMaterial = m_textMesh.font.material;
                }

                m_textMesh.fontSize = 48;
                m_textMesh.alignment = TextAnchor.MiddleCenter;

                //m_textMesh.color = new Color32(255, 255, 0, 255);    
            }



            for (int i = 0; i <= 1000000; i++)
            {
                if (BenchmarkType == 0)
                {
                    m_textMeshPro.text = label01 + (i % 1000);
                    if (i % 1000 == 999)
                        m_textMeshPro.fontSharedMaterial = m_textMeshPro.fontSharedMaterial == m_material01 ? m_textMeshPro.fontSharedMaterial = m_material02 : m_textMeshPro.fontSharedMaterial = m_material01;



                }
                else if (BenchmarkType == 1)
                    m_textMesh.text = label02 + (i % 1000).ToString();

                yield return null;
            }


            yield return null;
        }


        /*
        void Update()
        {
            if (BenchmarkType == 0)
            {
                m_textMeshPro.text = (m_frame % 1000).ToString();            
            }
            else if (BenchmarkType == 1)
            {
                m_textMesh.text = (m_frame % 1000).ToString();
            }

            m_frame += 1;
        }
        */
    }

}


==================== SkewTextExample.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/SkewTextExample.cs) ====================
﻿using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{

    public class SkewTextExample : MonoBehaviour
    {

        private TMP_Text m_TextComponent;

        public AnimationCurve VertexCurve = new AnimationCurve(new Keyframe(0, 0), new Keyframe(0.25f, 2.0f), new Keyframe(0.5f, 0), new Keyframe(0.75f, 2.0f), new Keyframe(1, 0f));
        //public float AngleMultiplier = 1.0f;
        //public float SpeedMultiplier = 1.0f;
        public float CurveScale = 1.0f;
        public float ShearAmount = 1.0f;

        void Awake()
        {
            m_TextComponent = gameObject.GetComponent<TMP_Text>();
        }


        void Start()
        {
            StartCoroutine(WarpText());
        }


        private AnimationCurve CopyAnimationCurve(AnimationCurve curve)
        {
            AnimationCurve newCurve = new AnimationCurve();

            newCurve.keys = curve.keys;

            return newCurve;
        }


        /// <summary>
        ///  Method to curve text along a Unity animation curve.
        /// </summary>
        /// <param name="textComponent"></param>
        /// <returns></returns>
        IEnumerator WarpText()
        {
            VertexCurve.preWrapMode = WrapMode.Clamp;
            VertexCurve.postWrapMode = WrapMode.Clamp;

            //Mesh mesh = m_TextComponent.textInfo.meshInfo[0].mesh;

            Vector3[] vertices;
            Matrix4x4 matrix;

            m_TextComponent.havePropertiesChanged = true; // Need to force the TextMeshPro Object to be updated.
            CurveScale *= 10;
            float old_CurveScale = CurveScale;
            float old_ShearValue = ShearAmount;
            AnimationCurve old_curve = CopyAnimationCurve(VertexCurve);

            while (true)
            {
                if (!m_TextComponent.havePropertiesChanged && old_CurveScale == CurveScale && old_curve.keys[1].value == VertexCurve.keys[1].value && old_ShearValue == ShearAmount)
                {
                    yield return null;
                    continue;
                }

                old_CurveScale = CurveScale;
                old_curve = CopyAnimationCurve(VertexCurve);
                old_ShearValue = ShearAmount;

                m_TextComponent.ForceMeshUpdate(); // Generate the mesh and populate the textInfo with data we can use and manipulate.

                TMP_TextInfo textInfo = m_TextComponent.textInfo;
                int characterCount = textInfo.characterCount;


                if (characterCount == 0) continue;

                //vertices = textInfo.meshInfo[0].vertices;
                //int lastVertexIndex = textInfo.characterInfo[characterCount - 1].vertexIndex;

                float boundsMinX = m_TextComponent.bounds.min.x;  //textInfo.meshInfo[0].mesh.bounds.min.x;
                float boundsMaxX = m_TextComponent.bounds.max.x;  //textInfo.meshInfo[0].mesh.bounds.max.x;



                for (int i = 0; i < characterCount; i++)
                {
                    if (!textInfo.characterInfo[i].isVisible)
                        continue;

                    int vertexIndex = textInfo.characterInfo[i].vertexIndex;

                    // Get the index of the mesh used by this character.
                    int materialIndex = textInfo.characterInfo[i].materialReferenceIndex;

                    vertices = textInfo.meshInfo[materialIndex].vertices;

                    // Compute the baseline mid point for each character
                    Vector3 offsetToMidBaseline = new Vector2((vertices[vertexIndex + 0].x + vertices[vertexIndex + 2].x) / 2, textInfo.characterInfo[i].baseLine);
                    //float offsetY = VertexCurve.Evaluate((float)i / characterCount + loopCount / 50f); // Random.Range(-0.25f, 0.25f);

                    // Apply offset to adjust our pivot point.
                    vertices[vertexIndex + 0] += -offsetToMidBaseline;
                    vertices[vertexIndex + 1] += -offsetToMidBaseline;
                    vertices[vertexIndex + 2] += -offsetToMidBaseline;
                    vertices[vertexIndex + 3] += -offsetToMidBaseline;

                    // Apply the Shearing FX
                    float shear_value = ShearAmount * 0.01f;
                    Vector3 topShear = new Vector3(shear_value * (textInfo.characterInfo[i].topRight.y - textInfo.characterInfo[i].baseLine), 0, 0);
                    Vector3 bottomShear = new Vector3(shear_value * (textInfo.characterInfo[i].baseLine - textInfo.characterInfo[i].bottomRight.y), 0, 0);

                    vertices[vertexIndex + 0] += -bottomShear;
                    vertices[vertexIndex + 1] += topShear;
                    vertices[vertexIndex + 2] += topShear;
                    vertices[vertexIndex + 3] += -bottomShear;


                    // Compute the angle of rotation for each character based on the animation curve
                    float x0 = (offsetToMidBaseline.x - boundsMinX) / (boundsMaxX - boundsMinX); // Character's position relative to the bounds of the mesh.
                    float x1 = x0 + 0.0001f;
                    float y0 = VertexCurve.Evaluate(x0) * CurveScale;
                    float y1 = VertexCurve.Evaluate(x1) * CurveScale;

                    Vector3 horizontal = new Vector3(1, 0, 0);
                    //Vector3 normal = new Vector3(-(y1 - y0), (x1 * (boundsMaxX - boundsMinX) + boundsMinX) - offsetToMidBaseline.x, 0);
                    Vector3 tangent = new Vector3(x1 * (boundsMaxX - boundsMinX) + boundsMinX, y1) - new Vector3(offsetToMidBaseline.x, y0);

                    float dot = Mathf.Acos(Vector3.Dot(horizontal, tangent.normalized)) * 57.2957795f;
                    Vector3 cross = Vector3.Cross(horizontal, tangent);
                    float angle = cross.z > 0 ? dot : 360 - dot;

                    matrix = Matrix4x4.TRS(new Vector3(0, y0, 0), Quaternion.Euler(0, 0, angle), Vector3.one);

                    vertices[vertexIndex + 0] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 0]);
                    vertices[vertexIndex + 1] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 1]);
                    vertices[vertexIndex + 2] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 2]);
                    vertices[vertexIndex + 3] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 3]);

                    vertices[vertexIndex + 0] += offsetToMidBaseline;
                    vertices[vertexIndex + 1] += offsetToMidBaseline;
                    vertices[vertexIndex + 2] += offsetToMidBaseline;
                    vertices[vertexIndex + 3] += offsetToMidBaseline;
                }


                // Upload the mesh with the revised information
                m_TextComponent.UpdateVertexData();

                yield return null; // new WaitForSeconds(0.025f);
            }
        }
    }
}


==================== TMP_DigitValidator.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_DigitValidator.cs) ====================
﻿using UnityEngine;
using System;


namespace TMPro
{
    /// <summary>
    /// EXample of a Custom Character Input Validator to only allow digits from 0 to 9.
    /// </summary>
    [Serializable]
    //[CreateAssetMenu(fileName = "InputValidator - Digits.asset", menuName = "TextMeshPro/Input Validators/Digits", order = 100)]
    public class TMP_DigitValidator : TMP_InputValidator
    {
        // Custom text input validation function
        public override char Validate(ref string text, ref int pos, char ch)
        {
            if (ch >= '0' && ch <= '9')
            {
                text += ch;
                pos += 1;
                return ch;
            }

            return (char)0;
        }
    }
}


==================== TMP_UiFrameRateCounter.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_UiFrameRateCounter.cs) ====================
﻿using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class TMP_UiFrameRateCounter : MonoBehaviour
    {
        public float UpdateInterval = 5.0f;
        private float m_LastInterval = 0;
        private int m_Frames = 0;

        public enum FpsCounterAnchorPositions { TopLeft, BottomLeft, TopRight, BottomRight };

        public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.TopRight;

        private string htmlColorTag;
        private const string fpsLabel = "{0:2}</color> <#8080ff>FPS \n<#FF8000>{1:2} <#8080ff>MS";

        private TextMeshProUGUI m_TextMeshPro;
        private RectTransform m_frameCounter_transform;

        private FpsCounterAnchorPositions last_AnchorPosition;

        void Awake()
        {
            if (!enabled)
                return;

            Application.targetFrameRate = 1000;

            GameObject frameCounter = new GameObject("Frame Counter");
            m_frameCounter_transform = frameCounter.AddComponent<RectTransform>();

            m_frameCounter_transform.SetParent(this.transform, false);

            m_TextMeshPro = frameCounter.AddComponent<TextMeshProUGUI>();
            m_TextMeshPro.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/LiberationSans SDF");
            m_TextMeshPro.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Overlay");

            m_TextMeshPro.enableWordWrapping = false;
            m_TextMeshPro.fontSize = 36;

            m_TextMeshPro.isOverlay = true;

            Set_FrameCounter_Position(AnchorPosition);
            last_AnchorPosition = AnchorPosition;
        }


        void Start()
        {
            m_LastInterval = Time.realtimeSinceStartup;
            m_Frames = 0;
        }


        void Update()
        {
            if (AnchorPosition != last_AnchorPosition)
                Set_FrameCounter_Position(AnchorPosition);

            last_AnchorPosition = AnchorPosition;

            m_Frames += 1;
            float timeNow = Time.realtimeSinceStartup;

            if (timeNow > m_LastInterval + UpdateInterval)
            {
                // display two fractional digits (f2 format)
                float fps = m_Frames / (timeNow - m_LastInterval);
                float ms = 1000.0f / Mathf.Max(fps, 0.00001f);

                if (fps < 30)
                    htmlColorTag = "<color=yellow>";
                else if (fps < 10)
                    htmlColorTag = "<color=red>";
                else
                    htmlColorTag = "<color=green>";

                m_TextMeshPro.SetText(htmlColorTag + fpsLabel, fps, ms);

                m_Frames = 0;
                m_LastInterval = timeNow;
            }
        }


        void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position)
        {
            switch (anchor_position)
            {
                case FpsCounterAnchorPositions.TopLeft:
                    m_TextMeshPro.alignment = TextAlignmentOptions.TopLeft;
                    m_frameCounter_transform.pivot = new Vector2(0, 1);
                    m_frameCounter_transform.anchorMin = new Vector2(0.01f, 0.99f);
                    m_frameCounter_transform.anchorMax = new Vector2(0.01f, 0.99f);
                    m_frameCounter_transform.anchoredPosition = new Vector2(0, 1);
                    break;
                case FpsCounterAnchorPositions.BottomLeft:
                    m_TextMeshPro.alignment = TextAlignmentOptions.BottomLeft;
                    m_frameCounter_transform.pivot = new Vector2(0, 0);
                    m_frameCounter_transform.anchorMin = new Vector2(0.01f, 0.01f);
                    m_frameCounter_transform.anchorMax = new Vector2(0.01f, 0.01f);
                    m_frameCounter_transform.anchoredPosition = new Vector2(0, 0);
                    break;
                case FpsCounterAnchorPositions.TopRight:
                    m_TextMeshPro.alignment = TextAlignmentOptions.TopRight;
                    m_frameCounter_transform.pivot = new Vector2(1, 1);
                    m_frameCounter_transform.anchorMin = new Vector2(0.99f, 0.99f);
                    m_frameCounter_transform.anchorMax = new Vector2(0.99f, 0.99f);
                    m_frameCounter_transform.anchoredPosition = new Vector2(1, 1);
                    break;
                case FpsCounterAnchorPositions.BottomRight:
                    m_TextMeshPro.alignment = TextAlignmentOptions.BottomRight;
                    m_frameCounter_transform.pivot = new Vector2(1, 0);
                    m_frameCounter_transform.anchorMin = new Vector2(0.99f, 0.01f);
                    m_frameCounter_transform.anchorMax = new Vector2(0.99f, 0.01f);
                    m_frameCounter_transform.anchoredPosition = new Vector2(1, 0);
                    break;
            }
        }
    }
}

==================== TMP_TextInfoDebugTool.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_TextInfoDebugTool.cs) ====================
﻿using System;
using UnityEngine;
using System.Collections;
using UnityEditor;


namespace TMPro.Examples
{

    public class TMP_TextInfoDebugTool : MonoBehaviour
    {
        // Since this script is used for debugging, we exclude it from builds.
        // TODO: Rework this script to make it into an editor utility.
        #if UNITY_EDITOR
        public bool ShowCharacters;
        public bool ShowWords;
        public bool ShowLinks;
        public bool ShowLines;
        public bool ShowMeshBounds;
        public bool ShowTextBounds;
        [Space(10)]
        [TextArea(2, 2)]
        public string ObjectStats;

        [SerializeField]
        private TMP_Text m_TextComponent;

        private Transform m_Transform;
        private TMP_TextInfo m_TextInfo;

        private float m_ScaleMultiplier;
        private float m_HandleSize;


        void OnDrawGizmos()
        {
            if (m_TextComponent == null)
            {
                m_TextComponent = GetComponent<TMP_Text>();

                if (m_TextComponent == null)
                    return;
            }

            m_Transform = m_TextComponent.transform;

            // Get a reference to the text object's textInfo
            m_TextInfo = m_TextComponent.textInfo;

            // Update Text Statistics
            ObjectStats = "Characters: " + m_TextInfo.characterCount + "   Words: " + m_TextInfo.wordCount + "   Spaces: " + m_TextInfo.spaceCount + "   Sprites: " + m_TextInfo.spriteCount + "   Links: " + m_TextInfo.linkCount
                          + "\nLines: " + m_TextInfo.lineCount + "   Pages: " + m_TextInfo.pageCount;

            // Get the handle size for drawing the various
            m_ScaleMultiplier = m_TextComponent.GetType() == typeof(TextMeshPro) ? 1 : 0.1f;
            m_HandleSize = HandleUtility.GetHandleSize(m_Transform.position) * m_ScaleMultiplier;

            // Draw line metrics
            #region Draw Lines
            if (ShowLines)
                DrawLineBounds();
            #endregion

            // Draw word metrics
            #region Draw Words
            if (ShowWords)
                DrawWordBounds();
            #endregion

            // Draw character metrics
            #region Draw Characters
            if (ShowCharacters)
                DrawCharactersBounds();
            #endregion

            // Draw Quads around each of the words
            #region Draw Links
            if (ShowLinks)
                DrawLinkBounds();
            #endregion

            // Draw Quad around the bounds of the text
            #region Draw Bounds
            if (ShowMeshBounds)
                DrawBounds();
            #endregion

            // Draw Quad around the rendered region of the text.
            #region Draw Text Bounds
            if (ShowTextBounds)
                DrawTextBounds();
            #endregion
        }


        /// <summary>
        /// Method to draw a rectangle around each character.
        /// </summary>
        /// <param name="text"></param>
        void DrawCharactersBounds()
        {
            int characterCount = m_TextInfo.characterCount;

            for (int i = 0; i < characterCount; i++)
            {
                // Draw visible as well as invisible characters
                TMP_CharacterInfo characterInfo = m_TextInfo.characterInfo[i];

                bool isCharacterVisible = i < m_TextComponent.maxVisibleCharacters &&
                                          characterInfo.lineNumber < m_TextComponent.maxVisibleLines &&
                                          i >= m_TextComponent.firstVisibleCharacter;

                if (m_TextComponent.overflowMode == TextOverflowModes.Page)
                    isCharacterVisible = isCharacterVisible && characterInfo.pageNumber + 1 == m_TextComponent.pageToDisplay;

                if (!isCharacterVisible)
                    continue;

                float dottedLineSize = 6;

                // Get Bottom Left and Top Right position of the current character
                Vector3 bottomLeft = m_Transform.TransformPoint(characterInfo.bottomLeft);
                Vector3 topLeft = m_Transform.TransformPoint(new Vector3(characterInfo.topLeft.x, characterInfo.topLeft.y, 0));
                Vector3 topRight = m_Transform.TransformPoint(characterInfo.topRight);
                Vector3 bottomRight = m_Transform.TransformPoint(new Vector3(characterInfo.bottomRight.x, characterInfo.bottomRight.y, 0));

                // Draw character bounds
                if (characterInfo.isVisible)
                {
                    Color color = Color.green;
                    DrawDottedRectangle(bottomLeft, topRight, color);
                }
                else
                {
                    Color color = Color.grey;

                    float whiteSpaceAdvance = Math.Abs(characterInfo.origin - characterInfo.xAdvance) > 0.01f ? characterInfo.xAdvance : characterInfo.origin + (characterInfo.ascender - characterInfo.descender) * 0.03f;
                    DrawDottedRectangle(m_Transform.TransformPoint(new Vector3(characterInfo.origin, characterInfo.descender, 0)), m_Transform.TransformPoint(new Vector3(whiteSpaceAdvance, characterInfo.ascender, 0)), color, 4);
                }

                float origin = characterInfo.origin;
                float advance = characterInfo.xAdvance;
                float ascentline = characterInfo.ascender;
                float baseline = characterInfo.baseLine;
                float descentline = characterInfo.descender;

                //Draw Ascent line
                Vector3 ascentlineStart = m_Transform.TransformPoint(new Vector3(origin, ascentline, 0));
                Vector3 ascentlineEnd = m_Transform.TransformPoint(new Vector3(advance, ascentline, 0));

                Handles.color = Color.cyan;
                Handles.DrawDottedLine(ascentlineStart, ascentlineEnd, dottedLineSize);

                // Draw Cap Height & Mean line
                float capline = characterInfo.fontAsset == null ? 0 : baseline + characterInfo.fontAsset.faceInfo.capLine * characterInfo.scale;
                Vector3 capHeightStart = new Vector3(topLeft.x, m_Transform.TransformPoint(new Vector3(0, capline, 0)).y, 0);
                Vector3 capHeightEnd = new Vector3(topRight.x, m_Transform.TransformPoint(new Vector3(0, capline, 0)).y, 0);

                float meanline = characterInfo.fontAsset == null ? 0 : baseline + characterInfo.fontAsset.faceInfo.meanLine * characterInfo.scale;
                Vector3 meanlineStart = new Vector3(topLeft.x, m_Transform.TransformPoint(new Vector3(0, meanline, 0)).y, 0);
                Vector3 meanlineEnd = new Vector3(topRight.x, m_Transform.TransformPoint(new Vector3(0, meanline, 0)).y, 0);

                if (characterInfo.isVisible)
                {
                    // Cap line
                    Handles.color = Color.cyan;
                    Handles.DrawDottedLine(capHeightStart, capHeightEnd, dottedLineSize);

                    // Mean line
                    Handles.color = Color.cyan;
                    Handles.DrawDottedLine(meanlineStart, meanlineEnd, dottedLineSize);
                }

                //Draw Base line
                Vector3 baselineStart = m_Transform.TransformPoint(new Vector3(origin, baseline, 0));
                Vector3 baselineEnd = m_Transform.TransformPoint(new Vector3(advance, baseline, 0));

                Handles.color = Color.cyan;
                Handles.DrawDottedLine(baselineStart, baselineEnd, dottedLineSize);

                //Draw Descent line
                Vector3 descentlineStart = m_Transform.TransformPoint(new Vector3(origin, descentline, 0));
                Vector3 descentlineEnd = m_Transform.TransformPoint(new Vector3(advance, descentline, 0));

                Handles.color = Color.cyan;
                Handles.DrawDottedLine(descentlineStart, descentlineEnd, dottedLineSize);

                // Draw Origin
                Vector3 originPosition = m_Transform.TransformPoint(new Vector3(origin, baseline, 0));
                DrawCrosshair(originPosition, 0.05f / m_ScaleMultiplier, Color.cyan);

                // Draw Horizontal Advance
                Vector3 advancePosition = m_Transform.TransformPoint(new Vector3(advance, baseline, 0));
                DrawSquare(advancePosition, 0.025f / m_ScaleMultiplier, Color.yellow);
                DrawCrosshair(advancePosition, 0.0125f / m_ScaleMultiplier, Color.yellow);

                // Draw text labels for metrics
               if (m_HandleSize < 0.5f)
               {
                   GUIStyle style = new GUIStyle(GUI.skin.GetStyle("Label"));
                   style.normal.textColor = new Color(0.6f, 0.6f, 0.6f, 1.0f);
                   style.fontSize = 12;
                   style.fixedWidth = 200;
                   style.fixedHeight = 20;

                   Vector3 labelPosition;
                   float center = (origin + advance) / 2;

                   //float baselineMetrics = 0;
                   //float ascentlineMetrics = ascentline - baseline;
                   //float caplineMetrics = capline - baseline;
                   //float meanlineMetrics = meanline - baseline;
                   //float descentlineMetrics = descentline - baseline;

                   // Ascent Line
                   labelPosition = m_Transform.TransformPoint(new Vector3(center, ascentline, 0));
                   style.alignment = TextAnchor.UpperCenter;
                   Handles.Label(labelPosition, "Ascent Line", style);
                   //Handles.Label(labelPosition, "Ascent Line (" + ascentlineMetrics.ToString("f3") + ")" , style);

                   // Base Line
                   labelPosition = m_Transform.TransformPoint(new Vector3(center, baseline, 0));
                   Handles.Label(labelPosition, "Base Line", style);
                   //Handles.Label(labelPosition, "Base Line (" + baselineMetrics.ToString("f3") + ")" , style);

                   // Descent line
                   labelPosition = m_Transform.TransformPoint(new Vector3(center, descentline, 0));
                   Handles.Label(labelPosition, "Descent Line", style);
                   //Handles.Label(labelPosition, "Descent Line (" + descentlineMetrics.ToString("f3") + ")" , style);

                   if (characterInfo.isVisible)
                   {
                       // Cap Line
                       labelPosition = m_Transform.TransformPoint(new Vector3(center, capline, 0));
                       style.alignment = TextAnchor.UpperCenter;
                       Handles.Label(labelPosition, "Cap Line", style);
                       //Handles.Label(labelPosition, "Cap Line (" + caplineMetrics.ToString("f3") + ")" , style);

                       // Mean Line
                       labelPosition = m_Transform.TransformPoint(new Vector3(center, meanline, 0));
                       style.alignment = TextAnchor.UpperCenter;
                       Handles.Label(labelPosition, "Mean Line", style);
                       //Handles.Label(labelPosition, "Mean Line (" + ascentlineMetrics.ToString("f3") + ")" , style);

                       // Origin
                       labelPosition = m_Transform.TransformPoint(new Vector3(origin, baseline, 0));
                       style.alignment = TextAnchor.UpperRight;
                       Handles.Label(labelPosition, "Origin ", style);

                       // Advance
                       labelPosition = m_Transform.TransformPoint(new Vector3(advance, baseline, 0));
                       style.alignment = TextAnchor.UpperLeft;
                       Handles.Label(labelPosition, "  Advance", style);
                   }
               }
            }
        }


        /// <summary>
        /// Method to draw rectangles around each word of the text.
        /// </summary>
        /// <param name="text"></param>
        void DrawWordBounds()
        {
            for (int i = 0; i < m_TextInfo.wordCount; i++)
            {
                TMP_WordInfo wInfo = m_TextInfo.wordInfo[i];

                bool isBeginRegion = false;

                Vector3 bottomLeft = Vector3.zero;
                Vector3 topLeft = Vector3.zero;
                Vector3 bottomRight = Vector3.zero;
                Vector3 topRight = Vector3.zero;

                float maxAscender = -Mathf.Infinity;
                float minDescender = Mathf.Infinity;

                Color wordColor = Color.green;

                // Iterate through each character of the word
                for (int j = 0; j < wInfo.characterCount; j++)
                {
                    int characterIndex = wInfo.firstCharacterIndex + j;
                    TMP_CharacterInfo currentCharInfo = m_TextInfo.characterInfo[characterIndex];
                    int currentLine = currentCharInfo.lineNumber;

                    bool isCharacterVisible = characterIndex > m_TextComponent.maxVisibleCharacters ||
                                              currentCharInfo.lineNumber > m_TextComponent.maxVisibleLines ||
                                             (m_TextComponent.overflowMode == TextOverflowModes.Page && currentCharInfo.pageNumber + 1 != m_TextComponent.pageToDisplay) ? false : true;

                    // Track Max Ascender and Min Descender
                    maxAscender = Mathf.Max(maxAscender, currentCharInfo.ascender);
                    minDescender = Mathf.Min(minDescender, currentCharInfo.descender);

                    if (isBeginRegion == false && isCharacterVisible)
                    {
                        isBeginRegion = true;

                        bottomLeft = new Vector3(currentCharInfo.bottomLeft.x, currentCharInfo.descender, 0);
                        topLeft = new Vector3(currentCharInfo.bottomLeft.x, currentCharInfo.ascender, 0);

                        //Debug.Log("Start Word Region at [" + currentCharInfo.character + "]");

                        // If Word is one character
                        if (wInfo.characterCount == 1)
                        {
                            isBeginRegion = false;

                            topLeft = m_Transform.TransformPoint(new Vector3(topLeft.x, maxAscender, 0));
                            bottomLeft = m_Transform.TransformPoint(new Vector3(bottomLeft.x, minDescender, 0));
                            bottomRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, minDescender, 0));
                            topRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, maxAscender, 0));

                            // Draw Region
                            DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, wordColor);

                            //Debug.Log("End Word Region at [" + currentCharInfo.character + "]");
                        }
                    }

                    // Last Character of Word
                    if (isBeginRegion && j == wInfo.characterCount - 1)
                    {
                        isBeginRegion = false;

                        topLeft = m_Transform.TransformPoint(new Vector3(topLeft.x, maxAscender, 0));
                        bottomLeft = m_Transform.TransformPoint(new Vector3(bottomLeft.x, minDescender, 0));
                        bottomRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, minDescender, 0));
                        topRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, maxAscender, 0));

                        // Draw Region
                        DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, wordColor);

                        //Debug.Log("End Word Region at [" + currentCharInfo.character + "]");
                    }
                    // If Word is split on more than one line.
                    else if (isBeginRegion && currentLine != m_TextInfo.characterInfo[characterIndex + 1].lineNumber)
                    {
                        isBeginRegion = false;

                        topLeft = m_Transform.TransformPoint(new Vector3(topLeft.x, maxAscender, 0));
                        bottomLeft = m_Transform.TransformPoint(new Vector3(bottomLeft.x, minDescender, 0));
                        bottomRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, minDescender, 0));
                        topRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, maxAscender, 0));

                        // Draw Region
                        DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, wordColor);
                        //Debug.Log("End Word Region at [" + currentCharInfo.character + "]");
                        maxAscender = -Mathf.Infinity;
                        minDescender = Mathf.Infinity;

                    }
                }

                //Debug.Log(wInfo.GetWord(m_TextMeshPro.textInfo.characterInfo));
            }


        }


        /// <summary>
        /// Draw rectangle around each of the links contained in the text.
        /// </summary>
        /// <param name="text"></param>
        void DrawLinkBounds()
        {
            TMP_TextInfo textInfo = m_TextComponent.textInfo;

            for (int i = 0; i < textInfo.linkCount; i++)
            {
                TMP_LinkInfo linkInfo = textInfo.linkInfo[i];

                bool isBeginRegion = false;

                Vector3 bottomLeft = Vector3.zero;
                Vector3 topLeft = Vector3.zero;
                Vector3 bottomRight = Vector3.zero;
                Vector3 topRight = Vector3.zero;

                float maxAscender = -Mathf.Infinity;
                float minDescender = Mathf.Infinity;

                Color32 linkColor = Color.cyan;

                // Iterate through each character of the link text
                for (int j = 0; j < linkInfo.linkTextLength; j++)
                {
                    int characterIndex = linkInfo.linkTextfirstCharacterIndex + j;
                    TMP_CharacterInfo currentCharInfo = textInfo.characterInfo[characterIndex];
                    int currentLine = currentCharInfo.lineNumber;

                    bool isCharacterVisible = characterIndex > m_TextComponent.maxVisibleCharacters ||
                                              currentCharInfo.lineNumber > m_TextComponent.maxVisibleLines ||
                                             (m_TextComponent.overflowMode == TextOverflowModes.Page && currentCharInfo.pageNumber + 1 != m_TextComponent.pageToDisplay) ? false : true;

                    // Track Max Ascender and Min Descender
                    maxAscender = Mathf.Max(maxAscender, currentCharInfo.ascender);
                    minDescender = Mathf.Min(minDescender, currentCharInfo.descender);

                    if (isBeginRegion == false && isCharacterVisible)
                    {
                        isBeginRegion = true;

                        bottomLeft = new Vector3(currentCharInfo.bottomLeft.x, currentCharInfo.descender, 0);
                        topLeft = new Vector3(currentCharInfo.bottomLeft.x, currentCharInfo.ascender, 0);

                        //Debug.Log("Start Word Region at [" + currentCharInfo.character + "]");

                        // If Link is one character
                        if (linkInfo.linkTextLength == 1)
                        {
                            isBeginRegion = false;

                            topLeft = m_Transform.TransformPoint(new Vector3(topLeft.x, maxAscender, 0));
                            bottomLeft = m_Transform.TransformPoint(new Vector3(bottomLeft.x, minDescender, 0));
                            bottomRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, minDescender, 0));
                            topRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, maxAscender, 0));

                            // Draw Region
                            DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, linkColor);

                            //Debug.Log("End Word Region at [" + currentCharInfo.character + "]");
                        }
                    }

                    // Last Character of Link
                    if (isBeginRegion && j == linkInfo.linkTextLength - 1)
                    {
                        isBeginRegion = false;

                        topLeft = m_Transform.TransformPoint(new Vector3(topLeft.x, maxAscender, 0));
                        bottomLeft = m_Transform.TransformPoint(new Vector3(bottomLeft.x, minDescender, 0));
                        bottomRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, minDescender, 0));
                        topRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, maxAscender, 0));

                        // Draw Region
                        DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, linkColor);

                        //Debug.Log("End Word Region at [" + currentCharInfo.character + "]");
                    }
                    // If Link is split on more than one line.
                    else if (isBeginRegion && currentLine != textInfo.characterInfo[characterIndex + 1].lineNumber)
                    {
                        isBeginRegion = false;

                        topLeft = m_Transform.TransformPoint(new Vector3(topLeft.x, maxAscender, 0));
                        bottomLeft = m_Transform.TransformPoint(new Vector3(bottomLeft.x, minDescender, 0));
                        bottomRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, minDescender, 0));
                        topRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, maxAscender, 0));

                        // Draw Region
                        DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, linkColor);

                        maxAscender = -Mathf.Infinity;
                        minDescender = Mathf.Infinity;
                        //Debug.Log("End Word Region at [" + currentCharInfo.character + "]");
                    }
                }

                //Debug.Log(wInfo.GetWord(m_TextMeshPro.textInfo.characterInfo));
            }
        }


        /// <summary>
        /// Draw Rectangles around each lines of the text.
        /// </summary>
        /// <param name="text"></param>
        void DrawLineBounds()
        {
            int lineCount = m_TextInfo.lineCount;

            for (int i = 0; i < lineCount; i++)
            {
                TMP_LineInfo lineInfo = m_TextInfo.lineInfo[i];
                TMP_CharacterInfo firstCharacterInfo = m_TextInfo.characterInfo[lineInfo.firstCharacterIndex];
                TMP_CharacterInfo lastCharacterInfo = m_TextInfo.characterInfo[lineInfo.lastCharacterIndex];

                bool isLineVisible = (lineInfo.characterCount == 1 && (firstCharacterInfo.character == 10 || firstCharacterInfo.character == 11 || firstCharacterInfo.character == 0x2028 || firstCharacterInfo.character == 0x2029)) ||
                                      i > m_TextComponent.maxVisibleLines ||
                                     (m_TextComponent.overflowMode == TextOverflowModes.Page && firstCharacterInfo.pageNumber + 1 != m_TextComponent.pageToDisplay) ? false : true;

                if (!isLineVisible) continue;

                float lineBottomLeft = firstCharacterInfo.bottomLeft.x;
                float lineTopRight = lastCharacterInfo.topRight.x;

                float ascentline = lineInfo.ascender;
                float baseline = lineInfo.baseline;
                float descentline = lineInfo.descender;

                float dottedLineSize = 12;

                // Draw line extents
                DrawDottedRectangle(m_Transform.TransformPoint(lineInfo.lineExtents.min), m_Transform.TransformPoint(lineInfo.lineExtents.max), Color.green, 4);

                // Draw Ascent line
                Vector3 ascentlineStart = m_Transform.TransformPoint(new Vector3(lineBottomLeft, ascentline, 0));
                Vector3 ascentlineEnd = m_Transform.TransformPoint(new Vector3(lineTopRight, ascentline, 0));

                Handles.color = Color.yellow;
                Handles.DrawDottedLine(ascentlineStart, ascentlineEnd, dottedLineSize);

                // Draw Base line
                Vector3 baseLineStart = m_Transform.TransformPoint(new Vector3(lineBottomLeft, baseline, 0));
                Vector3 baseLineEnd = m_Transform.TransformPoint(new Vector3(lineTopRight, baseline, 0));

                Handles.color = Color.yellow;
                Handles.DrawDottedLine(baseLineStart, baseLineEnd, dottedLineSize);

                // Draw Descent line
                Vector3 descentLineStart = m_Transform.TransformPoint(new Vector3(lineBottomLeft, descentline, 0));
                Vector3 descentLineEnd = m_Transform.TransformPoint(new Vector3(lineTopRight, descentline, 0));

                Handles.color = Color.yellow;
                Handles.DrawDottedLine(descentLineStart, descentLineEnd, dottedLineSize);

                // Draw text labels for metrics
                if (m_HandleSize < 1.0f)
                {
                    GUIStyle style = new GUIStyle();
                    style.normal.textColor = new Color(0.8f, 0.8f, 0.8f, 1.0f);
                    style.fontSize = 12;
                    style.fixedWidth = 200;
                    style.fixedHeight = 20;
                    Vector3 labelPosition;

                    // Ascent Line
                    labelPosition = m_Transform.TransformPoint(new Vector3(lineBottomLeft, ascentline, 0));
                    style.padding = new RectOffset(0, 10, 0, 5);
                    style.alignment = TextAnchor.MiddleRight;
                    Handles.Label(labelPosition, "Ascent Line", style);

                    // Base Line
                    labelPosition = m_Transform.TransformPoint(new Vector3(lineBottomLeft, baseline, 0));
                    Handles.Label(labelPosition, "Base Line", style);

                    // Descent line
                    labelPosition = m_Transform.TransformPoint(new Vector3(lineBottomLeft, descentline, 0));
                    Handles.Label(labelPosition, "Descent Line", style);
                }
            }
        }


        /// <summary>
        /// Draw Rectangle around the bounds of the text object.
        /// </summary>
        void DrawBounds()
        {
            Bounds meshBounds = m_TextComponent.bounds;

            // Get Bottom Left and Top Right position of each word
            Vector3 bottomLeft = m_TextComponent.transform.position + meshBounds.min;
            Vector3 topRight = m_TextComponent.transform.position + meshBounds.max;

            DrawRectangle(bottomLeft, topRight, new Color(1, 0.5f, 0));
        }


        void DrawTextBounds()
        {
            Bounds textBounds = m_TextComponent.textBounds;

            Vector3 bottomLeft = m_TextComponent.transform.position + (textBounds.center - textBounds.extents);
            Vector3 topRight = m_TextComponent.transform.position + (textBounds.center + textBounds.extents);

            DrawRectangle(bottomLeft, topRight, new Color(0f, 0.5f, 0.5f));
        }


        // Draw Rectangles
        void DrawRectangle(Vector3 BL, Vector3 TR, Color color)
        {
            Gizmos.color = color;

            Gizmos.DrawLine(new Vector3(BL.x, BL.y, 0), new Vector3(BL.x, TR.y, 0));
            Gizmos.DrawLine(new Vector3(BL.x, TR.y, 0), new Vector3(TR.x, TR.y, 0));
            Gizmos.DrawLine(new Vector3(TR.x, TR.y, 0), new Vector3(TR.x, BL.y, 0));
            Gizmos.DrawLine(new Vector3(TR.x, BL.y, 0), new Vector3(BL.x, BL.y, 0));
        }

        void DrawDottedRectangle(Vector3 bottomLeft, Vector3 topRight, Color color, float size = 5.0f)
        {
            Handles.color = color;
            Handles.DrawDottedLine(bottomLeft, new Vector3(bottomLeft.x, topRight.y, bottomLeft.z), size);
            Handles.DrawDottedLine(new Vector3(bottomLeft.x, topRight.y, bottomLeft.z), topRight, size);
            Handles.DrawDottedLine(topRight, new Vector3(topRight.x, bottomLeft.y, bottomLeft.z), size);
            Handles.DrawDottedLine(new Vector3(topRight.x, bottomLeft.y, bottomLeft.z), bottomLeft, size);
        }

        void DrawSolidRectangle(Vector3 bottomLeft, Vector3 topRight, Color color, float size = 5.0f)
        {
            Handles.color = color;
            Rect rect = new Rect(bottomLeft, topRight - bottomLeft);
            Handles.DrawSolidRectangleWithOutline(rect, color, Color.black);
        }

        void DrawSquare(Vector3 position, float size, Color color)
        {
            Handles.color = color;
            Vector3 bottomLeft = new Vector3(position.x - size, position.y - size, position.z);
            Vector3 topLeft = new Vector3(position.x - size, position.y + size, position.z);
            Vector3 topRight = new Vector3(position.x + size, position.y + size, position.z);
            Vector3 bottomRight = new Vector3(position.x + size, position.y - size, position.z);

            Handles.DrawLine(bottomLeft, topLeft);
            Handles.DrawLine(topLeft, topRight);
            Handles.DrawLine(topRight, bottomRight);
            Handles.DrawLine(bottomRight, bottomLeft);
        }

        void DrawCrosshair(Vector3 position, float size, Color color)
        {
            Handles.color = color;

            Handles.DrawLine(new Vector3(position.x - size, position.y, position.z), new Vector3(position.x + size, position.y, position.z));
            Handles.DrawLine(new Vector3(position.x, position.y - size, position.z), new Vector3(position.x, position.y + size, position.z));
        }


        // Draw Rectangles
        void DrawRectangle(Vector3 bl, Vector3 tl, Vector3 tr, Vector3 br, Color color)
        {
            Gizmos.color = color;

            Gizmos.DrawLine(bl, tl);
            Gizmos.DrawLine(tl, tr);
            Gizmos.DrawLine(tr, br);
            Gizmos.DrawLine(br, bl);
        }


        // Draw Rectangles
        void DrawDottedRectangle(Vector3 bl, Vector3 tl, Vector3 tr, Vector3 br, Color color)
        {
            var cam = Camera.current;
            float dotSpacing = (cam.WorldToScreenPoint(br).x - cam.WorldToScreenPoint(bl).x) / 75f;
            UnityEditor.Handles.color = color;

            UnityEditor.Handles.DrawDottedLine(bl, tl, dotSpacing);
            UnityEditor.Handles.DrawDottedLine(tl, tr, dotSpacing);
            UnityEditor.Handles.DrawDottedLine(tr, br, dotSpacing);
            UnityEditor.Handles.DrawDottedLine(br, bl, dotSpacing);
        }
        #endif
    }
}



==================== ObjectSpin.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/ObjectSpin.cs) ====================
﻿using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class ObjectSpin : MonoBehaviour
    {

#pragma warning disable 0414

        public float SpinSpeed = 5;
        public int RotationRange = 15;
        private Transform m_transform;

        private float m_time;
        private Vector3 m_prevPOS;
        private Vector3 m_initial_Rotation;
        private Vector3 m_initial_Position;
        private Color32 m_lightColor;
        private int frames = 0;

        public enum MotionType { Rotation, BackAndForth, Translation };
        public MotionType Motion;

        void Awake()
        {
            m_transform = transform;
            m_initial_Rotation = m_transform.rotation.eulerAngles;
            m_initial_Position = m_transform.position;

            Light light = GetComponent<Light>();
            m_lightColor = light != null ? light.color : Color.black;
        }


        // Update is called once per frame
        void Update()
        {
            if (Motion == MotionType.Rotation)
            {
                m_transform.Rotate(0, SpinSpeed * Time.deltaTime, 0);
            }
            else if (Motion == MotionType.BackAndForth)
            {
                m_time += SpinSpeed * Time.deltaTime;
                m_transform.rotation = Quaternion.Euler(m_initial_Rotation.x, Mathf.Sin(m_time) * RotationRange + m_initial_Rotation.y, m_initial_Rotation.z);
            }
            else
            {
                m_time += SpinSpeed * Time.deltaTime;

                float x = 15 * Mathf.Cos(m_time * .95f);
                float y = 10; // *Mathf.Sin(m_time * 1f) * Mathf.Cos(m_time * 1f);
                float z = 0f; // *Mathf.Sin(m_time * .9f);    

                m_transform.position = m_initial_Position + new Vector3(x, z, y);

                // Drawing light patterns because they can be cool looking.
                //if (frames > 2)
                //    Debug.DrawLine(m_transform.position, m_prevPOS, m_lightColor, 100f);

                m_prevPOS = m_transform.position;
                frames += 1;
            }
        }
    }
}

==================== EnvMapAnimator.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/EnvMapAnimator.cs) ====================
﻿using UnityEngine;
using System.Collections;
using TMPro;

public class EnvMapAnimator : MonoBehaviour {

    //private Vector3 TranslationSpeeds;
    public Vector3 RotationSpeeds;
    private TMP_Text m_textMeshPro;
    private Material m_material;
    

    void Awake()
    {
        //Debug.Log("Awake() on Script called.");
        m_textMeshPro = GetComponent<TMP_Text>();
        m_material = m_textMeshPro.fontSharedMaterial;
    }

    // Use this for initialization
	IEnumerator Start ()
    {
        Matrix4x4 matrix = new Matrix4x4(); 
        
        while (true)
        {
            //matrix.SetTRS(new Vector3 (Time.time * TranslationSpeeds.x, Time.time * TranslationSpeeds.y, Time.time * TranslationSpeeds.z), Quaternion.Euler(Time.time * RotationSpeeds.x, Time.time * RotationSpeeds.y , Time.time * RotationSpeeds.z), Vector3.one);
             matrix.SetTRS(Vector3.zero, Quaternion.Euler(Time.time * RotationSpeeds.x, Time.time * RotationSpeeds.y , Time.time * RotationSpeeds.z), Vector3.one);

            m_material.SetMatrix("_EnvMatrix", matrix);

            yield return null;
        }
	}
}


==================== Benchmark04.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/Benchmark04.cs) ====================
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class Benchmark04 : MonoBehaviour
    {

        public int SpawnType = 0;

        public int MinPointSize = 12;
        public int MaxPointSize = 64;
        public int Steps = 4;

        private Transform m_Transform;
        //private TextMeshProFloatingText floatingText_Script;
        //public Material material;


        void Start()
        {
            m_Transform = transform;

            float lineHeight = 0;
            float orthoSize = Camera.main.orthographicSize = Screen.height / 2;
            float ratio = (float)Screen.width / Screen.height;

            for (int i = MinPointSize; i <= MaxPointSize; i += Steps)
            {
                if (SpawnType == 0)
                {
                    // TextMesh Pro Implementation
                    GameObject go = new GameObject("Text - " + i + " Pts");

                    if (lineHeight > orthoSize * 2) return;

                    go.transform.position = m_Transform.position + new Vector3(ratio * -orthoSize * 0.975f, orthoSize * 0.975f - lineHeight, 0);

                    TextMeshPro textMeshPro = go.AddComponent<TextMeshPro>();

                    //textMeshPro.fontSharedMaterial = material;
                    //textMeshPro.font = Resources.Load("Fonts & Materials/LiberationSans SDF", typeof(TextMeshProFont)) as TextMeshProFont;
                    //textMeshPro.anchor = AnchorPositions.Left;
                    textMeshPro.rectTransform.pivot = new Vector2(0, 0.5f);

                    textMeshPro.enableWordWrapping = false;
                    textMeshPro.extraPadding = true;
                    textMeshPro.isOrthographic = true;
                    textMeshPro.fontSize = i;

                    textMeshPro.text = i + " pts - Lorem ipsum dolor sit...";
                    textMeshPro.color = new Color32(255, 255, 255, 255);

                    lineHeight += i;
                }
                else
                {
                    // TextMesh Implementation
                    // Causes crashes since atlas needed exceeds 4096 X 4096
                    /*
                    GameObject go = new GameObject("Arial " + i);

                    //if (lineHeight > orthoSize * 2 * 0.9f) return;

                    go.transform.position = m_Transform.position + new Vector3(ratio * -orthoSize * 0.975f, orthoSize * 0.975f - lineHeight, 1);
                                       
                    TextMesh textMesh = go.AddComponent<TextMesh>();
                    textMesh.font = Resources.Load("Fonts/ARIAL", typeof(Font)) as Font;
                    textMesh.renderer.sharedMaterial = textMesh.font.material;
                    textMesh.anchor = TextAnchor.MiddleLeft;
                    textMesh.fontSize = i * 10;

                    textMesh.color = new Color32(255, 255, 255, 255);
                    textMesh.text = i + " pts - Lorem ipsum dolor sit...";

                    lineHeight += i;
                    */
                }
            }
        }

    }
}


==================== TextMeshSpawner.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/TextMeshSpawner.cs) ====================
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class TextMeshSpawner : MonoBehaviour
    {

        public int SpawnType = 0;
        public int NumberOfNPC = 12;

        public Font TheFont;

        private TextMeshProFloatingText floatingText_Script;

        void Awake()
        {

        }

        void Start()
        {

            for (int i = 0; i < NumberOfNPC; i++)
            {
                if (SpawnType == 0)
                {
                    // TextMesh Pro Implementation     
                    //go.transform.localScale = new Vector3(2, 2, 2);
                    GameObject go = new GameObject(); //"NPC " + i);
                    go.transform.position = new Vector3(Random.Range(-95f, 95f), 0.5f, Random.Range(-95f, 95f));

                    //go.transform.position = new Vector3(0, 1.01f, 0);
                    //go.renderer.castShadows = false;
                    //go.renderer.receiveShadows = false;
                    //go.transform.rotation = Quaternion.Euler(0, Random.Range(0, 360), 0);

                    TextMeshPro textMeshPro = go.AddComponent<TextMeshPro>();
                    //textMeshPro.FontAsset = Resources.Load("Fonts & Materials/LiberationSans SDF", typeof(TextMeshProFont)) as TextMeshProFont;
                    //textMeshPro.anchor = AnchorPositions.Bottom;
                    textMeshPro.fontSize = 96;

                    textMeshPro.text = "!";
                    textMeshPro.color = new Color32(255, 255, 0, 255);
                    //textMeshPro.Text = "!";


                    // Spawn Floating Text
                    floatingText_Script = go.AddComponent<TextMeshProFloatingText>();
                    floatingText_Script.SpawnType = 0;
                }
                else
                {
                    // TextMesh Implementation
                    GameObject go = new GameObject(); //"NPC " + i);
                    go.transform.position = new Vector3(Random.Range(-95f, 95f), 0.5f, Random.Range(-95f, 95f));

                    //go.transform.position = new Vector3(0, 1.01f, 0);

                    TextMesh textMesh = go.AddComponent<TextMesh>();
                    textMesh.GetComponent<Renderer>().sharedMaterial = TheFont.material;
                    textMesh.font = TheFont;
                    textMesh.anchor = TextAnchor.LowerCenter;
                    textMesh.fontSize = 96;

                    textMesh.color = new Color32(255, 255, 0, 255);
                    textMesh.text = "!";

                    // Spawn Floating Text
                    floatingText_Script = go.AddComponent<TextMeshProFloatingText>();
                    floatingText_Script.SpawnType = 1;
                }
            }
        }

    }
}


==================== WarpTextExample.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/WarpTextExample.cs) ====================
﻿using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{

    public class WarpTextExample : MonoBehaviour
    {

        private TMP_Text m_TextComponent;

        public AnimationCurve VertexCurve = new AnimationCurve(new Keyframe(0, 0), new Keyframe(0.25f, 2.0f), new Keyframe(0.5f, 0), new Keyframe(0.75f, 2.0f), new Keyframe(1, 0f));
        public float AngleMultiplier = 1.0f;
        public float SpeedMultiplier = 1.0f;
        public float CurveScale = 1.0f;

        void Awake()
        {
            m_TextComponent = gameObject.GetComponent<TMP_Text>();
        }


        void Start()
        {
            StartCoroutine(WarpText());
        }


        private AnimationCurve CopyAnimationCurve(AnimationCurve curve)
        {
            AnimationCurve newCurve = new AnimationCurve();

            newCurve.keys = curve.keys;

            return newCurve;
        }


        /// <summary>
        ///  Method to curve text along a Unity animation curve.
        /// </summary>
        /// <param name="textComponent"></param>
        /// <returns></returns>
        IEnumerator WarpText()
        {
            VertexCurve.preWrapMode = WrapMode.Clamp;
            VertexCurve.postWrapMode = WrapMode.Clamp;

            //Mesh mesh = m_TextComponent.textInfo.meshInfo[0].mesh;

            Vector3[] vertices;
            Matrix4x4 matrix;

            m_TextComponent.havePropertiesChanged = true; // Need to force the TextMeshPro Object to be updated.
            CurveScale *= 10;
            float old_CurveScale = CurveScale;
            AnimationCurve old_curve = CopyAnimationCurve(VertexCurve);

            while (true)
            {
                if (!m_TextComponent.havePropertiesChanged && old_CurveScale == CurveScale && old_curve.keys[1].value == VertexCurve.keys[1].value)
                {
                    yield return null;
                    continue;
                }

                old_CurveScale = CurveScale;
                old_curve = CopyAnimationCurve(VertexCurve);

                m_TextComponent.ForceMeshUpdate(); // Generate the mesh and populate the textInfo with data we can use and manipulate.

                TMP_TextInfo textInfo = m_TextComponent.textInfo;
                int characterCount = textInfo.characterCount;


                if (characterCount == 0) continue;

                //vertices = textInfo.meshInfo[0].vertices;
                //int lastVertexIndex = textInfo.characterInfo[characterCount - 1].vertexIndex;

                float boundsMinX = m_TextComponent.bounds.min.x;  //textInfo.meshInfo[0].mesh.bounds.min.x;
                float boundsMaxX = m_TextComponent.bounds.max.x;  //textInfo.meshInfo[0].mesh.bounds.max.x;



                for (int i = 0; i < characterCount; i++)
                {
                    if (!textInfo.characterInfo[i].isVisible)
                        continue;

                    int vertexIndex = textInfo.characterInfo[i].vertexIndex;

                    // Get the index of the mesh used by this character.
                    int materialIndex = textInfo.characterInfo[i].materialReferenceIndex;

                    vertices = textInfo.meshInfo[materialIndex].vertices;

                    // Compute the baseline mid point for each character
                    Vector3 offsetToMidBaseline = new Vector2((vertices[vertexIndex + 0].x + vertices[vertexIndex + 2].x) / 2, textInfo.characterInfo[i].baseLine);
                    //float offsetY = VertexCurve.Evaluate((float)i / characterCount + loopCount / 50f); // Random.Range(-0.25f, 0.25f);

                    // Apply offset to adjust our pivot point.
                    vertices[vertexIndex + 0] += -offsetToMidBaseline;
                    vertices[vertexIndex + 1] += -offsetToMidBaseline;
                    vertices[vertexIndex + 2] += -offsetToMidBaseline;
                    vertices[vertexIndex + 3] += -offsetToMidBaseline;

                    // Compute the angle of rotation for each character based on the animation curve
                    float x0 = (offsetToMidBaseline.x - boundsMinX) / (boundsMaxX - boundsMinX); // Character's position relative to the bounds of the mesh.
                    float x1 = x0 + 0.0001f;
                    float y0 = VertexCurve.Evaluate(x0) * CurveScale;
                    float y1 = VertexCurve.Evaluate(x1) * CurveScale;

                    Vector3 horizontal = new Vector3(1, 0, 0);
                    //Vector3 normal = new Vector3(-(y1 - y0), (x1 * (boundsMaxX - boundsMinX) + boundsMinX) - offsetToMidBaseline.x, 0);
                    Vector3 tangent = new Vector3(x1 * (boundsMaxX - boundsMinX) + boundsMinX, y1) - new Vector3(offsetToMidBaseline.x, y0);

                    float dot = Mathf.Acos(Vector3.Dot(horizontal, tangent.normalized)) * 57.2957795f;
                    Vector3 cross = Vector3.Cross(horizontal, tangent);
                    float angle = cross.z > 0 ? dot : 360 - dot;

                    matrix = Matrix4x4.TRS(new Vector3(0, y0, 0), Quaternion.Euler(0, 0, angle), Vector3.one);

                    vertices[vertexIndex + 0] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 0]);
                    vertices[vertexIndex + 1] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 1]);
                    vertices[vertexIndex + 2] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 2]);
                    vertices[vertexIndex + 3] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 3]);

                    vertices[vertexIndex + 0] += offsetToMidBaseline;
                    vertices[vertexIndex + 1] += offsetToMidBaseline;
                    vertices[vertexIndex + 2] += offsetToMidBaseline;
                    vertices[vertexIndex + 3] += offsetToMidBaseline;
                }


                // Upload the mesh with the revised information
                m_TextComponent.UpdateVertexData();

                yield return new WaitForSeconds(0.025f);
            }
        }
    }
}


==================== TMP_TextSelector_A.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_TextSelector_A.cs) ====================
﻿using UnityEngine;
using UnityEngine.EventSystems;
using System.Collections;


namespace TMPro.Examples
{

    public class TMP_TextSelector_A : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler
    {
        private TextMeshPro m_TextMeshPro;

        private Camera m_Camera;

        private bool m_isHoveringObject;
        private int m_selectedLink = -1;
        private int m_lastCharIndex = -1;
        private int m_lastWordIndex = -1;

        void Awake()
        {
            m_TextMeshPro = gameObject.GetComponent<TextMeshPro>();
            m_Camera = Camera.main;

            // Force generation of the text object so we have valid data to work with. This is needed since LateUpdate() will be called before the text object has a chance to generated when entering play mode.
            m_TextMeshPro.ForceMeshUpdate();
        }


        void LateUpdate()
        {
            m_isHoveringObject = false;

            if (TMP_TextUtilities.IsIntersectingRectTransform(m_TextMeshPro.rectTransform, Input.mousePosition, Camera.main))
            {
                m_isHoveringObject = true;
            }

            if (m_isHoveringObject)
            {
                #region Example of Character Selection
                int charIndex = TMP_TextUtilities.FindIntersectingCharacter(m_TextMeshPro, Input.mousePosition, Camera.main, true);
                if (charIndex != -1 && charIndex != m_lastCharIndex && (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)))
                {
                    //Debug.Log("[" + m_TextMeshPro.textInfo.characterInfo[charIndex].character + "] has been selected.");

                    m_lastCharIndex = charIndex;

                    int meshIndex = m_TextMeshPro.textInfo.characterInfo[charIndex].materialReferenceIndex;

                    int vertexIndex = m_TextMeshPro.textInfo.characterInfo[charIndex].vertexIndex;

                    Color32 c = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255);

                    Color32[] vertexColors = m_TextMeshPro.textInfo.meshInfo[meshIndex].colors32;

                    vertexColors[vertexIndex + 0] = c;
                    vertexColors[vertexIndex + 1] = c;
                    vertexColors[vertexIndex + 2] = c;
                    vertexColors[vertexIndex + 3] = c;

                    //m_TextMeshPro.mesh.colors32 = vertexColors;
                    m_TextMeshPro.textInfo.meshInfo[meshIndex].mesh.colors32 = vertexColors;
                }
                #endregion

                #region Example of Link Handling
                // Check if mouse intersects with any links.
                int linkIndex = TMP_TextUtilities.FindIntersectingLink(m_TextMeshPro, Input.mousePosition, m_Camera);

                // Clear previous link selection if one existed.
                if ((linkIndex == -1 && m_selectedLink != -1) || linkIndex != m_selectedLink)
                {
                    //m_TextPopup_RectTransform.gameObject.SetActive(false);
                    m_selectedLink = -1;
                }

                // Handle new Link selection.
                if (linkIndex != -1 && linkIndex != m_selectedLink)
                {
                    m_selectedLink = linkIndex;

                    TMP_LinkInfo linkInfo = m_TextMeshPro.textInfo.linkInfo[linkIndex];

                    // The following provides an example of how to access the link properties.
                    //Debug.Log("Link ID: \"" + linkInfo.GetLinkID() + "\"   Link Text: \"" + linkInfo.GetLinkText() + "\""); // Example of how to retrieve the Link ID and Link Text.

                    Vector3 worldPointInRectangle;

                    RectTransformUtility.ScreenPointToWorldPointInRectangle(m_TextMeshPro.rectTransform, Input.mousePosition, m_Camera, out worldPointInRectangle);

                    switch (linkInfo.GetLinkID())
                    {
                        case "id_01": // 100041637: // id_01
                                      //m_TextPopup_RectTransform.position = worldPointInRectangle;
                                      //m_TextPopup_RectTransform.gameObject.SetActive(true);
                                      //m_TextPopup_TMPComponent.text = k_LinkText + " ID 01";
                            break;
                        case "id_02": // 100041638: // id_02
                                      //m_TextPopup_RectTransform.position = worldPointInRectangle;
                                      //m_TextPopup_RectTransform.gameObject.SetActive(true);
                                      //m_TextPopup_TMPComponent.text = k_LinkText + " ID 02";
                            break;
                    }
                }
                #endregion


                #region Example of Word Selection
                // Check if Mouse intersects any words and if so assign a random color to that word.
                int wordIndex = TMP_TextUtilities.FindIntersectingWord(m_TextMeshPro, Input.mousePosition, Camera.main);
                if (wordIndex != -1 && wordIndex != m_lastWordIndex)
                {
                    m_lastWordIndex = wordIndex;

                    TMP_WordInfo wInfo = m_TextMeshPro.textInfo.wordInfo[wordIndex];

                    Vector3 wordPOS = m_TextMeshPro.transform.TransformPoint(m_TextMeshPro.textInfo.characterInfo[wInfo.firstCharacterIndex].bottomLeft);
                    wordPOS = Camera.main.WorldToScreenPoint(wordPOS);

                    //Debug.Log("Mouse Position: " + Input.mousePosition.ToString("f3") + "  Word Position: " + wordPOS.ToString("f3"));

                    Color32[] vertexColors = m_TextMeshPro.textInfo.meshInfo[0].colors32;

                    Color32 c = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255);
                    for (int i = 0; i < wInfo.characterCount; i++)
                    {
                        int vertexIndex = m_TextMeshPro.textInfo.characterInfo[wInfo.firstCharacterIndex + i].vertexIndex;

                        vertexColors[vertexIndex + 0] = c;
                        vertexColors[vertexIndex + 1] = c;
                        vertexColors[vertexIndex + 2] = c;
                        vertexColors[vertexIndex + 3] = c;
                    }

                    m_TextMeshPro.mesh.colors32 = vertexColors;
                }
                #endregion
            }
        }


        public void OnPointerEnter(PointerEventData eventData)
        {
            Debug.Log("OnPointerEnter()");
            m_isHoveringObject = true;
        }


        public void OnPointerExit(PointerEventData eventData)
        {
            Debug.Log("OnPointerExit()");
            m_isHoveringObject = false;
        }

    }
}


==================== ShaderPropAnimator.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/ShaderPropAnimator.cs) ====================
﻿using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class ShaderPropAnimator : MonoBehaviour
    {

        private Renderer m_Renderer;
        private Material m_Material;

        public AnimationCurve GlowCurve;

        public float m_frame;

        void Awake()
        {
            // Cache a reference to object's renderer
            m_Renderer = GetComponent<Renderer>();

            // Cache a reference to object's material and create an instance by doing so.
            m_Material = m_Renderer.material;
        }

        void Start()
        {
            StartCoroutine(AnimateProperties());
        }

        IEnumerator AnimateProperties()
        {
            //float lightAngle;
            float glowPower;
            m_frame = Random.Range(0f, 1f);

            while (true)
            {
                //lightAngle = (m_Material.GetFloat(ShaderPropertyIDs.ID_LightAngle) + Time.deltaTime) % 6.2831853f;
                //m_Material.SetFloat(ShaderPropertyIDs.ID_LightAngle, lightAngle);

                glowPower = GlowCurve.Evaluate(m_frame);
                m_Material.SetFloat(ShaderUtilities.ID_GlowPower, glowPower);

                m_frame += Time.deltaTime * Random.Range(0.2f, 0.3f);
                yield return new WaitForEndOfFrame();
            }
        }
    }
}


==================== DropdownSample.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/DropdownSample.cs) ====================
﻿using TMPro;
using UnityEngine;

public class DropdownSample: MonoBehaviour
{
	[SerializeField]
	private TextMeshProUGUI text = null;

	[SerializeField]
	private TMP_Dropdown dropdownWithoutPlaceholder = null;

	[SerializeField]
	private TMP_Dropdown dropdownWithPlaceholder = null;

	public void OnButtonClick()
	{
		text.text = dropdownWithPlaceholder.value > -1 ? "Selected values:\n" + dropdownWithoutPlaceholder.value + " - " + dropdownWithPlaceholder.value : "Error: Please make a selection";
	}
}


==================== Benchmark01.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/TextMesh Pro/Examples & Extras/Scripts/Benchmark01.cs) ====================
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class Benchmark01 : MonoBehaviour
    {

        public int BenchmarkType = 0;

        public TMP_FontAsset TMProFont;
        public Font TextMeshFont;

        private TextMeshPro m_textMeshPro;
        private TextContainer m_textContainer;
        private TextMesh m_textMesh;

        private const string label01 = "The <#0050FF>count is: </color>{0}";
        private const string label02 = "The <color=#0050FF>count is: </color>";

        //private string m_string;
        //private int m_frame;

        private Material m_material01;
        private Material m_material02;



        IEnumerator Start()
        {



            if (BenchmarkType == 0) // TextMesh Pro Component
            {
                m_textMeshPro = gameObject.AddComponent<TextMeshPro>();
                m_textMeshPro.autoSizeTextContainer = true;

                //m_textMeshPro.anchorDampening = true;

                if (TMProFont != null)
                    m_textMeshPro.font = TMProFont;

                //m_textMeshPro.font = Resources.Load("Fonts & Materials/Anton SDF", typeof(TextMeshProFont)) as TextMeshProFont; // Make sure the Anton SDF exists before calling this...
                //m_textMeshPro.fontSharedMaterial = Resources.Load("Fonts & Materials/Anton SDF", typeof(Material)) as Material; // Same as above make sure this material exists.

                m_textMeshPro.fontSize = 48;
                m_textMeshPro.alignment = TextAlignmentOptions.Center;
                //m_textMeshPro.anchor = AnchorPositions.Center;
                m_textMeshPro.extraPadding = true;
                //m_textMeshPro.outlineWidth = 0.25f;
                //m_textMeshPro.fontSharedMaterial.SetFloat("_OutlineWidth", 0.2f);
                //m_textMeshPro.fontSharedMaterial.EnableKeyword("UNDERLAY_ON");
                //m_textMeshPro.lineJustification = LineJustificationTypes.Center;
                m_textMeshPro.enableWordWrapping = false;    
                //m_textMeshPro.lineLength = 60;          
                //m_textMeshPro.characterSpacing = 0.2f;
                //m_textMeshPro.fontColor = new Color32(255, 255, 255, 255);

                m_material01 = m_textMeshPro.font.material;
                m_material02 = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Drop Shadow"); // Make sure the LiberationSans SDF exists before calling this...  


            }
            else if (BenchmarkType == 1) // TextMesh
            {
                m_textMesh = gameObject.AddComponent<TextMesh>();

                if (TextMeshFont != null)
                {
                    m_textMesh.font = TextMeshFont;
                    m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material;
                }
                else
                {
                    m_textMesh.font = Resources.Load("Fonts/ARIAL", typeof(Font)) as Font;
                    m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material;
                }

                m_textMesh.fontSize = 48;
                m_textMesh.anchor = TextAnchor.MiddleCenter;

                //m_textMesh.color = new Color32(255, 255, 0, 255);
            }



            for (int i = 0; i <= 1000000; i++)
            {
                if (BenchmarkType == 0)
                {
                    m_textMeshPro.SetText(label01, i % 1000);
                    if (i % 1000 == 999)
                        m_textMeshPro.fontSharedMaterial = m_textMeshPro.fontSharedMaterial == m_material01 ? m_textMeshPro.fontSharedMaterial = m_material02 : m_textMeshPro.fontSharedMaterial = m_material01;



                }
                else if (BenchmarkType == 1)
                    m_textMesh.text = label02 + (i % 1000).ToString();

                yield return null;
            }


            yield return null;
        }


        /*
        void Update()
        {
            if (BenchmarkType == 0)
            {
                m_textMeshPro.text = (m_frame % 1000).ToString();
            }
            else if (BenchmarkType == 1)
            {
                m_textMesh.text = (m_frame % 1000).ToString();
            }

            m_frame += 1;
        }
        */
    }
}


==================== CharacterPermanentStats.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Data/CharacterPermanentStats.cs) ====================
// --- 파일명: CharacterPermanentStats.cs ---

using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[System.Serializable]
public class CharacterPermanentStats
{
    public string characterId;

    [Tooltip("테스트 시 해금할 스탯을 여기에 추가하세요. 실제 게임에서는 룰렛을 통해 해금됩니다.")]
    public List<StatType> defaultUnlockedStats = new List<StatType> { StatType.Health, StatType.Attack, StatType.AttackSpeed, StatType.MoveSpeed, StatType.CritMultiplier, StatType.CritRate };

    // [수정] 변수를 선언할 때 바로 new로 초기화해서 Null 참조 예외를 원천적으로 방지
    public Dictionary<StatType, bool> unlockedStatus = new Dictionary<StatType, bool>();
    public Dictionary<StatType, float> investedRatios = new Dictionary<StatType, float>();

    // JSON 저장을 위한 헬퍼 프로퍼티
    public StatDictionaryData statData
    {
        get
        {
            StatDictionaryData data = new StatDictionaryData();
            // unlockedStatus가 null이 아니므로 이제 여기서 에러가 발생하지 않아.
            foreach (var kvp in unlockedStatus)
            {
                data.statTypes.Add(kvp.Key);
                data.unlockedStatuses.Add(kvp.Value);
            }
            foreach (var kvp in investedRatios)
            {
                data.investedRatios.Add(kvp.Value);
            }
            return data;
        }
        set
        {
            unlockedStatus.Clear();
            investedRatios.Clear();
            if (value != null)
            {
                for (int i = 0; i < value.statTypes.Count; i++)
                {
                    unlockedStatus[value.statTypes[i]] = value.unlockedStatuses[i];
                    investedRatios[value.statTypes[i]] = value.investedRatios[i];
                }
            }
        }
    }

    // [수정] JsonUtility가 이 생성자를 사용하지 않으므로, 딕셔너리 초기화 코드는 선언부로 옮기고 여기서는 비워둠.
    public CharacterPermanentStats()
    {
        // 비어 있어도 괜찮아.
    }

    public CharacterPermanentStats(string charId)
    {
        characterId = charId;

        // 모든 스탯을 일단 '잠금' 상태로 초기화
        foreach (StatType type in System.Enum.GetValues(typeof(StatType)))
        {
            unlockedStatus[type] = false;
            investedRatios[type] = 0f;
        }

        // defaultUnlockedStats 리스트에 있는 스탯들만 '해금' 상태로 변경
        foreach (StatType type in defaultUnlockedStats)
        {
            unlockedStatus[type] = true;
        }
    }

    // ... 이하 나머지 코드는 동일 ...

    public List<StatType> GetLockedStats()
    {
        return unlockedStatus.Where(kvp => !kvp.Value).Select(kvp => kvp.Key).ToList();
    }

    public List<StatType> GetUnlockedStats()
    {
        return unlockedStatus.Where(kvp => kvp.Value).Select(kvp => kvp.Key).ToList();
    }

    public bool AllStatsUnlocked()
    {
        return unlockedStatus.Values.All(unlocked => unlocked);
    }

    public void UnlockStat(StatType stat)
    {
        if (unlockedStatus.ContainsKey(stat))
        {
            unlockedStatus[stat] = true;
        }
    }

    public void DistributePoints(int points)
    {
        List<StatType> unlocked = GetUnlockedStats();
        if (unlocked.Count == 0) return;

        for (int i = 0; i < points; i++)
        {
            StatType targetStat = unlocked[Random.Range(0, unlocked.Count)];
            float weight = GetWeightForStat(targetStat);
            investedRatios[targetStat] += weight;
        }
    }

    private float GetWeightForStat(StatType stat)
    {
        switch (stat)
        {
            case StatType.Health: return 0.02f;
            default: return 0.01f;
        }
    }
}

==================== CardDataSO.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Data/CardDataSO.cs) ====================
using UnityEngine;
using System;
using System.Collections.Generic;

// ▼▼▼ 이 내부 클래스들을 먼저 정의합니다. ▼▼▼

[Serializable]
public class BasicInfo
{
    [Tooltip("카드의 고유 ID (예: warrior_basic_001)")]
    public string cardID;
    [Tooltip("UI에 표시될 카드 이름")]
    public string cardName;
    [Tooltip("UI에 표시될 카드 아이콘")]
    public Sprite cardIcon;
    [Tooltip("카드의 타입 (물리 또는 마법)")]
    public CardType type;
    [Tooltip("카드의 희귀도")]
    public CardRarity rarity;
    [Tooltip("카드 효과 설명 텍스트"), TextArea(3, 5)]
    public string effectDescription;
}

[Serializable]
public class StatModifiers
{
    [Tooltip("공격력에 더해지는 % 배율")]
    public float damageMultiplier;
    [Tooltip("공격 속도에 더해지는 % 배율")]
    public float attackSpeedMultiplier;
    [Tooltip("이동 속도에 더해지는 % 배율")]
    public float moveSpeedMultiplier;
    [Tooltip("최대 체력에 더해지는 % 배율")]
    public float healthMultiplier;
    [Tooltip("치명타 확률에 더해지는 % 배율")]
    public float critRateMultiplier;
    [Tooltip("치명타 피해량에 더해지는 % 배율")]
    public float critDamageMultiplier;
}

// ▲▲▲ 내부 클래스 정의 끝 ▲▲▲


[CreateAssetMenu(fileName = "CardData_", menuName = "GameData/CardData")]
public class CardDataSO : ScriptableObject
{
    [Header("1. 기본 정보")]
    public BasicInfo basicInfo;

    [Header("2. 패시브 능력치")]
    public StatModifiers statModifiers;
    
    [Header("3. 옵션 부품 조립 슬롯")]
    [Tooltip("이 카드에 장착할 '옵션(CardEffectSO)' 에셋들의 Addressable ID 목록")]
    public List<string> attachedEffectIDs;

    [Header("4. 메타 정보")]
    [Tooltip("룰렛에서 선택될 확률 가중치")]
    public float selectionWeight = 1f;
    [Tooltip("카드 보상으로 등장할 확률 가중치")]
    public float rewardAppearanceWeight;
    [Tooltip("카드 해금 조건")]
    public string unlockCondition;
}

==================== MonsterDataSo.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Data/MonsterDataSo.cs) ====================
// ϸ: MonsterDataSO.cs
// : Assets/1.Scripts/Data/MonsterDataSO.cs
using UnityEngine;

/// <summary>
///     ͸ ϴ ScriptableObjectԴϴ.
/// ü, ӵ, ݷ,     Ӽ   ϳ   ֽϴ.
/// </summary>
[CreateAssetMenu(fileName = "MonsterData_", menuName = "GameData/MonsterData")]
public class MonsterDataSO : ScriptableObject
{
    [Header("⺻ ")]
    [Tooltip("͸ ã   IDԴϴ. (: slime_normal, goblin_archer)")]
    public string monsterID;

    [Tooltip("  ǥõ ̸Դϴ.")]
    public string monsterName;

    [Header("ɷġ")]
    public float maxHealth = 100f;
    public float moveSpeed = 3f;
    public float contactDamage = 10f;

    [Header("")]
    [Tooltip(" Ͱ    ϼ.")]
    public GameObject prefab; // [] string ٽ GameObject 

    // [Ȯ ] ȹ ޵ پ  ൿ   
    // public enum MonsterBehaviorType { Chase, Flee, Patrol, ExplodeOnDeath }
    // public MonsterBehaviorType behaviorType;
}

==================== ArtifactDataSO.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Data/ArtifactDataSO.cs) ====================
using UnityEngine;

[CreateAssetMenu(fileName = "ArtifactData_", menuName = "GameData/ArtifactData")]
public class ArtifactDataSO : ScriptableObject
{
    [Header("기본 정보")]
    public string artifactID;
    public string artifactName;
    [TextArea(3, 5)]
    public string description;

    [Header("유물 속성")]
    public CardRarity rarity;

    [Header("효과 파라미터")]
    public float attackBoostRatio;
    public float healthBoostRatio;
    public float moveSpeedBoostRatio;
    public float critChanceBoostRatio;
    public float critDamageBoostRatio;
    public float lifestealBoostRatio;

    [Header("슬롯 및 확률 보너스")]
    public int ownedCardSlotBonus;
    public float specificCardTriggerChanceBonus;

    [Header("시각 정보")]
    public Sprite icon;
}

==================== JsonDataClasses.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Data/JsonDataClasses.cs) ====================
using System;
using System.Collections.Generic;
using UnityEngine; // For Sprite, though not directly used in JSON deserialization, useful for context

// 전체 게임 데이터를 담을 JSON 구조의 루트 클래스
[Serializable]
public class GameDataJson
{
    public List<CardDataJson> cards;
    public List<ArtifactDataJson> artifacts;
}

// CardDataSO와 필드를 일치시키는 JSON용 클래스
[Serializable]
public class CardDataJson
{
    public string cardID;
    public string cardName;
    public string iconPath; // Sprite를 대체할 리소스 경로
    public string type; // CardType enum을 string으로 매핑
    public string rarity; // CardRarity enum을 string으로 매핑

    public float damageMultiplier;
    public float attackSpeedMultiplier;
    public float moveSpeedMultiplier;
    public float healthMultiplier;
    public float critRateMultiplier;
    public float critDamageMultiplier;
    public float lifestealPercentage;
    public string effectDescription;

    public string effectType; // CardEffectType enum을 string으로 매핑
    public string triggerType; // TriggerType enum을 string으로 매핑

    public float rewardAppearanceWeight;
    public string unlockCondition;
}

// ArtifactDataSO와 필드를 일치시키는 JSON용 클래스
[Serializable]
public class ArtifactDataJson
{
    public string artifactID;
    public string artifactName;
    public string iconPath; // Sprite를 대체할 리소스 경로
    public string rarity; // CardRarity enum을 string으로 매핑

    public float attackBoostRatio;
    public float healthBoostRatio;
    public float moveSpeedBoostRatio;
    public float critChanceBoostRatio;
    public float critDamageBoostRatio;
    public float lifestealBoostRatio;
    
    // ArtifactDataSO에 추가된 필드들
    public int ownedCardSlotBonus;
    public float specificCardTriggerChanceBonus;
}

// ProgressionManager의 영구 데이터를 저장하기 위한 클래스
[Serializable]
public class ProgressionData
{
    public int knowledgeShards;
    public int genePoints;

    // JsonUtility는 Dictionary를 직접 직렬화할 수 없으므로 List 두 개로 변환하여 저장합니다.
    public List<string> achievementIDs = new List<string>();
    public List<bool> achievementStates = new List<bool>();

    public List<string> bossKillIDs = new List<string>();
    public List<bool> bossKillStates = new List<bool>();

    // 캐릭터별 영구 스탯 데이터
    public List<CharacterPermanentStats> characterPermanentStats = new List<CharacterPermanentStats>();
}

// CharacterPermanentStats 클래스의 Dictionary를 직렬화하기 위한 헬퍼 클래스
[Serializable]
public class StatDictionaryData
{
    public List<StatType> statTypes = new List<StatType>();
    public List<bool> unlockedStatuses = new List<bool>();
    public List<float> investedRatios = new List<float>();
}




==================== PrefabDB.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Data/PrefabDB.cs) ====================
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "PrefabDB", menuName = "GameData/PrefabDB")]
public class PrefabDB : ScriptableObject
{
    [Header("몬스터 프리팹")]
    public List<GameObject> monsterPrefabs;

    [Header("총알 프리팹")]
    public List<GameObject> bulletPrefabs;

    [Header("시각 효과 (VFX) 프리팹")]
    public List<GameObject> vfxPrefabs;
}


==================== AudioCollection.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Data/AudioCollection.cs) ====================
using UnityEngine;

/// <summary>
/// BGM, SFX 등 오디오 클립들을 그룹으로 묶어 관리하는 ScriptableObject.
/// 각 씬이나 상황에 맞는 오디오 세트를 구성하는 데 사용됩니다.
/// </summary>
[CreateAssetMenu(fileName = "NewAudioCollection", menuName = "9th/Audio/Audio Collection")]
public class AudioCollection : ScriptableObject
{
    [Header("배경음악 (BGM)")]
    public AudioClip[] bgmClips;

    [Header("효과음 (SFX)")]
    public AudioClip[] sfxClips;

    /// <summary>
    /// 이름으로 BGM 오디오 클립을 찾습니다.
    /// </summary>
    public AudioClip GetBgmClip(string clipName)
    {
        foreach (var clip in bgmClips)
        {
            if (clip.name == clipName)
            {
                return clip;
            }
        }
        Debug.LogWarning($"'{name}' 컬렉션에 '{clipName}' BGM이 없습니다.");
        return null;
    }

    /// <summary>
    /// 이름으로 SFX 오디오 클립을 찾습니다.
    /// </summary>
    public AudioClip GetSfxClip(string clipName)
    {
        foreach (var clip in sfxClips)
        {
            if (clip.name == clipName)
            {
                return clip;
            }
        }
        Debug.LogWarning($"'{name}' 컬렉션에 '{clipName}' SFX가 없습니다.");
        return null;
    }
}


==================== MapNode.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Data/MapNode.cs) ====================
using System.Collections.Generic;
using UnityEngine;

public enum NodeType { Monster, Elite, Shop, Rest, Boss, Event }

public class MapNode
{
    public NodeType NodeType;
    public Vector2Int Position; //  ڿ ġ (x, y)
    public List<MapNode> NextNodes = new List<MapNode>(); //  忡   ִ  
}

==================== StatusEffectDataSO.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Data/StatusEffectDataSO.cs) ====================
using UnityEngine;

[CreateAssetMenu(fileName = "StatusEffectData_", menuName = "GameData/StatusEffectData")]
public class StatusEffectDataSO : ScriptableObject
{
    [Header("기본 정보")]
    public string effectId;
    public string effectName;
    public Sprite icon;

    [Header("효과 속성")]
    public float duration;
    public bool isBuff;

    [Header("능력치 변경 효과 (백분율, %)")]
    public float damageRatioBonus;
    public float attackSpeedRatioBonus;
    public float moveSpeedRatioBonus;
    public float healthRatioBonus;
    public float critRateRatioBonus;
    public float critDamageRatioBonus;

    [Header("지속 피해/회복 효과")]
    public float damageOverTime;
    public float healOverTime;

    /// <summary>
    /// [리팩토링] 대상 캐릭터에게 이 상태 효과의 능력치 보너스를 적용합니다.
    /// </summary>
    public void ApplyEffect(CharacterStats targetStats)
    {
        if (targetStats == null) return;

        // 각 보너스 값이 0이 아닐 때만 Modifier를 추가합니다.
        if (damageRatioBonus != 0) targetStats.AddModifier(StatType.Attack, new StatModifier(damageRatioBonus, this));
        if (attackSpeedRatioBonus != 0) targetStats.AddModifier(StatType.AttackSpeed, new StatModifier(attackSpeedRatioBonus, this));
        if (moveSpeedRatioBonus != 0) targetStats.AddModifier(StatType.MoveSpeed, new StatModifier(moveSpeedRatioBonus, this));
        if (healthRatioBonus != 0) targetStats.AddModifier(StatType.Health, new StatModifier(healthRatioBonus, this));
        if (critRateRatioBonus != 0) targetStats.AddModifier(StatType.CritRate, new StatModifier(critRateRatioBonus, this));
        if (critDamageRatioBonus != 0) targetStats.AddModifier(StatType.CritMultiplier, new StatModifier(critDamageRatioBonus, this));
    }

    /// <summary>
    /// [리팩토링] 대상 캐릭터에게서 이 상태 효과의 능력치 보너스를 제거합니다.
    /// </summary>
    public void RemoveEffect(CharacterStats targetStats)
    {
        if (targetStats == null) return;

        targetStats.RemoveModifiersFromSource(this);
    }
}

==================== CampaignDataSO.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Data/CampaignDataSO.cs) ====================
// --- ϸ: CampaignDataSO.cs ---
// : Assets/1.Scripts/Data/CampaignDataSO.cs
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "CampaignData_", menuName = "GameData/CampaignData")]
public class CampaignDataSO : ScriptableObject
{
    [Tooltip(" ķ ϴ  Դϴ.  ˴ϴ.")]
    public List<RoundDataSO> rounds;
}

==================== UIGraphicsDB.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Data/UIGraphicsDB.cs) ====================
// UIGraphicsDB.cs
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "UIGraphicsDB", menuName = "GameData/UIGraphics Database")]
public class UIGraphicsDB : ScriptableObject
{
    // --- ̱(Singleton)  ---
    private static UIGraphicsDB _instance;
    public static UIGraphicsDB Instance
    {
        get
        {
            if (_instance == null)
            {
                _instance = Resources.Load<UIGraphicsDB>("UIGraphicsDB");
                if (_instance == null)
                    Debug.LogError("UIGraphicsDB could not be loaded from Resources!");
            }
            return _instance;
        }
    }

    // ---   ---
    [System.Serializable]
    public struct RaritySpriteEntry
    {
        public CardRarity rarity;
        public Sprite sprite;
    }

    public List<RaritySpriteEntry> raritySprites;

    // ---    Լ ---
    private Dictionary<CardRarity, Sprite> raritySpriteDict;

    private void OnEnable()
    {
        // Ʈ ųʸ ȯϿ ˻ ӵ Դϴ.
        raritySpriteDict = raritySprites.ToDictionary(x => x.rarity, x => x.sprite);
    }

    public Sprite GetRaritySprite(CardRarity rarity)
    {
        if (raritySpriteDict != null && raritySpriteDict.TryGetValue(rarity, out Sprite sprite))
        {
            return sprite;
        }
        return null; // شϴ Ʈ  
    }
}

==================== Wave.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Data/Wave.cs) ====================
// --- ���ϸ�: Wave.cs ---
using UnityEngine;

// [�߰�] ���� ����� �����ϴ� enum. �� �κ��� ��� ù ��° ������ �߻��߾�.
public enum SpawnType
{
    Spread, // ������ �ð� ���� ������ ����
    Burst   // �� ���� �͸��� ����
}

[System.Serializable]
public class Wave
{
    [Tooltip("�� ���̺꿡�� ������ ������ ������(SO)�� ���� ���⿡ �����ϼ���.")]
    // [����] string ��� MonsterDataSO�� ���� �����մϴ�.
    public MonsterDataSO monsterData;

    [Tooltip("������ ������ ��")]
    public int count;

    [Tooltip("SpawnType�� Spread�� ��, ù ���ͺ��� ������ ���ͱ��� �����Ǵ� �� �ɸ��� �� �ð��Դϴ�.")]
    public float duration = 10f;

    [Tooltip("�� ���̺갡 ���� �� ���� ���̺갡 ���۵Ǳ������ ��� �ð��Դϴ�.")]
    public float delayAfterWave;

    [Tooltip("���� ��� (Spread: �ð���, Burst: ����)")]
    public SpawnType spawnType;

    // ▼▼▼ [3] 이 줄을 추가하세요. ▼▼▼
    [Tooltip("이 웨이브의 몬스터를 몇 마리 미리 생성할지 정합니다. 0으로 두면 'Count' 값을 따릅니다.")]
    public int preloadCount = 50;
}

==================== CharacterDataSO.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Data/CharacterDataSO.cs) ====================
// --- 파일명: CharacterDataSO.cs ---
using UnityEngine;
using System.Collections.Generic; // List를 사용하기 위해 추가

[CreateAssetMenu(fileName = "CharacterData_", menuName = "GameData/CharacterData")]
public class CharacterDataSO : ScriptableObject
{
    [Header("기본 정보")]
    public string characterId;
    public string characterName;
    public Sprite illustration;
    [TextArea(3, 5)]
    public string description;

    [Header("기본 능력치")]
    public BaseStats baseStats;

    [Header("시작 아이템")]
    public CardDataSO startingCard;
    public List<ArtifactDataSO> startingArtifacts; // [추가] 시작 유물 목록

    [Header("초기 포인트")]
    public int initialAllocationPoints;
}

==================== RoundDataSO.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Data/RoundDataSO.cs) ====================
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "RoundData_", menuName = "GameData/RoundData")]
public class RoundDataSO : ScriptableObject
{
    public float roundDuration = 180f;
    public int killGoal = 100;
    public List<Wave> waves;

}

==================== StatModifier.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Data/StatModifier.cs) ====================
/// <summary>
/// 개별 스탯 보너스에 대한 정보를 담는 클래스입니다.
/// </summary>
public class StatModifier
{
    public readonly float Value; // 보너스 수치 (예: 0.1f는 10%)
    public readonly object Source; // 이 보너스를 제공한 객체 (CardDataSO, ArtifactDataSO 등)

    public StatModifier(float value, object source)
    {
        Value = value;
        Source = source;
    }
}

==================== BaseStats.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Data/BaseStats.cs) ====================
using UnityEngine;

[System.Serializable]
public class BaseStats
{
    public float baseDamage;
    public float baseAttackSpeed;
    public float baseMoveSpeed;
    public float baseHealth;
    public float baseCritRate;
    public float baseCritDamage;
}

==================== CardEffectSO.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Data/CardEffects/CardEffectSO.cs) ====================
using UnityEngine;

/// <summary>
/// 모든 카드 효과 '옵션'의 기반이 되는 추상 ScriptableObject입니다.
/// 각 효과는 이 클래스를 상속받아 자신만의 Execute 로직을 구현해야 합니다.
/// 자식 클래스의 Execute 메소드 최상단에는 자신의 실행을 알리는 디버그 로그를 반드시 추가해야 합니다.
/// 예: Debug.Log($"<color=lime>[{GetType().Name}]</color> '{this.name}' 실행.");
/// </summary>
public abstract class CardEffectSO : ScriptableObject
{
    /// <summary>
    /// 이 효과가 언제 발동될지를 정의합니다.
    /// </summary>
    public enum EffectTrigger
    {
        OnFire,           // 카드가 발사되는 즉시
        OnHit,            // 투사체가 무언가에 명중했을 때
        OnCrit,           // 치명타로 명중했을 때
        OnKill,           // 적을 처치했을 때
        OnLastRicochetHit // 마지막 리코셰(튕김)가 명중했을 때
    }

    [Header("효과 발동 조건")]
    [Tooltip("이 효과가 어떤 시점에 발동될지를 선택합니다.")]
    public EffectTrigger trigger;

    /// <summary>
    /// 이 효과의 실제 로직을 실행하는 메소드입니다.
    /// 자식 클래스에서 이 메소드를 반드시 재정의(override)해야 합니다.
    /// </summary>
    /// <param name="context">효과 실행에 필요한 모든 정보가 담긴 컨텍스트 객체</param>
    public abstract void Execute(EffectContext context);
}

==================== RouteSelectionController.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/RouteSelectionController.cs) ====================
// 파일 경로: Assets/1/Scripts/UI/RouteSelectionController.cs

using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using System.Collections;
using System.Collections.Generic;

/// <summary>
/// 맵 경로 선택 씬의 전체적인 흐름을 제어하는 '조율자(Coordinator)' 클래스입니다.
/// MapManager로부터 맵 데이터를 받아 MapView에 그리도록 지시하고,
/// RewardManager의 상태에 따라 UI 포커스와 버튼 활성화 여부를 결정합니다.
/// </summary>
public class RouteSelectionController : MonoBehaviour
{
    // --- Inspector-Visible Fields --- //
    [Header("제어할 UI 패널")]
    [SerializeField] private GameObject routeSelectPanel;

    [Header("전문 컴포넌트 참조")]
    [SerializeField] private MapView mapView;
    [SerializeField] private AutoFocusScroller autoFocusScroller;

    [Header("포커스 대상 버튼")]
    public Button rewardPageButton;

    // --- Unity Lifecycle Methods --- //
    void Awake()
    {
        ServiceLocator.Register<RouteSelectionController>(this);
    }

    void Start()
    {
        if (routeSelectPanel == null || mapView == null || autoFocusScroller == null)
        {
            Debug.LogError($"[{GetType().Name}] 필요한 UI 컴포넌트가 Inspector에 연결되지 않았습니다!", this.gameObject);
            return;
        }
        mapView.OnNodeSelected += OnNodeClicked;
        routeSelectPanel.SetActive(false); // 시작 시에는 비활성화 상태
    }

    // --- Public Methods --- //

    /// <summary>
    /// 맵 선택 패널을 활성화하고 관련된 모든 UI를 최신 상태로 업데이트합니다.
    /// 다른 UI 관리자(예: CardRewardUIManager)에 의해 호출됩니다.
    /// </summary>
    public void Show()
    {
        Debug.Log($"[{GetType().Name}] Show()가 호출되었습니다. 맵 선택 UI를 활성화합니다.");

        // 맵 뷰를 생성하기 전에, MapManager가 유효한 맵 데이터를 가지고 있는지 다시 확인합니다.
        GenerateMapView();

        routeSelectPanel.SetActive(true);
        UpdateNodeInteractability();
        mapView.SetupAllNodeNavigations(rewardPageButton); // 컨트롤러 네비게이션 설정
        StartCoroutine(SetFocusRoutine()); // 포커스 설정
    }

    /// <summary>
    /// 맵 선택 패널을 비활성화합니다.
    /// </summary>
    public void Hide()
    {
        routeSelectPanel.SetActive(false);
    }

    /// <summary>
    /// '보상 페이지로' 버튼을 클릭했을 때, 다시 카드 보상 UI로 돌아갑니다.
    /// </summary>
    public void GoBackToCardReward()
    {
        Debug.Log($"[{GetType().Name}] '보상 페이지로' 버튼이 클릭되었습니다. 카드 보상 UI로 돌아갑니다.");
        Hide();

        var cardRewardUI = ServiceLocator.Get<CardRewardUIManager>();
        if (cardRewardUI != null)
        {
            cardRewardUI.Show();
        }
    }

    // --- Private Helper Methods --- //

    /// <summary>
    /// MapManager의 데이터를 기반으로 MapView에 맵을 그리도록 지시합니다.
    /// </summary>
    private void GenerateMapView()
    {
        var mapManager = ServiceLocator.Get<MapManager>();

        // [디버깅] 맵이 그려지지 않는 문제의 원인을 찾기 위한 핵심 확인 지점입니다.
        if (mapManager == null || !mapManager.IsMapInitialized)
        {
            Debug.LogError($"[{GetType().Name}] CRITICAL: MapManager를 찾을 수 없거나, 맵 데이터가 초기화되지 않았습니다! (IsMapInitialized: {(mapManager != null ? mapManager.IsMapInitialized.ToString() : "N/A")}). 맵이 그려지지 않을 것입니다.");
            return;
        }

        Debug.Log($"[{GetType().Name}] 유효한 MapManager를 찾았습니다. MapView 생성을 시작합니다.");
        mapView.GenerateMapView(mapManager.AllNodes, mapManager.MapWidth, mapManager.MapHeight);
    }

    /// <summary>
    /// MapView에서 특정 노드가 클릭되었을 때 호출되는 이벤트 핸들러입니다.
    /// </summary>
    // ▼▼▼▼▼ OnNodeClicked 함수를 아래 내용으로 교체 ▼▼▼▼▼
    private void OnNodeClicked(MapNode node)
    {
        // 실제 로직은 코루틴에서 처리하도록 변경
        StartCoroutine(SelectNodeAndPreload(node));
    }

    /// <summary>
    /// 노드 선택 후, 다음 라운드에 필요한 에셋을 프리로드하고 씬을 전환하는 코루틴입니다.
    /// </summary>
    private IEnumerator SelectNodeAndPreload(MapNode node)
    {
        Debug.Log($"[{GetType().Name}] 노드 {node.Position} 선택됨. 다음 라운드 프리로딩을 시작합니다.");

        // 다른 노드를 중복 클릭하는 것을 방지하기 위해 모든 노드 비활성화
        mapView.UpdateNodeInteractability(new List<MapNode>());

        // 필요한 매니저들 가져오기
        var gameManager = ServiceLocator.Get<GameManager>();
        var campaignManager = ServiceLocator.Get<CampaignManager>();
        var mapManager = ServiceLocator.Get<MapManager>();

        // 다음 라운드 데이터 가져오기
        RoundDataSO nextRoundData = campaignManager.GetRoundDataForNode(node);

        // GameManager의 새 프리로더를 호출하고 끝날 때까지 대기
        yield return StartCoroutine(gameManager.PreloadAssetsForRound(nextRoundData, null));

        // 프리로딩이 끝나면 맵 위치를 업데이트하고 씬 전환
        mapManager.MoveToNode(node);
        Hide();
        gameManager.ChangeState(GameManager.GameState.Gameplay);
    }
    // ▲▲▲▲▲ 여기까지 교체 및 추가 ▲▲▲▲▲


    /// <summary>
    /// 현재 플레이어가 이동할 수 있는 노드만 활성화하도록 MapView에 지시합니다.
    /// </summary>
    // ▼▼▼▼▼▼▼▼▼▼▼ [이 함수 전체를 아래 코드로 교체하세요] ▼▼▼▼▼▼▼▼▼▼▼
    private void UpdateNodeInteractability()
    {
        var mapManager = ServiceLocator.Get<MapManager>();
        if (mapManager == null) return;

        List<MapNode> reachableNodes = mapManager.GetReachableNodes();
        mapView.UpdateNodeInteractability(reachableNodes);
    }

    /// <summary>
    /// UI가 활성화된 후, 현재 상황에 맞는 버튼에 자동으로 포커스를 설정하는 코루틴입니다.
    /// </summary>
    private IEnumerator SetFocusRoutine()
    {
        yield return null; // UI가 완전히 활성화될 때까지 한 프레임 대기
        EventSystem.current.SetSelectedGameObject(null);
        GameObject targetObjectToFocus = null;

        // [핵심 로직] RewardManager의 상태를 직접 가져와 '보상 페이지로' 버튼의 활성화 여부를 결정합니다.
        var rewardManager = ServiceLocator.Get<RewardManager>();
        // RewardManager가 없거나, 있더라도 보상 선택이 완료된 상태라면 true가 됩니다.
        bool isRewardSelectionComplete = (rewardManager == null || rewardManager.IsRewardSelectionComplete);

        Debug.Log($"[{GetType().Name}] 포커스 설정 중... RewardManager의 보상 선택 완료 상태: {isRewardSelectionComplete}");

        if (rewardPageButton != null)
        {
            // 보상 선택이 완료되지 않았을 때만 '보상 페이지로' 버튼을 활성화합니다.
            rewardPageButton.gameObject.SetActive(!isRewardSelectionComplete);
        }

        if (isRewardSelectionComplete)
        {
            // 보상 선택이 끝났다면, 선택 가능한 맵 노드 중 가장 왼쪽에 있는 노드에 포커스를 줍니다.
            targetObjectToFocus = mapView.FindLeftmostAvailableNode(ServiceLocator.Get<MapManager>().GetReachableNodes());
            Debug.Log($"[{GetType().Name}] 포커스 대상: 맵 노드 ({(targetObjectToFocus != null ? targetObjectToFocus.name : "없음")})");
        }
        else
        {
            // 아직 보상 선택이 끝나지 않았다면, '보상 페이지로' 버튼에 포커스를 줍니다.
            if (rewardPageButton != null)
            {
                targetObjectToFocus = rewardPageButton.gameObject;
                Debug.Log($"[{GetType().Name}] 포커스 대상: '보상 페이지로' 버튼");
            }
        }

        // 최종적으로 결정된 대상에 포커스를 설정합니다.
        if (targetObjectToFocus != null)
        {
            EventSystem.current.SetSelectedGameObject(targetObjectToFocus);
        }
    }
}

==================== PopupController.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/PopupController.cs) ====================
using UnityEngine;
using TMPro;
using UnityEngine.UI;
using System.Collections;
using System; // Action 사용을 위해 필요

/// <summary>
/// 게임 전체에서 사용될 수 있는 범용 팝업 UI를 관리하는 싱글톤 클래스입니다.
/// 간단한 오류 메시지를 일정 시간 동안 보여주거나, 
/// 사용자에게 확인/취소 선택지를 제공하는 확인(Confirm) 팝업을 생성합니다.
/// </summary>
public class PopupController : MonoBehaviour
{
    [Header("오류 팝업 참조")]
    [SerializeField] private GameObject errorPopupPanel; // 오류 메시지 패널
    [SerializeField] private TextMeshProUGUI errorText; // 오류 메시지 텍스트

    [Header("확인 팝업 참조")]
    [SerializeField] private GameObject confirmPopupPanel; // 확인 팝업 패널
    [SerializeField] private TextMeshProUGUI confirmText; // 확인 메시지 텍스트
    [SerializeField] private Button confirmYesButton; // '예' 버튼
    [SerializeField] private Button confirmNoButton; // '아니오' 버튼

    private Action onConfirmYes; // '예' 버튼 클릭 시 실행될 콜백
    private Action onConfirmNo; // '아니오' 버튼 클릭 시 실행될 콜백

    void Awake()
    {
        if (!ServiceLocator.IsRegistered<PopupController>())
        {
            ServiceLocator.Register<PopupController>(this);
            DontDestroyOnLoad(gameObject);

            // 버튼 리스너 초기화
            confirmYesButton.onClick.AddListener(OnConfirmYesClicked);
            confirmNoButton.onClick.AddListener(OnConfirmNoClicked);

            // 초기에는 모든 팝업을 비활성화
            errorPopupPanel.SetActive(false);
            confirmPopupPanel.SetActive(false);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    /// <summary>
    /// 지정된 시간 동안 오류 메시지 팝업을 표시합니다.
    /// </summary>
    /// <param name="message">표시할 메시지</param>
    /// <param name="duration">표시 시간(초)</param>
    public void ShowError(string message, float duration = 2f)
    {
        errorText.text = message;
        StartCoroutine(ShowErrorRoutine(duration));
    }

    private IEnumerator ShowErrorRoutine(float duration)
    {
        errorPopupPanel.SetActive(true);
        yield return new WaitForSeconds(duration);
        errorPopupPanel.SetActive(false);
    }

    /// <summary>
    /// 확인/취소 버튼이 있는 확인 팝업을 표시합니다.
    /// </summary>
    /// <param name="message">표시할 메시지</param>
    /// <param name="onYes">'예'를 눌렀을 때 실행될 동작</param>
    /// <param name="onNo">'아니오'를 눌렀을 때 실행될 동작 (선택 사항)</param>
    public void ShowConfirm(string message, Action onYes, Action onNo = null)
    {
        confirmText.text = message;
        onConfirmYes = onYes;
        onConfirmNo = onNo;
        confirmPopupPanel.SetActive(true);
    }

    private void OnConfirmYesClicked()
    {
        // '예' 콜백이 있다면 실행
        onConfirmYes?.Invoke();
        confirmPopupPanel.SetActive(false);
    }

    private void OnConfirmNoClicked()
    {
        // '아니오' 콜백이 있다면 실행
        onConfirmNo?.Invoke();
        confirmPopupPanel.SetActive(false);
    }
}


==================== SynthesisPopup.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/SynthesisPopup.cs) ====================
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;
using System;
using TMPro;
using System.Collections; // <-- [1] Coroutine 사용을 위해 추가
using UnityEngine.EventSystems; // <-- [2] EventSystem 사용을 위해 추가

/// <summary>
/// 카드 합성에 사용할 재료를 선택하는 팝업 UI를 제어합니다.
/// </summary>
public class SynthesisPopup : MonoBehaviour
{
    [Header("UI 요소 참조")]
    [SerializeField] private GameObject contentPanel; // 카드들이 표시될 부모 오브젝트
    [SerializeField] private GameObject cardDisplayPrefab; // 재료 카드를 표시할 UI 프리팹 (CardDisplay.cs 포함)
    [SerializeField] private Button confirmButton;
    [SerializeField] private Button cancelButton;
    [SerializeField] private TextMeshProUGUI titleText;

    private Action<CardDataSO> onConfirm; // 확인 시 선택된 카드를 전달할 콜백
    private Action onCancel; // <-- [1] 취소 콜백을 저장할 변수 추가
    private CardDataSO selectedMaterialCard;
    private List<CardDisplay> spawnedCardDisplays = new List<CardDisplay>();

    void Awake()
    {
        confirmButton.onClick.AddListener(OnConfirmClicked);
        cancelButton.onClick.AddListener(OnCancelClicked);
    }

    /// <summary>
    /// 팝업을 초기화하고 재료 카드 목록을 표시합니다.
    /// </summary>
    /// <param name="baseCardName">합성의 기준이 되는 카드 이름</param>
    /// <param name="materialChoices">재료로 사용할 수 있는 카드 목록</param>
    /// <param name="confirmCallback">확인 버튼 클릭 시 실행될 콜백</param>
    public void Initialize(string baseCardName, List<CardDataSO> materialChoices, Action<CardDataSO> confirmCallback, Action onCancelCallback)
    {
        gameObject.SetActive(true);
        onConfirm = confirmCallback;
        onCancel = onCancelCallback; // <-- [3] 전달받은 취소 콜백 저장
        selectedMaterialCard = null;
        UpdateConfirmButton();

        if (titleText != null) titleText.text = $"Select '{baseCardName}' to use as your composite card.";

        // 기존 UI 삭제
        foreach (var display in spawnedCardDisplays) Destroy(display.gameObject);
        spawnedCardDisplays.Clear();
        
        // ▼▼▼▼▼ [3] 포커스 설정을 위한 코루틴을 시작하는 코드 추가 ▼▼▼▼▼
        StartCoroutine(SetInitialPopupFocus());

        // 재료 카드 목록 UI 생성
        foreach (var card in materialChoices)
        {
            GameObject cardUI = Instantiate(cardDisplayPrefab, contentPanel.transform);

            CardDisplay cardDisplay = cardUI.GetComponent<CardDisplay>();
            if (cardDisplay != null)
            {
                cardDisplay.Setup(card);
                // 팝업 내의 카드 클릭 시 OnMaterialCardSelected를 호출하도록 리스너 재설정
                cardDisplay.selectButton.onClick.RemoveAllListeners();
                cardDisplay.selectButton.onClick.AddListener(() => OnMaterialCardSelected(cardDisplay));
                spawnedCardDisplays.Add(cardDisplay);
            }
        }
    }

    /// <summary>
    /// 팝업 내에서 재료 카드가 선택되었을 때 호출됩니다.
    /// </summary>
    private void OnMaterialCardSelected(CardDisplay selectedDisplay)
    {
        selectedMaterialCard = selectedDisplay.GetCurrentCard();

        // 하이라이트 처리
        foreach (var display in spawnedCardDisplays)
        {
            display.SetHighlight(display == selectedDisplay);
        }
        UpdateConfirmButton();
    }

    private void UpdateConfirmButton()
    {
        confirmButton.interactable = (selectedMaterialCard != null);
    }

    private void OnConfirmClicked()
    {
        if (selectedMaterialCard != null)
        {
            onConfirm?.Invoke(selectedMaterialCard);
        }
        gameObject.SetActive(false);
    }

    private void OnCancelClicked()
    {
        onCancel?.Invoke(); // <-- [4] 저장해둔 취소 콜백 실행
        gameObject.SetActive(false);
    }

    // ▼▼▼▼▼ [4] 아래 코루틴 함수 전체를 새로 추가 ▼▼▼▼▼
    /// <summary>
    /// 팝업이 나타난 후, UI 포커스를 팝업 내부의 버튼으로 설정합니다.
    /// </summary>
    private IEnumerator SetInitialPopupFocus()
    {
        // UI 요소들이 완전히 활성화될 시간을 벌기 위해 한 프레임 대기합니다.
        yield return null;

        // EventSystem의 현재 선택된 오브젝트를 null로 초기화하여 이전 포커스를 지웁니다.
        EventSystem.current.SetSelectedGameObject(null);

        // '취소' 버튼이 존재하고 활성화 상태라면, 그곳에 포커스를 맞춥니다.
        if (cancelButton != null && cancelButton.interactable)
        {
            EventSystem.current.SetSelectedGameObject(cancelButton.gameObject);
            Debug.Log("[SynthesisPopup] UI 포커스를 '취소' 버튼으로 설정했습니다.");
        }
    }
}


==================== RewardSceneController.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/RewardSceneController.cs) ====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class RewardSceneController : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}


==================== GeneBoosterRoulette.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/GeneBoosterRoulette.cs) ====================
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;
using TMPro;
using System.Collections;

public class GeneBoosterRoulette : MonoBehaviour
{
    [Header("UI 요소 참조")]
    [SerializeField] private Button spinRouletteButton;
    [SerializeField] private TextMeshProUGUI genePointsText;
    [SerializeField] private TMP_InputField pointsToInvestInput;
    [SerializeField] private Button investButton;
    [SerializeField] private List<GameObject> statUIs;
    [SerializeField] private Image spinRouletteButtonImage;

    private const int ROULETTE_COST = 15;

    private CharacterPermanentStats permanentStats;

    // --- [추가] 서비스 로케이터를 통해 매니저 인스턴스를 저장할 변수 ---
    private ProgressionManager progressionManager;
    private PopupController popupController;

    void Start()
    {
        // --- [추가] 서비스 로케이터를 통해 필요한 매니저를 미리 찾아둡니다. ---
        progressionManager = ServiceLocator.Get<ProgressionManager>();
        popupController = ServiceLocator.Get<PopupController>();
        var gameManager = ServiceLocator.Get<GameManager>();

        string characterId = "warrior";
        if (gameManager != null && gameManager.SelectedCharacter != null)
        {
            characterId = gameManager.SelectedCharacter.characterId;
        }

        permanentStats = progressionManager.GetPermanentStatsFor(characterId);

        spinRouletteButton.onClick.AddListener(SpinRoulette);
        investButton.onClick.AddListener(InvestPoints);

        UpdateUI();
    }

    private void UpdateUI()
    {
        // --- [수정] 미리 찾아둔 progressionManager 변수를 사용합니다. ---
        genePointsText.text = $"보유 포인트: {progressionManager.GenePoints}";

        bool canSpin = progressionManager.GenePoints >= ROULETTE_COST && !permanentStats.AllStatsUnlocked();
        spinRouletteButton.interactable = canSpin;
        if (spinRouletteButtonImage != null)
        {
            spinRouletteButtonImage.color = canSpin ? Color.white : Color.gray;
        }

        investButton.interactable = progressionManager.GenePoints > 0;
    }

    private void SpinRoulette()
    {
        // --- [수정] 미리 찾아둔 변수들을 사용합니다. ---
        if (!progressionManager.SpendCurrency(MetaCurrencyType.GenePoints, ROULETTE_COST))
        {
            if (popupController != null) popupController.ShowError("유전자 포인트가 부족합니다.", 1.5f);
            return;
        }

        List<StatType> availableStats = permanentStats.GetLockedStats();
        if (availableStats.Count == 0)
        {
            if (popupController != null) popupController.ShowError("모든 스탯이 이미 해금되었습니다.", 1.5f);
            return;
        }

        StartCoroutine(SpinRouletteAnimation(availableStats));
    }

    private IEnumerator SpinRouletteAnimation(List<StatType> availableStats)
    {
        spinRouletteButton.interactable = false;
        Debug.Log("룰렛 애니메이션 시작...");

        yield return new WaitForSeconds(2f);

        StatType unlockedStat = availableStats[Random.Range(0, availableStats.Count)];
        permanentStats.UnlockStat(unlockedStat);
        Debug.Log($"룰렛 결과: {unlockedStat} 능력치 해금!");

        spinRouletteButton.interactable = true;
        UpdateUI();
    }

    private void InvestPoints()
    {
        if (!int.TryParse(pointsToInvestInput.text, out int points) || points <= 0)
        {
            // --- [수정] 미리 찾아둔 popupController 변수를 사용합니다. ---
            if (popupController != null) popupController.ShowError("유효한 투자 포인트를 입력하세요.", 1.5f);
            return;
        }

        // --- [수정] 미리 찾아둔 progressionManager 변수를 사용합니다. ---
        points = Mathf.Min(points, progressionManager.GenePoints);

        if (!progressionManager.SpendCurrency(MetaCurrencyType.GenePoints, points))
        {
            if (popupController != null) popupController.ShowError("투자에 필요한 유전자 포인트가 부족합니다.", 1.5f);
            return;
        }

        permanentStats.DistributePoints(points);
        Debug.Log($"{points} 포인트를 해금된 능력치에 랜덤하게 투자했습니다.");

        UpdateUI();
    }
}

==================== OptionsController.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/OptionsController.cs) ====================
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Collections.Generic;

public class OptionsController : MonoBehaviour
{
    [Header("그래픽 설정 참조")]
    [SerializeField] private TMP_Dropdown resolutionDropdown;
    [SerializeField] private Toggle fullscreenToggle;

    [Header("오디오 설정 참조")]
    [SerializeField] private Slider bgmVolumeSlider;
    [SerializeField] private Slider sfxVolumeSlider;

    [Header("언어 및 접근성 참조")]
    [SerializeField] private TMP_Dropdown languageDropdown;
    [SerializeField] private Slider fontSizeSlider;
    [SerializeField] private CanvasScaler mainCanvasScaler;

    private Resolution[] resolutions;

    // --- [추가] AudioManager 인스턴스를 저장할 변수 ---
    private AudioManager audioManager;

    void Start()
    {
        // --- [추가] ServiceLocator를 통해 AudioManager를 찾아옵니다. ---
        audioManager = ServiceLocator.Get<AudioManager>();

        resolutionDropdown.onValueChanged.AddListener(SetResolution);
        fullscreenToggle.onValueChanged.AddListener(SetFullscreen);
        bgmVolumeSlider.onValueChanged.AddListener(SetBgmVolume);
        sfxVolumeSlider.onValueChanged.AddListener(SetSfxVolume);
        languageDropdown.onValueChanged.AddListener(SetLanguage);
        fontSizeSlider.onValueChanged.AddListener(SetFontSize);

        InitializeGraphicsSettings();
        InitializeAudioSettings();
        InitializeAccessibilitySettings();
        LoadSettings();
    }

    private void InitializeGraphicsSettings()
    {
        resolutions = Screen.resolutions;
        resolutionDropdown.ClearOptions();
        List<string> options = new List<string>();
        int currentResolutionIndex = 0;
        for (int i = 0; i < resolutions.Length; i++)
        {
            string option = resolutions[i].width + " x " + resolutions[i].height;
            options.Add(option);
            if (resolutions[i].width == Screen.currentResolution.width &&
                resolutions[i].height == Screen.currentResolution.height)
            {
                currentResolutionIndex = i;
            }
        }
        resolutionDropdown.AddOptions(options);
        resolutionDropdown.value = currentResolutionIndex;
        resolutionDropdown.RefreshShownValue();

        fullscreenToggle.isOn = Screen.fullScreen;
    }

    private void InitializeAudioSettings()
    {
        // --- [수정] 찾아온 audioManager 인스턴스를 사용합니다. ---
        if (audioManager != null)
        {
            bgmVolumeSlider.value = audioManager.GetBgmVolume();
            sfxVolumeSlider.value = audioManager.GetSfxVolume();
        }
    }

    private void InitializeAccessibilitySettings()
    {
        languageDropdown.ClearOptions();
        languageDropdown.AddOptions(new List<string> { "한국어", "English" });
        languageDropdown.value = 0;
        languageDropdown.RefreshShownValue();

        fontSizeSlider.minValue = 0.5f;
        fontSizeSlider.maxValue = 1.5f;
        fontSizeSlider.value = 1.0f;
    }

    public void SetResolution(int resolutionIndex)
    {
        Resolution resolution = resolutions[resolutionIndex];
        Screen.SetResolution(resolution.width, resolution.height, Screen.fullScreen);
        Debug.Log($"해상도 변경: {resolution.width}x{resolution.height}");
        SaveSettings();
    }

    public void SetFullscreen(bool isFullscreen)
    {
        Screen.fullScreen = isFullscreen;
        Debug.Log($"전체화면 모드: {isFullscreen}");
        SaveSettings();
    }

    public void SetBgmVolume(float volume)
    {
        // --- [수정] 찾아온 audioManager 인스턴스를 사용합니다. ---
        if (audioManager != null)
        {
            audioManager.SetVolume(volume, sfxVolumeSlider.value);
        }
        SaveSettings();
    }

    public void SetSfxVolume(float volume)
    {
        // --- [수정] 찾아온 audioManager 인스턴스를 사용합니다. ---
        if (audioManager != null)
        {
            audioManager.SetVolume(bgmVolumeSlider.value, volume);
        }
        SaveSettings();
    }

    public void SetLanguage(int languageIndex)
    {
        string languageCode = languageDropdown.options[languageIndex].text;
        Debug.Log($"언어 변경: {languageCode}");
        SaveSettings();
    }

    public void SetFontSize(float scale)
    {
        if (mainCanvasScaler != null)
        {
            mainCanvasScaler.dynamicPixelsPerUnit = 1.0f * scale;
            Debug.Log($"폰트 크기 변경: {scale}");
        }
        else
        {
            Debug.LogWarning("mainCanvasScaler가 할당되지 않았습니다. 폰트 크기를 변경할 수 없습니다.");
        }
        SaveSettings();
    }

    public void SaveSettings()
    {
        PlayerPrefs.SetInt("ResolutionIndex", resolutionDropdown.value);
        PlayerPrefs.SetInt("Fullscreen", fullscreenToggle.isOn ? 1 : 0);
        PlayerPrefs.SetFloat("BGMVolume", bgmVolumeSlider.value);
        PlayerPrefs.SetFloat("SFXVolume", sfxVolumeSlider.value);
        PlayerPrefs.SetInt("LanguageIndex", languageDropdown.value);
        PlayerPrefs.SetFloat("FontSizeScale", fontSizeSlider.value);
        PlayerPrefs.Save();
        Debug.Log("설정이 저장되었습니다.");
    }

    private void LoadSettings()
    {
        if (PlayerPrefs.HasKey("ResolutionIndex"))
        {
            resolutionDropdown.value = PlayerPrefs.GetInt("ResolutionIndex");
            resolutionDropdown.RefreshShownValue();
            SetResolution(resolutionDropdown.value);
        }
        if (PlayerPrefs.HasKey("Fullscreen"))
        {
            fullscreenToggle.isOn = PlayerPrefs.GetInt("Fullscreen") == 1;
            SetFullscreen(fullscreenToggle.isOn);
        }
        if (PlayerPrefs.HasKey("BGMVolume"))
        {
            bgmVolumeSlider.value = PlayerPrefs.GetFloat("BGMVolume");
            SetBgmVolume(bgmVolumeSlider.value);
        }
        if (PlayerPrefs.HasKey("SFXVolume"))
        {
            sfxVolumeSlider.value = PlayerPrefs.GetFloat("SFXVolume");
            SetSfxVolume(sfxVolumeSlider.value);
        }
        if (PlayerPrefs.HasKey("LanguageIndex"))
        {
            languageDropdown.value = PlayerPrefs.GetInt("LanguageIndex");
            languageDropdown.RefreshShownValue();
            SetLanguage(languageDropdown.value);
        }
        if (PlayerPrefs.HasKey("FontSizeScale"))
        {
            fontSizeSlider.value = PlayerPrefs.GetFloat("FontSizeScale");
            SetFontSize(fontSizeSlider.value);
        }
        Debug.Log("설정을 불러왔습니다.");
    }
}

==================== CodexController.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/CodexController.cs) ====================
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

public class CodexController : MonoBehaviour
{
    [Header("UI 요소 참조")]
    [SerializeField] private GameObject cardCodexPanel;
    [SerializeField] private GameObject artifactCodexPanel;
    [SerializeField] private Button cardTabButton;
    [SerializeField] private Button artifactTabButton;
    [SerializeField] private ScrollRect cardScrollRect;
    [SerializeField] private ScrollRect artifactScrollRect;
    [SerializeField] private GameObject itemInfoPrefab;

    private List<CardDataSO> allCards;
    private List<ArtifactDataSO> allArtifacts;
    private Dictionary<string, CodexItemDisplay> displayedCodexItems = new Dictionary<string, CodexItemDisplay>();

    // --- [추가] 필요한 매니저들을 저장할 변수 ---
    private ProgressionManager progressionManager;
    private PopupController popupController;
    private DataManager dataManager;

    void Awake()
    {
        cardTabButton.onClick.AddListener(ShowCardCodex);
        artifactTabButton.onClick.AddListener(ShowArtifactCodex);

        // --- [추가] Awake에서 매니저들을 미리 찾아옵니다. ---
        progressionManager = ServiceLocator.Get<ProgressionManager>();
        popupController = ServiceLocator.Get<PopupController>();
        dataManager = ServiceLocator.Get<DataManager>();
    }

    void OnEnable()
    {
        LoadData();
        PopulateCodex();
        ShowCardCodex();
    }

    private void LoadData()
    {
        allCards = dataManager.GetAllCards();
        allArtifacts = dataManager.GetAllArtifacts();
    }

    private void PopulateCodex()
    {
        displayedCodexItems.Clear();

        foreach (Transform child in cardScrollRect.content) Destroy(child.gameObject);
        cardScrollRect.content.DetachChildren();

        foreach (var card in allCards)
        {
            GameObject itemUI = Instantiate(itemInfoPrefab, cardScrollRect.content);
            CodexItemDisplay display = itemUI.GetComponent<CodexItemDisplay>();
            if (display != null)
            {
                bool isUnlocked = progressionManager.IsCodexItemUnlocked(card.cardID);
                display.SetupForCard(card, isUnlocked);
                display.SetHintButtonClickListener(card.cardID, PurchaseHint);
                displayedCodexItems[card.cardID] = display;
            }
        }

        foreach (Transform child in artifactScrollRect.content) Destroy(child.gameObject);
        artifactScrollRect.content.DetachChildren();

        if (allArtifacts != null)
        {
            foreach (var artifact in allArtifacts)
            {
                GameObject itemUI = Instantiate(itemInfoPrefab, artifactScrollRect.content);
                CodexItemDisplay display = itemUI.GetComponent<CodexItemDisplay>();
                if (display != null)
                {
                    bool isUnlocked = progressionManager.IsCodexItemUnlocked(artifact.artifactID);
                    display.SetupForArtifact(artifact, isUnlocked);
                    display.SetHintButtonClickListener(artifact.artifactID, PurchaseHint);
                    displayedCodexItems[artifact.artifactID] = display;
                }
            }
        }
        Debug.Log("도감 데이터를 기반으로 UI를 모두 생성했습니다.");
    }

    private void ShowCardCodex()
    {
        cardCodexPanel.SetActive(true);
        artifactCodexPanel.SetActive(false);
        cardTabButton.image.color = Color.white;
        artifactTabButton.image.color = Color.gray;
    }

    private void ShowArtifactCodex()
    {
        cardCodexPanel.SetActive(false);
        artifactCodexPanel.SetActive(true);
        cardTabButton.image.color = Color.gray;
        artifactTabButton.image.color = Color.white;
    }

    public void PurchaseHint(string itemId)
    {
        int hintCost = 10;
        if (progressionManager.SpendCurrency(MetaCurrencyType.KnowledgeShards, hintCost))
        {
            Debug.Log($"{itemId}의 힌트를 구매했습니다.");
            if (displayedCodexItems.TryGetValue(itemId, out CodexItemDisplay display))
            {
                display.ShowHint();
            }
            if (popupController != null) popupController.ShowError("힌트 구매 성공!", 1.5f);
        }
        else
        {
            Debug.LogWarning("힌트 구매에 필요한 지식의 파편이 부족합니다.");
            if (popupController != null) popupController.ShowError("지식의 파편이 부족합니다!", 1.5f);
        }
    }
}

==================== CardDisplay.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/CardDisplay.cs) ====================
// CardDisplay.cs (최종 수정본)
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using UnityEngine.Events;

// [수정] 이벤트가 CardDataSO 대신 CardDisplay 자신을 전달하도록 변경합니다.
[System.Serializable]
public class CardSelectedEvent : UnityEvent<CardDisplay> { }

public class CardDisplay : MonoBehaviour
{
    [Header("UI 요소 참조")]
    [SerializeField] private TextMeshProUGUI nameText;
    [SerializeField] private TextMeshProUGUI descriptionText;
    [SerializeField] private Image cardBackgroundImage;
    [SerializeField] private Image cardIconImage;
    [SerializeField] private Image rarityImage;
    [SerializeField] private Image highlightBorder;

    public Button selectButton;
    public CardSelectedEvent OnCardSelected;

    private CardDataSO currentCard;
    public CardDataSO CurrentCard => currentCard;

    public CardDataSO GetCurrentCard()
    {
        return currentCard;
    }

    public void Setup(CardDataSO cardData)
    {
        currentCard = cardData;

        if (nameText != null) nameText.text = cardData.cardName;
        if (descriptionText != null) descriptionText.text = cardData.effectDescription;
        if (cardIconImage != null && cardData.cardIcon != null)
        {
            cardIconImage.sprite = cardData.cardIcon;
        }
        if (rarityImage != null)
        {
            rarityImage.sprite = UIGraphicsDB.Instance.GetRaritySprite(cardData.rarity);
        }
        if (selectButton != null)
        {
            selectButton.onClick.RemoveAllListeners();
            // [수정] 이벤트 발생 시 카드 데이터(currentCard) 대신 CardDisplay 컴포넌트(this)를 전달합니다.
            selectButton.onClick.AddListener(() => OnCardSelected.Invoke(this));
        }
    }

    public void SetHighlight(bool isSelected)
    {
        if (highlightBorder != null)
        {
            highlightBorder.gameObject.SetActive(isSelected);
        }
    }
}

==================== CharacterSelectUI.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/CharacterSelectUI.cs) ====================
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class CharacterSelectUI : MonoBehaviour
{
    [Header("컨트롤러 참조")]
    [SerializeField] private CharacterSelectController controller;
    [Header("UI 요소 참조")]
    [SerializeField] private TextMeshProUGUI totalPointsText;
    [Header("캐릭터별 일러스트 오브젝트 참조")]
    [SerializeField] private GameObject warriorCharacterIllust;
    [SerializeField] private GameObject archerCharacterIllust;
    [SerializeField] private GameObject mageCharacterIllust;
    [Header("버튼 목록")]
    [SerializeField] private Button warriorButton;
    [SerializeField] private Button archerButton;
    [SerializeField] private Button mageButton;
    [SerializeField] private Button startButton;
    [Header("선택 상태 시각화")]
    [SerializeField] private Color selectedButtonColor = Color.yellow;
    [SerializeField] private Color unselectedButtonColor = Color.white;
    private Button currentlySelectedCharacterButton;

    void Awake()
    {
        warriorButton.onClick.AddListener(() => SelectCharacter(CharacterIDs.Warrior));
        archerButton.onClick.AddListener(() => SelectCharacter(CharacterIDs.Archer));
        mageButton.onClick.AddListener(() => SelectCharacter(CharacterIDs.Mage));
        startButton.onClick.AddListener(OnGameStartClicked);
    }

    void Start()
    {
        DeactivateAllCharacterIllustrations();
        if (totalPointsText != null) totalPointsText.text = "보유 포인트: --";
        ResetButtonColors();
    }

    private void ResetButtonColors()
    {
        warriorButton.image.color = unselectedButtonColor;
        archerButton.image.color = unselectedButtonColor;
        mageButton.image.color = unselectedButtonColor;
        currentlySelectedCharacterButton = null;
    }

    private void DeactivateAllCharacterIllustrations()
    {
        if (warriorCharacterIllust != null) warriorCharacterIllust.SetActive(false);
        if (archerCharacterIllust != null) archerCharacterIllust.SetActive(false);
        if (mageCharacterIllust != null) mageCharacterIllust.SetActive(false);
    }

    private void SelectCharacter(string characterId)
    {
        CharacterDataSO characterData = ServiceLocator.Get<DataManager>().GetCharacter(characterId);
        if (characterData == null) return;

        controller.OnCharacterSelected(characterData);
        UpdateCharacterInfo(characterData);
        DeactivateAllCharacterIllustrations();

        if (currentlySelectedCharacterButton != null)
        {
            currentlySelectedCharacterButton.image.color = unselectedButtonColor;
        }

        switch (characterId)
        {
            case CharacterIDs.Warrior:
                if (warriorCharacterIllust != null) warriorCharacterIllust.SetActive(true);
                currentlySelectedCharacterButton = warriorButton;
                break;
            case CharacterIDs.Archer:
                if (archerCharacterIllust != null) archerCharacterIllust.SetActive(true);
                currentlySelectedCharacterButton = archerButton;
                break;
            case CharacterIDs.Mage:
                if (mageCharacterIllust != null) mageCharacterIllust.SetActive(true);
                currentlySelectedCharacterButton = mageButton;
                break;
        }

        if (currentlySelectedCharacterButton != null)
        {
            currentlySelectedCharacterButton.image.color = selectedButtonColor;
        }
    }

    private void UpdateCharacterInfo(CharacterDataSO characterData)
    {
        if (totalPointsText != null)
        {
            totalPointsText.text = $"보유 포인트: {characterData.initialAllocationPoints}";
        }
    }

    private void OnGameStartClicked()
    {
        controller.ProceedToPointAllocation();
    }
}

==================== HUDController.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/HUDController.cs) ====================
// --- 파일명: HUDController.cs (추적 디버깅 버전) ---
// 역할: HUD의 전체 생명주기를 추적하여 문제의 원인을 찾습니다.
// 수정 내용: Awake, OnEnable, Start, OnDisable, OnDestroy 등 모든 주요 함수에
//           실행 시점을 알리는 디버그 로그를 추가했습니다.
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class HUDController : MonoBehaviour
{
    [SerializeField] private Slider healthBar;
    [SerializeField] private TextMeshProUGUI timerText;
    [SerializeField] private TextMeshProUGUI killCountText;

    private int instanceId;

    // 1. 스크립트 인스턴스가 처음 로드될 때 호출됩니다. (게임 오브젝트가 비활성화 상태여도 호출됨)
    private void Awake()
    {
        // Awake에서 고유한 ID를 생성합니다. GetInstanceID()는 모든 유니티 오브젝트가 가진 고유 번호입니다.
        instanceId = gameObject.GetInstanceID();
        Debug.Log($"[HUD 추적 ID: {instanceId}] {gameObject.name} - Awake() 호출됨. (Frame: {Time.frameCount})");
    }

    private void OnEnable()
    {
        Debug.Log($"[HUD 추적 ID: {instanceId}] {gameObject.name} - OnEnable() 호출됨. 이벤트 구독 시작. (Frame: {Time.frameCount})");
        RoundManager.OnRoundStarted += HandleRoundStarted;
        RoundManager.OnKillCountChanged += UpdateKillCount;
        RoundManager.OnTimerChanged += UpdateTimer;
        RoundManager.OnRoundEnded += HandleRoundEnd;
    }

    private void Start()
    {
        Debug.Log($"[HUD 추적 ID: {instanceId}] {gameObject.name} - Start() 호출됨. (Frame: {Time.frameCount})");
    }

    private void HandleRoundStarted(RoundDataSO roundData)
    {
        // [유령 추적 2] 어떤 HUD가 방송을 수신하는지 확인합니다.
        UpdateKillCount(0, roundData.killGoal);
        UpdateTimer(roundData.roundDuration);
    }

    private void OnDisable()
    {
        RoundManager.OnRoundStarted -= HandleRoundStarted;
        RoundManager.OnKillCountChanged -= UpdateKillCount;
        RoundManager.OnTimerChanged -= UpdateTimer;
        RoundManager.OnRoundEnded -= HandleRoundEnd;
    }

    private void OnDestroy()
    {
        Debug.LogWarning($"[HUD 추적 ID: {instanceId}] {gameObject.name} - OnDestroy() 호출됨! (Frame: {Time.frameCount})");
    }

    // --- UI 업데이트 함수 (변경 없음) ---
    public void UpdateTimer(float time)
    {
        if (timerText == null) return;
        time = Mathf.Max(0, time);
        int minutes = (int)time / 60;
        int seconds = (int)time % 60;
        timerText.text = $"Time : {minutes:00}:{seconds:00}";
    }

    public void UpdateKillCount(int currentKills, int goalKills)
    {
        if (killCountText != null)
        {
            killCountText.text = $"Kills: {currentKills} / {goalKills}";
        }
    }

    private void HandleRoundEnd(bool success)
    {
        Debug.Log($"[HUD 추적] {gameObject.name} - '라운드 종료' 방송 수신. (Frame: {Time.frameCount})");
    }
}


==================== CardRewardUIManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/CardRewardUIManager.cs) ====================
// 파일 경로: Assets/1/Scripts/UI/CardRewardUIManager.cs

using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.EventSystems;

/// <summary>
/// 카드 보상 씬의 UI를 총괄하는 관리자입니다.
/// RewardManager로부터 카드 목록을 받아 화면에 표시하고, 사용자의 선택(획득, 합성, 스킵)을 처리하며,
/// 선택 결과에 따라 다른 UI(맵 선택)로의 전환을 담당합니다.
/// </summary>
public class CardRewardUIManager : MonoBehaviour
{
    // --- Inspector-Visible Fields --- //
    [Header("UI 요소 및 부모")]
    [SerializeField] private GameObject cardDisplayPrefab;
    [SerializeField] private Transform cardSlotsParent;
    
    // ▼▼▼ [1] 이 줄을 추가하세요. ▼▼▼
    [SerializeField] private CanvasGroup cardRewardCanvasGroup;

    [Header("버튼 참조")]
    [SerializeField] private Button acquireButton;
    [SerializeField] private Button synthesizeButton;
    [SerializeField] private Button skipButton;
    [SerializeField] private Button mapButton;

    [Header("팝업 참조")]
    [SerializeField] private SynthesisPopup synthesisPopup;

    // --- Private State Fields --- //
    private CardDisplay selectedDisplay;
    private List<CardDisplay> spawnedCardDisplays = new List<CardDisplay>();
    private GameObject lastSelectedCardObject; // UI 포커스 관리를 위해 마지막으로 선택된 오브젝트를 저장

    // --- Unity Lifecycle Methods --- //
    void Awake()
    {
        ServiceLocator.Register<CardRewardUIManager>(this);

        // 각 버튼에 대한 이벤트 리스너를 연결합니다.
        acquireButton.onClick.AddListener(OnAcquireClicked);
        synthesizeButton.onClick.AddListener(OnSynthesizeClicked);
        skipButton.onClick.AddListener(OnSkipClicked);
        if (mapButton != null) { mapButton.onClick.AddListener(OnMapButtonClicked); }

        Debug.Log("[CardRewardUIManager] Awake: 이벤트 리스너가 성공적으로 연결되었습니다.");
    }

    void OnEnable()
    {
        // RewardManager의 static 이벤트들을 구독하여, 보상이 준비되거나 스킵될 때 적절한 함수가 호출되도록 합니다.
        RewardManager.OnCardRewardReady += Initialize;
        RewardManager.OnRewardSkipped += HandleRewardSkipped;
    }

    void OnDisable()
{
    // 오브젝트가 비활성화될 때, 메모리 누수를 방지하기 위해 구독했던 이벤트를 해제합니다.
    RewardManager.OnCardRewardReady -= Initialize;
    RewardManager.OnRewardSkipped -= HandleRewardSkipped;
}

// ▼▼▼▼▼▼▼▼▼▼▼ [이 부분 추가] ▼▼▼▼▼▼▼▼▼▼▼
/// <summary>
/// 이 UI 오브젝트가 활성화되고 난 후, 첫 프레임에 호출됩니다.
/// </summary>
void Start()
{
    // RewardManager를 찾아 다음 보상 처리를 시작하도록 명시적으로 요청합니다.
    var rewardManager = ServiceLocator.Get<RewardManager>();
    if (rewardManager != null)
    {
        Debug.Log("[CardRewardUIManager] Start: RewardManager에게 보상 처리를 요청합니다.");
        rewardManager.ProcessNextReward();
    }
    else
    {
        Debug.LogError("[CardRewardUIManager] Start에서 RewardManager를 찾을 수 없습니다!");
    }
}
// ▲▲▲▲▲▲▲▲▲▲▲ [여기까지 추가] ▲▲▲▲▲▲▲▲▲▲▲

    // --- Event Handlers --- //
    private void HandleRewardSkipped()
    {
        Debug.Log("[CardRewardUIManager] 보상 스킵 신호(OnRewardSkipped)를 감지했습니다. 맵 선택으로 즉시 이동합니다.");
        TransitionToMap();
    }

    /// <summary>
    /// RewardManager로부터 카드 목록을 받아 보상 UI를 초기화하고 화면에 표시합니다.
    /// </summary>
    public void Initialize(List<CardDataSO> cardChoices)
    {
        Debug.Log($"[CardRewardUIManager] Initialize: {cardChoices.Count}개의 카드 보상으로 UI를 초기화합니다.");

        // 이전에 생성된 카드 UI가 있다면 모두 파괴하여 초기화합니다.
        foreach (Transform child in cardSlotsParent) { Destroy(child.gameObject); }
        spawnedCardDisplays.Clear();

        // 전달받은 카드 데이터 목록을 순회하며 CardDisplay 프리팹을 생성합니다.
        foreach (var cardData in cardChoices)
        {
            GameObject cardUI = Instantiate(cardDisplayPrefab, cardSlotsParent);
            CardDisplay cardDisplay = cardUI.GetComponent<CardDisplay>();
            if (cardDisplay != null)
            {
                cardDisplay.Setup(cardData);
                cardDisplay.OnCardSelected.AddListener(HandleCardSelection);
                spawnedCardDisplays.Add(cardDisplay);
            }
        }

        selectedDisplay = null; // 선택된 카드 없음으로 초기화
        UpdateButtonsState(); // 버튼 상태 업데이트
        // ▼▼▼ [2] 기존 SetInitialFocus 호출 부분을 변경된 이름으로 수정합니다. ▼▼▼
        StartCoroutine(SetFocusToCardCoroutine()); // 첫 번째 카드에 포커스 설정
    }

    /// <summary>
    /// 특정 카드 UI가 선택되었을 때 호출됩니다.
    /// </summary>
    private void HandleCardSelection(CardDisplay display)
    {
        selectedDisplay = display;
        Debug.Log($"[CardRewardUIManager] 카드 선택됨: {display.CurrentCard.cardName}");

        // 모든 카드 UI를 순회하며, 선택된 카드에만 하이라이트 효과를 적용합니다.
        foreach (var d in spawnedCardDisplays)
        {
            bool isSelected = (d == selectedDisplay);
            d.SetHighlight(isSelected);
            if (isSelected) { lastSelectedCardObject = d.gameObject; }
        }
        UpdateButtonsState(); // 버튼 상태 업데이트
    }

    // --- Button Click Handlers --- //
    private void OnAcquireClicked()
    {
        if (selectedDisplay == null)
        {
            Debug.LogWarning("[CardRewardUIManager] OnAcquireClicked: 선택된 카드가 없어 아무것도 하지 않습니다.");
            return;
        }

        CardDataSO selectedCardData = selectedDisplay.CurrentCard;
        Debug.Log($"[CardRewardUIManager] '획득' 버튼 클릭됨. 선택된 카드: {selectedCardData.cardName}");

        // [핵심 로직] CardManager를 통해 실제로 카드를 덱에 추가합니다.
        var cardManager = ServiceLocator.Get<CardManager>();
        if (cardManager != null)
        {
            cardManager.AcquireNewCard(selectedCardData);
            Debug.Log($"[CardRewardUIManager] CardManager를 통해 '{selectedCardData.cardName}' 카드를 성공적으로 획득했습니다.");
        }
        else
        {
            Debug.LogError("[CardRewardUIManager] CRITICAL: CardManager를 찾을 수 없어 카드를 획득할 수 없습니다!");
        }

        // 보상 선택이 완료되었음을 RewardManager에 알립니다.
        ServiceLocator.Get<RewardManager>()?.CompleteRewardSelection();
        
        // ▼▼▼ 디버그 로그 추가 ▼▼▼
        // ServiceLocator를 통해 CardManager에 다시 접근하여 상태 확인
        ServiceLocator.Get<CardManager>().SendMessage("PrintEquippedCards", "TransitionToMap 직전");

        // 맵 선택 화면으로 전환합니다.
        TransitionToMap();
    }

    private void OnSynthesizeClicked()
    {
        if (selectedDisplay == null || !synthesizeButton.interactable) return;
        Debug.Log($"[CardRewardUIManager] '합성' 버튼 클릭됨. 선택된 카드: {selectedDisplay.CurrentCard.cardName}");

        var cardManager = ServiceLocator.Get<CardManager>();
        CardDataSO selectedCardData = selectedDisplay.CurrentCard;
        List<CardDataSO> materialChoices = cardManager.GetSynthesizablePairs(selectedCardData);

        if (materialChoices.Count > 0 && synthesisPopup != null)
        {
            // ▼▼▼ [2] 팝업을 띄우기 전에 뒷쪽 패널의 상호작용을 막습니다. ▼▼▼
            if (cardRewardCanvasGroup != null)
            {
                cardRewardCanvasGroup.interactable = false;
            }

            synthesisPopup.gameObject.SetActive(true);

            // ▼▼▼ [3] 팝업이 닫힐 때 상호작용을 다시 활성화하도록 콜백을 전달합니다. ▼▼▼
            synthesisPopup.Initialize(selectedCardData.cardName, materialChoices, 
            (chosenMaterial) => {
                // 확인 콜백
                Debug.Log($"[CardRewardUIManager] 합성 재료 '{chosenMaterial.cardName}' 선택됨. 합성을 실행합니다.");
                if (cardRewardCanvasGroup != null) cardRewardCanvasGroup.interactable = true;
                cardManager.SynthesizeCards(selectedCardData, chosenMaterial);
                ServiceLocator.Get<RewardManager>()?.CompleteRewardSelection();
                TransitionToMap();
            }, 
            () => {
                // 취소 콜백
                Debug.Log("[CardRewardUIManager] 합성 취소됨.");
                if (cardRewardCanvasGroup != null) cardRewardCanvasGroup.interactable = true;
                // 포커스를 마지막으로 선택했던 합성 버튼으로 되돌립니다.
                EventSystem.current.SetSelectedGameObject(synthesizeButton.gameObject);
            });
        }
    }

    private void OnSkipClicked()
    {
        Debug.Log("[CardRewardUIManager] '스킵' 버튼 클릭됨.");
        ServiceLocator.Get<RewardManager>()?.CompleteRewardSelection();
        TransitionToMap();
    }

    private void OnMapButtonClicked()
    {
        Debug.Log("[CardRewardUIManager] '맵으로' 버튼 클릭됨.");
        TransitionToMap();
    }

    // --- Helper Methods --- //
    private void UpdateButtonsState()
    {
        acquireButton.interactable = (selectedDisplay != null);

        bool canSynthesize = false;
        if (selectedDisplay != null)
        {
            var cardManager = ServiceLocator.Get<CardManager>();
            if (cardManager != null)
            {
                canSynthesize = cardManager.HasSynthesizablePair(selectedDisplay.CurrentCard);
            }
        }
        synthesizeButton.interactable = canSynthesize;
    }

    private void TransitionToMap()
    {
        Debug.Log("[CardRewardUIManager] 맵 선택 화면으로 전환을 시작합니다...");

        var routeSelectionController = ServiceLocator.Get<RouteSelectionController>();
        if (routeSelectionController != null)
        {
            // [핵심 로직] 맵 선택 UI를 활성화합니다.
            routeSelectionController.Show();
        }
        else
        {
            Debug.LogError("[CardRewardUIManager] CRITICAL: RouteSelectionController를 찾을 수 없어 맵 화면으로 전환할 수 없습니다!");
        }

        // [핵심 로직] 전환 후, 자신(카드 보상 UI)은 확실하게 비활성화합니다.
        Hide();
    }

    // ▼▼▼ [1] 기존 SetInitialFocus 코루틴의 이름을 바꾸고 내용을 보강합니다. ▼▼▼
    private IEnumerator SetFocusToCardCoroutine()
    {
        yield return null; // UI 요소가 완전히 생성/활성화될 때까지 한 프레임 대기

        // 마지막으로 선택했던 카드가 있으면 그곳에 포커스를 맞춥니다.
        if (lastSelectedCardObject != null && lastSelectedCardObject.activeInHierarchy)
        {
            EventSystem.current.SetSelectedGameObject(lastSelectedCardObject);
        }
        // 마지막 선택 기록이 없으면, 생성된 카드 목록의 첫 번째에 포커스를 맞춥니다.
        else if (spawnedCardDisplays.Count > 0)
        {
            lastSelectedCardObject = spawnedCardDisplays[0].gameObject;
            EventSystem.current.SetSelectedGameObject(lastSelectedCardObject);
        }
    }

    public void Show() 
    { 
        gameObject.SetActive(true);
        // 맵에서 돌아왔을 때 포커스를 되찾기 위해 코루틴을 호출합니다.
        StartCoroutine(SetFocusToCardCoroutine());
    }
    public void Hide() { gameObject.SetActive(false); }
}

==================== UIPanel.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/UIPanel.cs) ====================
using UnityEngine;

/// <summary>
/// UIManager г ڵ ϴ  ũƮԴϴ.
///  ũƮ  UI г Ʈ GameObject ߰ϼ.
/// </summary>
public class UIPanel : MonoBehaviour
{
    // UIManager г ĺ ̸. Inspector մϴ.
    public string panelName;

    void Awake()
    {
        if (string.IsNullOrEmpty(panelName))
        {
            Debug.LogWarning($"UIPanel ũƮ  '{gameObject.name}' Ʈ 'panelName'  ʾҽϴ. GameObject ̸ մϴ.");
            panelName = gameObject.name;
        }

        // --- [] ServiceLocator  UIManager νϽ ɴϴ. ---
        var uiManager = ServiceLocator.Get<UIManager>();
        if (uiManager != null)
        {
            uiManager.RegisterPanel(panelName, gameObject);
        }
    }

    void OnDestroy()
    {
        // --- [] ServiceLocator  UIManager νϽ ɴϴ. ---
        var uiManager = ServiceLocator.Get<UIManager>();
        if (uiManager != null && !string.IsNullOrEmpty(panelName))
        {
            uiManager.UnregisterPanel(panelName);
        }
    }
}

==================== CodexItemDisplay.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/CodexItemDisplay.cs) ====================
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System;

/// <summary>
/// 도감의 개별 항목(카드 또는 유물) 하나의 UI 표시를 담당합니다.
/// </summary>
public class CodexItemDisplay : MonoBehaviour
{
    [Header("UI 요소 참조")]
    [SerializeField] private TextMeshProUGUI nameText;
    [SerializeField] private TextMeshProUGUI typeText; // 카드의 속성(물리/마법) 또는 "유물" 텍스트
    [SerializeField] private TextMeshProUGUI rarityText; // 등급/희귀도
    [SerializeField] private TextMeshProUGUI descriptionText;
    [SerializeField] private Image itemIcon;
    [SerializeField] private GameObject lockedOverlay; // 잠금 상태일 때 표시할 오버레이
    [SerializeField] private Button hintButton; // 힌트 구매 버튼 (잠금 상태일 때만 활성화)

    private string currentItemId; // 현재 표시 중인 아이템의 ID
    private bool isCurrentlyUnlocked; // 현재 아이템의 해금 상태
    private string unlockedDescription; // 해금된 경우의 실제 설명

    /// <summary>
    /// 힌트 버튼 클릭 시 호출될 콜백을 설정합니다.
    /// </summary>
    public void SetHintButtonClickListener(string itemId, Action<string> onClick)
    {
        currentItemId = itemId;
        if (hintButton != null)
        {
            hintButton.onClick.RemoveAllListeners();
            hintButton.onClick.AddListener(() => onClick?.Invoke(currentItemId));
        }
    }

    /// <summary>
    /// 카드 데이터로 UI를 설정합니다.
    /// </summary>
    public void SetupForCard(CardDataSO card, bool isUnlocked)
    {
        isCurrentlyUnlocked = isUnlocked;
        unlockedDescription = card.effectDescription; // 실제 설명 저장

        if (hintButton != null) hintButton.gameObject.SetActive(!isUnlocked);
        if (lockedOverlay != null) lockedOverlay.SetActive(!isUnlocked);

        if (isUnlocked)
        {
            nameText.text = card.cardName;
            typeText.text = card.type.ToString();
            rarityText.text = card.rarity.ToString();
            descriptionText.text = card.effectDescription;
            // if (itemIcon != null && card.icon != null) itemIcon.sprite = card.icon;
        }
        else
        {
            nameText.text = "????????";
            typeText.text = "";
            rarityText.text = "";
            descriptionText.text = "";
            // if (itemIcon != null) itemIcon.sprite = null;
        }
    }

    /// <summary>
    /// 유물 데이터로 UI를 설정합니다.
    /// </summary>
    public void SetupForArtifact(ArtifactDataSO artifact, bool isUnlocked)
    {
        isCurrentlyUnlocked = isUnlocked;
        unlockedDescription = artifact.description; // 실제 설명 저장

        if (hintButton != null) hintButton.gameObject.SetActive(!isUnlocked);
        if (lockedOverlay != null) lockedOverlay.SetActive(!isUnlocked);

        if (isUnlocked)
        {
            nameText.text = artifact.artifactName;
            typeText.text = "유물";
            rarityText.text = artifact.rarity.ToString();
            descriptionText.text = artifact.description; 
            // if (itemIcon != null && artifact.icon != null) itemIcon.sprite = artifact.icon;
        }
        else
        {
            nameText.text = "????????";
            typeText.text = "";
            rarityText.text = "";
            descriptionText.text = "";
            // if (itemIcon != null) itemIcon.sprite = null;
        }
    }

    /// <summary>
    /// 힌트를 표시합니다. (잠금 상태에서만 호출)
    /// </summary>
    public void ShowHint()
    {
        if (!isCurrentlyUnlocked) // 잠금 상태일 때만 힌트 표시
        {
            descriptionText.text = unlockedDescription; // 실제 설명 표시
            if (hintButton != null) hintButton.gameObject.SetActive(false); // 힌트 버튼 비활성화
        }
    }
}


==================== MapNodeUI.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/MapNodeUI.cs) ====================
using UnityEngine;
using UnityEngine.UI;

// 이 스크립트는 UI 버튼 오브젝트가 어떤 맵 노드 데이터(위치)를
// 가지고 있는지 관리하는 스크립트입니다.
public class MapNodeUI : MonoBehaviour
{
    public MapNode nodeData; // 이 노드 UI가 나타내는 맵 노드 데이터
    
    // [수정됨] Inspector에서 Button 컴포넌트를 연결할 수 있도록 [HideInInspector]를 제거합니다.
    [SerializeField] public Button button; 

    void Awake()
    {
        // [수정됨] 자식 오브젝트에서도 Button 컴포넌트를 찾을 수 있도록 GetComponentInChildren를 사용합니다.
        if (button == null) // Inspector에서 연결되지 않았다면 코드로 찾습니다.
        {
            button = GetComponentInChildren<Button>();
            if (button == null)
            {
                Debug.LogError($"[MapNodeUI] {gameObject.name}에서 Button 컴포넌트를 찾을 수 없습니다! Inspector에서 연결하거나 자식 오브젝트에 Button이 있는지 확인하세요.");
            }
        }
    }
}


==================== MapView.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/MapView.cs) ====================
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;
using System.Linq;

public class MapView : MonoBehaviour
{
    [Header("UI 프리팹")]
    [SerializeField] private GameObject nodePrefab;
    [SerializeField] private GameObject pathPrefab;

    [Header("UI 부모 오브젝트")]
    [SerializeField] private Transform pathParent;
    [SerializeField] private Transform nodeParent;

    [Header("맵 시각화 설정")]
    [SerializeField] private float nodeSpacingX = 200f;
    [SerializeField] private float nodeSpacingY = 120f;
    [SerializeField] private ScrollRect mapScrollRect;

    private Dictionary<MapNode, GameObject> nodeUiMap = new Dictionary<MapNode, GameObject>();

    public event System.Action<MapNode> OnNodeSelected;

    public void GenerateMapView(List<MapNode> mapData, int mapWidth, int intMapHeight)
    {
        Debug.Log("[MapView] GenerateMapView 시작."); // [추가됨] 디버그 로그
        foreach (Transform child in nodeParent) Destroy(child.gameObject); // [수정됨] intMapHeight로 변수명 변경
        foreach (Transform child in pathParent) Destroy(child.gameObject);
        nodeUiMap.Clear();

        float horizontalOffset = (mapWidth - 1) * nodeSpacingX * 0.5f;

        foreach (var nodeData in mapData)
        {
            GameObject nodeObj = Instantiate(nodePrefab, nodeParent);
            RectTransform nodeRect = nodeObj.GetComponent<RectTransform>();
            if (nodeRect != null)
            {
                float posX = nodeData.Position.x * nodeSpacingX - horizontalOffset;
                float posY = nodeData.Position.y * nodeSpacingY;
                nodeRect.anchoredPosition = new Vector2(posX, posY);
            }

            MapNodeUI mapNodeUI = nodeObj.GetComponent<MapNodeUI>();
            if (mapNodeUI != null)
            {
                // [추가됨] MapNodeUI의 button 참조 확인
                if (mapNodeUI.button == null)
                {
                    Debug.LogError($"[MapView] MapNodeUI ({nodeObj.name})에 Button 컴포넌트가 연결되지 않았습니다!");
                }
                else
                {
                    mapNodeUI.nodeData = nodeData;
                    MapNode currentNodeData = nodeData;
                    mapNodeUI.button.onClick.AddListener(() => OnNodeClicked(currentNodeData));
                }
            }
            else
            {
                Debug.LogError($"[MapView] 노드 프리팹 ({nodePrefab.name})에 MapNodeUI 컴포넌트가 없습니다!"); // [추가됨] 디버그 로그
            }

            nodeUiMap.Add(nodeData, nodeObj);
        }

        foreach (var nodeData in mapData)
        {
            if (nodeData.NextNodes.Count > 0)
            {
                GameObject fromObj = nodeUiMap[nodeData];
                foreach (var childNode in nodeData.NextNodes)
                {
                    if (nodeUiMap.ContainsKey(childNode))
                    {
                        DrawPath(fromObj, nodeUiMap[childNode]);
                    }
                }
            }
        }

        RectTransform contentRect = mapScrollRect.content;
        float totalMapHeight = (intMapHeight - 1) * nodeSpacingY; // [수정됨] intMapHeight로 변수명 변경
        contentRect.sizeDelta = new Vector2(contentRect.sizeDelta.x, totalMapHeight + 8000f);
        Debug.Log("[MapView] GenerateMapView 완료."); // [추가됨] 디버그 로그
    }

    private void OnNodeClicked(MapNode node)
    {
        OnNodeSelected?.Invoke(node);
        Debug.Log($"[MapView] OnNodeSelected 이벤트 발생 시도.");
    }

    private void DrawPath(GameObject from, GameObject to)
    {
        GameObject pathObj = Instantiate(pathPrefab, pathParent);
        RectTransform pathRect = pathObj.GetComponent<RectTransform>();
        Image pathImage = pathObj.GetComponent<Image>();

        Vector2 dir = (to.transform.position - from.transform.position).normalized;
        float distance = Vector2.Distance(to.transform.position, from.transform.position);

        pathRect.sizeDelta = new Vector2(distance, pathRect.sizeDelta.y);
        pathRect.position = from.transform.position;
        pathRect.pivot = new Vector2(0, 0.5f);
        pathRect.rotation = Quaternion.FromToRotation(Vector3.right, dir);
        if (pathImage != null) pathImage.type = Image.Type.Tiled;
    }

    /// <summary>
    /// [변경됨] 모든 노드의 네비게이션을 요구사항에 맞게 설정합니다.
    /// </summary>
    public void SetupAllNodeNavigations(Button backButton)
    {
        Debug.Log("[MapView] SetupAllNodeNavigations 시작."); // [추가됨] 디버그 로그
        foreach (var pair in nodeUiMap)
        {
            MapNode currentNodeData = pair.Key;
            GameObject currentNodeObj = pair.Value;
            Button currentBtn = currentNodeObj.GetComponent<Button>();

            if (currentBtn == null)
            {
                Debug.LogError($"[MapView] 노드 오브젝트 {currentNodeObj.name}에 Button 컴포넌트가 없습니다!"); // [추가됨] 디버그 로그
                continue;
            }

            Navigation nav = new Navigation
            {
                mode = Navigation.Mode.Explicit
            };

            var upCandidates = nodeUiMap.Where(p => p.Key.Position.y == currentNodeData.Position.y + 1);
            if (upCandidates.Any()) 
            {
                var targetUp = upCandidates.OrderBy(p => Mathf.Abs(p.Value.transform.position.x - currentNodeObj.transform.position.x)).First();
                nav.selectOnUp = targetUp.Value.GetComponent<Button>();
            }

            var downCandidates = nodeUiMap.Where(p => p.Key.Position.y == currentNodeData.Position.y - 1);
            if (downCandidates.Any())
            {
                var targetDown = downCandidates.OrderBy(p => Mathf.Abs(p.Value.transform.position.x - currentNodeObj.transform.position.x)).First();
                nav.selectOnDown = targetDown.Value.GetComponent<Button>();
            }

            var leftCandidates = nodeUiMap.Where(p => p.Key.Position.y == currentNodeData.Position.y && p.Key.Position.x < currentNodeData.Position.x);
            if (leftCandidates.Any())
            {
                var targetLeft = leftCandidates.OrderByDescending(p => p.Key.Position.x).First();
                nav.selectOnLeft = targetLeft.Value.GetComponent<Button>();
            }
            else
            {
                if (backButton != null && backButton.interactable)
                {
                    nav.selectOnLeft = backButton;
                }
            }

            var rightCandidates = nodeUiMap.Where(p => p.Key.Position.y == currentNodeData.Position.y && p.Key.Position.x > currentNodeData.Position.x);
            if (rightCandidates.Any())
            {
                var targetRight = rightCandidates.OrderBy(p => p.Key.Position.x).First();
                nav.selectOnRight = targetRight.Value.GetComponent<Button>();
            }

            currentBtn.navigation = nav;
        }
        Debug.Log("[MapView] SetupAllNodeNavigations 완료."); // [추가됨] 디버그 로그
    }

    public void UpdateNodeInteractability(List<MapNode> reachableNodes)
    {
        Debug.Log($"[MapView] UpdateNodeInteractability 시작. 도달 가능한 노드 수: {reachableNodes.Count}"); // [추가됨] 디버그 로그
        foreach (var entry in nodeUiMap)
        {
            Button button = entry.Value.GetComponentInChildren<Button>();
            if (button != null)
            {
                bool isInteractable = reachableNodes.Contains(entry.Key);
                button.interactable = isInteractable;
            }
            else
            {
                Debug.LogWarning($"[MapView] 노드 {entry.Key.Position}의 자식에서 Button 컴포넌트를 찾을 수 없습니다."); // [추가됨] 디버그 로그
            }
        }
        Debug.Log("[MapView] UpdateNodeInteractability 완료."); // [추가됨] 디버그 로그
    }

    public GameObject FindClosestNodeTo(Vector3 position)
    {
        if (nodeUiMap.Count == 0) return null;
        return nodeUiMap.OrderBy(p => Vector3.Distance(p.Value.transform.position, position)).First().Value;
    }

    public GameObject FindLeftmostAvailableNode(List<MapNode> reachableNodes)
    {
        if (reachableNodes == null || reachableNodes.Count == 0) return null;

        MapNode leftmostNode = reachableNodes
            .OrderBy(n => n.Position.y)
            .ThenBy(n => n.Position.x)
            .FirstOrDefault();

        if (leftmostNode != null && nodeUiMap.ContainsKey(leftmostNode))
        {
            return nodeUiMap[leftmostNode];
        }
        return null;
    }
}

==================== PlayerHealthBar.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/PlayerHealthBar.cs) ====================
using UnityEngine;
using UnityEngine.UI;

public class PlayerHealthBar : MonoBehaviour
{
    [SerializeField]
    private Slider healthBarSlider;

    void LateUpdate()
    {
        transform.rotation = Quaternion.identity;
    }

    public void UpdateHealth(float currentHealth, float maxHealth)
    {
        if (healthBarSlider != null && maxHealth > 0)
        {
            healthBarSlider.value = currentHealth / maxHealth;
        }
    }
}

==================== MainMenuUI.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/MainMenuUI.cs) ====================
﻿using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class MainMenuUI : MonoBehaviour
{
    [Header("UI 요소 참조")]
    public Button optionsButton;
    public Button startButton;
    public Button codexButton;
    public Button exitButton;
    public TextMeshProUGUI versionInfoText;

    void Start()
    {
        startButton.onClick.AddListener(OnStartButtonClicked);
        optionsButton.onClick.AddListener(OnOptionsButtonClicked);
        codexButton.onClick.AddListener(OnCodexButtonClicked);
        exitButton.onClick.AddListener(OnExitButtonClicked);

        if (versionInfoText != null)
        {
            versionInfoText.text = "Version: " + Application.version;
        }
    }

    public void OnOptionsButtonClicked() { Debug.Log("옵션 버튼 클릭!"); }
    public void OnStartButtonClicked() { ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.CharacterSelect); }
    public void OnCodexButtonClicked() { ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.Codex); }
    public void OnExitButtonClicked() { Application.Quit(); }
}

==================== AutoFocusScroller.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/AutoFocusScroller.cs) ====================
// : Assets/1/Scripts/UI/AutoFocusScroller.cs

using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;

public class AutoFocusScroller : MonoBehaviour
{
    [Header(" ")]
    [SerializeField] private ScrollRect mapScrollRect;
    [SerializeField] private MapView mapView;

    [Header("ũ ")]
    [SerializeField] private float edgeScrollSpeed = 1.0f;
    [SerializeField] private float scrollBoundaryOffset = 50f;

    private Vector3[] viewportCorners = new Vector3[4];

    void Update()
    {
        if (!gameObject.activeInHierarchy) return;

        GameObject rawSelectedObject = EventSystem.current.currentSelectedGameObject;
        if (rawSelectedObject == null) return;


        GameObject closestNode = mapView.FindClosestNodeTo(rawSelectedObject.transform.position);
        if (closestNode == null) return;


        mapScrollRect.viewport.GetWorldCorners(viewportCorners);
        float viewportTopY = viewportCorners[1].y;
        float viewportBottomY = viewportCorners[0].y;

        float nodeY = closestNode.transform.position.y;

        float topBoundary = viewportTopY - scrollBoundaryOffset;
        float bottomBoundary = viewportBottomY + scrollBoundaryOffset;
        
        bool shouldScrollUp = nodeY > topBoundary;
        bool shouldScrollDown = nodeY < bottomBoundary;

        if (shouldScrollUp)
        {
            // --- [ DELTA:  ߵ] ---
            Scroll(1);
        }
        else if (shouldScrollDown)
        {
            // --- [ DELTA:  ߵ] ---
            Scroll(-1);
        }
    }

    private void Scroll(int direction)
    {
        float currentScrollPos = mapScrollRect.verticalNormalizedPosition;
        float newScrollPos = currentScrollPos + (direction * edgeScrollSpeed * Time.unscaledDeltaTime);
        newScrollPos = Mathf.Clamp01(newScrollPos);

        mapScrollRect.verticalNormalizedPosition = newScrollPos;
    }
}

==================== DamageText.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/DamageText.cs) ====================
using UnityEngine;
using System.Collections;
using TMPro;

public class DamageText : MonoBehaviour
{
    [Header("ִϸ̼ ")]
    [Tooltip("ؽƮ Ƣ  ִϸ̼ ü ũ⸦ մϴ. (1 = 100%)")]
    public float animationScale = 1.0f;
    [Tooltip("ִϸ̼ Ǵ ðԴϴ.")]
    public float animationDuration = 0.8f;
    [Tooltip("ؽƮ  ö󰡴 ŸԴϴ.")]
    public float moveUpDistance = 1.5f;

    private TextMeshProUGUI textMesh;
    private PoolManager poolManager;

    private void Awake()
    {
        textMesh = GetComponentInChildren<TextMeshProUGUI>();
        if (textMesh == null)
        {
            Debug.LogError("DamageText: ڽ Ʈ TextMeshProUGUI Ʈ ã  ϴ!");
        }
    }

    void Start()
    {
        // --- [] ServiceLocator  PoolManager ãƿɴϴ. ---
        poolManager = ServiceLocator.Get<PoolManager>();
    }

    public void ShowDamage(float damageAmount)
    {
        if (textMesh == null) return;

        textMesh.text = Mathf.RoundToInt(damageAmount).ToString();
        StartCoroutine(Animate());
    }

    private IEnumerator Animate()
    {
        transform.SetParent(null, true);
        transform.localScale = Vector3.zero;

        Color startColor = textMesh.color;
        startColor.a = 1f;
        textMesh.color = startColor;

        Color endColor = startColor;
        endColor.a = 0f;

        float timer = 0f;
        Vector3 startPosition = transform.position;
        Vector3 targetPosition = startPosition + (Vector3.up * moveUpDistance);

        float popupDuration = 0.1f;
        Vector3 targetScale = Vector3.one * animationScale;

        while (timer < popupDuration)
        {
            transform.localScale = Vector3.Lerp(Vector3.zero, targetScale, timer / popupDuration);
            timer += Time.deltaTime;
            yield return null;
        }
        transform.localScale = targetScale;

        timer = 0f;
        while (timer < animationDuration)
        {
            transform.position = Vector3.Lerp(startPosition, targetPosition, timer / animationDuration);
            textMesh.color = Color.Lerp(startColor, endColor, timer / animationDuration);
            timer += Time.deltaTime;
            yield return null;
        }

        if (poolManager != null)
        {
            poolManager.Release(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }
}

==================== PointAllocationResultUI.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/PointAllocationResultUI.cs) ====================
// --- 파일명: PointAllocationResultUI.cs (최종 수정본) ---

using UnityEngine;
using TMPro;
using System.Collections.Generic;

public class PointAllocationResultUI : MonoBehaviour
{
    // ... (UI 참조 변수들은 이전과 동일) ...
    [SerializeField] private TextMeshProUGUI damageText;
    [SerializeField] private TextMeshProUGUI attackSpeedText;
    [SerializeField] private TextMeshProUGUI moveSpeedText;
    [SerializeField] private TextMeshProUGUI healthText;
    [SerializeField] private TextMeshProUGUI critRateText;
    [SerializeField] private TextMeshProUGUI critDamageText;

    // ✨ [1번 문제 해결] 파라미터를 분배된 포인트 딕셔너리로 변경
    public void UpdateDisplay(BaseStats baseStats, Dictionary<StatType, int> distributedPoints)
    {
        if (distributedPoints == null) // Confirm 전
        {
            damageText.text = $"Base Damage ({baseStats.baseDamage:F0}) + Gene Boost (??) = ???";
            attackSpeedText.text = $"Base Attack Speed ({baseStats.baseAttackSpeed:F1}) + Gene Boost (??) = ???";
            moveSpeedText.text = $"Base Move Speed ({baseStats.baseMoveSpeed:F1}) + Gene Boost (??) = ???";
            healthText.text = $"Base Health ({baseStats.baseHealth:F0}) + Gene Boost (??) = ???";
            critRateText.text = $"Base Crit Rate ({baseStats.baseCritRate:F0}%) + Gene Boost (??) = ???";
            critDamageText.text = $"Base Crit Damage ({baseStats.baseCritDamage:F0}%) + Gene Boost (??) = ???";
        }
        else // Confirm 후
        {
            // 각 스탯에 실제 분배된 포인트 개수를 가져옴
            int attackPoints = distributedPoints[StatType.Attack];
            int attackSpeedPoints = distributedPoints[StatType.AttackSpeed];
            int moveSpeedPoints = distributedPoints[StatType.MoveSpeed];
            int healthPoints = distributedPoints[StatType.Health];
            float baseCritRatePercent = baseStats.baseCritRate / 100f;
            float baseCritDmgPercent = baseStats.baseCritDamage / 100f;
            int critDmgPoints = distributedPoints[StatType.CritMultiplier];

            int critRatePoints = distributedPoints[StatType.CritRate];
            float finalCritRate = baseStats.baseCritRate * (1 + critRatePoints * 0.01f);


            // 최종 능력치 계산
            float finalDamage = baseStats.baseDamage * (1 + attackPoints * 0.01f);
            float finalAttackSpeed = baseStats.baseAttackSpeed * (1 + attackSpeedPoints * 0.01f);
            float finalMoveSpeed = baseStats.baseMoveSpeed * (1 + moveSpeedPoints * 0.01f);
            float finalHealth = baseStats.baseHealth * (1 + healthPoints * 0.02f);
            float finalCritDamage = baseCritDmgPercent * (1 + critDmgPoints * 0.01f);

            // ✨ 실제 분배된 포인트 개수를 UI에 표시
            damageText.text = $"Base Damage ({baseStats.baseDamage:F0}) + Gene Boost ({attackPoints}) = {finalDamage:F2}";
            attackSpeedText.text = $"Base Attack Speed ({baseStats.baseAttackSpeed:F1}) + Gene Boost ({attackSpeedPoints}) = {finalAttackSpeed:F2}";
            moveSpeedText.text = $"Base Move Speed ({baseStats.baseMoveSpeed:F1}) + Gene Boost ({moveSpeedPoints}) = {finalMoveSpeed:F2}";
            healthText.text = $"Base Health ({baseStats.baseHealth:F0}) + Gene Boost ({healthPoints}) = {finalHealth:F2}";
            critRateText.text = $"Base Crit Rate ({baseStats.baseCritRate:F0}%) + Gene Boost ({critRatePoints}) = {finalCritRate:F2}%"; // 포맷을 F2로 변경
            critDamageText.text = $"Base Crit Damage ({baseStats.baseCritDamage:F0}%) + Gene Boost ({critDmgPoints}) = {finalCritDamage * 100:F0}%";
        }
    }
}

==================== CharacterSelectController.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/CharacterSelectController.cs) ====================
using UnityEngine;

/// <summary>
/// 캐릭터 선택 씬의 전체적인 흐름과 상태를 관리하는 컨트롤러입니다.
/// 각 UI 패널(캐릭터 선택, 포인트 분배, 결과)을 제어하고,
/// 선택된 캐릭터 데이터와 분배된 포인트를 다음 씬으로 전달할 준비를 합니다.
/// </summary>
public class CharacterSelectController : MonoBehaviour
{
    public CharacterDataSO SelectedCharacter { get; private set; }
    public int AllocatedPoints { get; private set; }

    void Start()
    {
        // 씬이 시작되면, CharacterSelectUI 스크립트가 붙어있는 패널이 활성화됩니다.
    }

    public void OnCharacterSelected(CharacterDataSO characterData)
    {
        SelectedCharacter = characterData;
        Debug.Log($"[CharSelectController] 캐릭터 선택됨: {SelectedCharacter.characterName}");
    }

    public void ProceedToPointAllocation()
    {
        if (SelectedCharacter == null)
        {
            Debug.LogWarning("[CharSelectController] 캐릭터가 선택되지 않았습니다. 포인트 분배를 진행할 수 없습니다.");
            return;
        }

        ServiceLocator.Get<GameManager>().SelectedCharacter = this.SelectedCharacter;
        // GameManager의 PointAllocation 상태로 전환하도록 수정
        ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.PointAllocation);
    }
}

==================== UIManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/UIManager.cs) ====================
// 파일명: UIManager.cs (리팩토링 완료)
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

/// <summary>
/// 게임 내 UI 패널들을 관리하는 클래스입니다.
/// </summary>
public class UIManager : MonoBehaviour
{
    private Dictionary<string, GameObject> uiPanels = new Dictionary<string, GameObject>();

    void Awake()
    {
        if (!ServiceLocator.IsRegistered<UIManager>())
        {
            ServiceLocator.Register<UIManager>(this);
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void ShowPanel(string panelName, bool isActive)
    {
        if (uiPanels.TryGetValue(panelName, out GameObject panel))
        {
            panel.SetActive(isActive);
            Debug.Log($"UI Panel '{panelName}' set to active: {isActive}");
        }
        else
        {
            Debug.LogWarning($"UI Panel '{panelName}' not found in UIManager.");
        }
    }

    public void ShowPanel(string panelName)
    {
        ShowPanel(panelName, true);
    }

    public void HideAllPanels()
    {
        foreach (var panel in uiPanels.Values)
        {
            panel.SetActive(false);
        }
        Debug.Log("All UI panels hidden.");
    }

    public void RegisterPanel(string panelName, GameObject panelGameObject)
    {
        if (!uiPanels.ContainsKey(panelName))
        {
            uiPanels.Add(panelName, panelGameObject);
            Debug.Log($"UI Panel '{panelName}' registered with UIManager.");
        }
        else
        {
            Debug.LogWarning($"UI Panel '{panelName}' is already registered.");
        }
    }

    public void UnregisterPanel(string panelName)
    {
        if (uiPanels.Remove(panelName))
        {
            Debug.Log($"UI Panel '{panelName}' unregistered from UIManager.");
        }
        else
        {
            Debug.LogWarning($"UI Panel '{panelName}' not found for unregistration.");
        }
    }
}

==================== GameInitiolizer.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/GameInitiolizer.cs) ====================
// ϸ: GameInitializer.cs
using System.Collections;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.SceneManagement;

public class GameInitializer : MonoBehaviour
{
    void Start()
    {
        StartCoroutine(LoadEssentialDataAndProceed());
    }

    private IEnumerator LoadEssentialDataAndProceed()
    {
        // 0. (û) ⿡ ε ȭ UI ǥϴ ڵ带   ֽϴ.
        Debug.Log("[GameInitializer] ʼ  ε մϴ...");

        // 1. Addressables ý ʱȭ (   )
        yield return Addressables.InitializeAsync();

        // 2. ٽ Ŵ յ 񵿱 νϽȭմϴ.
        yield return Addressables.InstantiateAsync(PrefabKeys.Managers);
        yield return Addressables.InstantiateAsync(PrefabKeys.GameplaySession);

        Debug.Log("[GameInitializer] ٽ Ŵ  Ϸ.");

        // 3. DataManager   ε   ٸϴ.
        var dataManager = ServiceLocator.Get<DataManager>();
        if (dataManager != null)
        {
            yield return dataManager.LoadAllDataAsync();
        }

        // 4.  ε  MainMenu  ̵մϴ.
        Debug.Log("[GameInitializer]   ε Ϸ.  ޴ ̵մϴ.");
        SceneManager.LoadScene(SceneNames.MainMenu);
    }
}

==================== UIFeedbackManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/UI/UIFeedbackManager.cs) ====================
using UnityEngine;

public class UIFeedbackManager : MonoBehaviour
{
    void OnEnable()
    {
        MonsterController.OnMonsterDamaged += HandleMonsterDamaged;
    }

    void OnDisable()
    {
        MonsterController.OnMonsterDamaged -= HandleMonsterDamaged;
    }

    private void HandleMonsterDamaged(float damageAmount, Vector3 position)
    {

        // DataManager ��� PrefabProvider�� PoolManager�� ���� ����ϴ� ���� �� ȿ�����Դϴ�.
        if (ServiceLocator.Get<PoolManager>() == null || ServiceLocator.Get<PrefabProvider>() == null) return;

        GameObject damageTextPrefab = ServiceLocator.Get<PrefabProvider>().GetPrefab("DamageTextCanvas");
        if (damageTextPrefab == null) return;

        GameObject textGO = ServiceLocator.Get<PoolManager>().Get(damageTextPrefab);
        if (textGO == null) return;

        textGO.transform.position = position + Vector3.up * 0.5f;

        DamageText damageTextComponent = textGO.GetComponent<DamageText>();
        if (damageTextComponent != null)
        {
            damageTextComponent.ShowDamage(damageAmount);
        }
    }
}

==================== CampaignManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/CampaignManager.cs) ====================
// 파일명: CampaignManager.cs (리팩토링 완료)
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class CampaignManager : MonoBehaviour
{
    [Header("캠페인 목록")]
    [Tooltip("여기에 캠페인으로 사용될 모든 캠페인 SO 목록을 추가하세요.")]
    public List<CampaignDataSO> availableCampaigns;

    private CampaignDataSO currentCampaign;

    void Awake()
    {
        Debug.Log($"[생명주기] {GetType().Name} (ID: {gameObject.GetInstanceID()}) - Awake() 시작. (프레임: {Time.frameCount})");
        if (!ServiceLocator.IsRegistered<CampaignManager>())
        {
            ServiceLocator.Register<CampaignManager>(this);
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    /// <summary>
    /// [주 함수] 사용 가능한 캠페인 중 하나를 무작위로 선택합니다.
    /// </summary>
    public CampaignDataSO SelectRandomCampaign()
    {
        if (availableCampaigns == null || availableCampaigns.Count == 0)
        {
            Debug.LogError("[CampaignManager] 사용 가능한 캠페인이 없습니다!");
            currentCampaign = null;
            return null;
        }

        currentCampaign = availableCampaigns[Random.Range(0, availableCampaigns.Count)];
        Debug.Log($"[CampaignManager] 새로운 캠페인 '{currentCampaign.name}'이(가) 선택되었습니다. (아직 시작은 안 함)");
        return currentCampaign;
    }

    public CampaignDataSO GetCurrentCampaign()
    {
        return currentCampaign;
    }

    /// <summary>
    /// 노드의 Y좌표(인덱스)에 해당하는 라운드 데이터를 반환합니다.
    /// </summary>
    public RoundDataSO GetRoundDataForNode(MapNode node)
    {
        if (currentCampaign == null)
        {
            Debug.LogError("### 오류 ### GetRoundDataForNode 호출: currentCampaign이 null입니다! 인스펙터에 캠페인이 등록되었는지 확인하세요.");
            return null;
        }

        if (node == null) return null;

        int roundIndex = node.Position.y;

        if (roundIndex >= 0 && roundIndex < currentCampaign.rounds.Count)
        {
            Debug.Log($"요청한 노드(Y:{roundIndex})에 맞는 라운드 데이터 '{currentCampaign.rounds[roundIndex].name}'을 반환합니다.");
            return currentCampaign.rounds[roundIndex];
        }
        else
        {
            Debug.LogError($"잘못된 라운드 인덱스({roundIndex})가 요청되었습니다!");
            return null;
        }
    }

    public void ResetCampaign()
    {
    }

    private void OnDestroy()
    {
        Debug.Log($"[생명주기] {GetType().Name} (ID: {gameObject.GetInstanceID()}) - OnDestroy() 시작. (프레임: {Time.frameCount})");
    }
}

==================== ProgressionManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/ProgressionManager.cs) ====================
// 파일명: ProgressionManager.cs (리팩토링 완료)
using UnityEngine;
using System.Collections.Generic;
using System.IO;
using System.Linq;

/// <summary>
/// 메타 프로그레션(도전 과제, 영구 재화 등) 데이터를 관리하고,
/// 관련 시스템에 데이터를 제공하는 중앙 관리자입니다.
/// </summary>
public class ProgressionManager : MonoBehaviour
{
    public int KnowledgeShards { get; private set; }
    public int GenePoints { get; private set; }
    private Dictionary<string, bool> achievementsUnlocked = new Dictionary<string, bool>();
    private Dictionary<string, bool> bossFirstKills = new Dictionary<string, bool>();
    private Dictionary<string, CharacterPermanentStats> permanentStatsDict = new Dictionary<string, CharacterPermanentStats>();

    private string savePath;

    void Awake()
    {
        if (!ServiceLocator.IsRegistered<ProgressionManager>())
        {
            ServiceLocator.Register<ProgressionManager>(this);
            DontDestroyOnLoad(gameObject);

            savePath = Path.Combine(Application.persistentDataPath, "progression.json");
            LoadData();
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void AddCurrency(MetaCurrencyType type, int amount)
    {
        if (amount < 0)
        {
            Debug.LogError("재화는 음수 값을 추가할 수 없습니다.");
            return;
        }

        switch (type)
        {
            case MetaCurrencyType.KnowledgeShards:
                KnowledgeShards += amount;
                Debug.Log($"지식의 파편 {amount} 획득. 현재: {KnowledgeShards}");
                break;
            case MetaCurrencyType.GenePoints:
                GenePoints += amount;
                Debug.Log($"유전자 증폭제 포인트 {amount} 획득. 현재: {GenePoints}");
                break;
        }
        SaveData();
    }

    public bool SpendCurrency(MetaCurrencyType type, int amount)
    {
        if (amount < 0)
        {
            Debug.LogError("재화는 음수 값을 사용할 수 없습니다.");
            return false;
        }

        bool success = false;
        switch (type)
        {
            case MetaCurrencyType.KnowledgeShards:
                if (KnowledgeShards >= amount)
                {
                    KnowledgeShards -= amount;
                    Debug.Log($"지식의 파편 {amount} 사용. 현재: {KnowledgeShards}");
                    success = true;
                }
                break;
            case MetaCurrencyType.GenePoints:
                if (GenePoints >= amount)
                {
                    GenePoints -= amount;
                    Debug.Log($"유전자 증폭제 포인트 {amount} 사용. 현재: {GenePoints}");
                    success = true;
                }
                break;
        }

        if (success)
        {
            SaveData();
            return true;
        }
        else
        {
            Debug.LogWarning($"{type} 재화가 부족하여 {amount}를 사용할 수 없습니다.");
            return false;
        }
    }

    public void TrackAchievement(string achievementID)
    {
        if (!achievementsUnlocked.ContainsKey(achievementID) || achievementsUnlocked[achievementID] == false)
        {
            achievementsUnlocked[achievementID] = true;
            Debug.Log($"도전 과제 달성: {achievementID}");
            SaveData();
        }
    }

    public void RegisterBossFirstKill(string bossID)
    {
        if (!bossFirstKills.ContainsKey(bossID) || bossFirstKills[bossID] == false)
        {
            bossFirstKills[bossID] = true;
            Debug.Log($"보스 최초 처치: {bossID}");
            SaveData();
        }
    }

    public CharacterPermanentStats GetPermanentStatsFor(string characterId)
    {
        if (!permanentStatsDict.TryGetValue(characterId, out var stats))
        {
            stats = new CharacterPermanentStats(characterId);
            permanentStatsDict[characterId] = stats;
            Debug.Log($"{characterId}에 대한 새로운 영구 스탯 데이터를 생성했습니다.");
        }
        return stats;
    }

    public void SaveData()
    {
        ProgressionData data = new ProgressionData
        {
            knowledgeShards = this.KnowledgeShards,
            genePoints = this.GenePoints,
            achievementIDs = achievementsUnlocked.Keys.ToList(),
            achievementStates = achievementsUnlocked.Values.ToList(),
            bossKillIDs = bossFirstKills.Keys.ToList(),
            bossKillStates = bossFirstKills.Values.ToList(),
            characterPermanentStats = permanentStatsDict.Values.ToList()
        };

        string json = JsonUtility.ToJson(data, true);
        File.WriteAllText(savePath, json);
        Debug.Log($"데이터 저장 완료: {savePath}");
    }

    public void LoadData()
    {
        if (File.Exists(savePath))
        {
            string json = File.ReadAllText(savePath);
            ProgressionData data = JsonUtility.FromJson<ProgressionData>(json);

            permanentStatsDict = new Dictionary<string, CharacterPermanentStats>();
            foreach (var stats in data.characterPermanentStats)
            {
                stats.statData = new StatDictionaryData
                {
                    statTypes = stats.statData.statTypes,
                    unlockedStatuses = stats.statData.unlockedStatuses,
                    investedRatios = stats.statData.investedRatios
                };
                permanentStatsDict[stats.characterId] = stats;
            }

            Debug.Log($"데이터 로드 완료: {savePath}");
        }
        else
        {
            Debug.Log("세이브 파일이 없어 새 게임을 시작합니다.");
            KnowledgeShards = 0;
            GenePoints = 0;
            achievementsUnlocked = new Dictionary<string, bool>();
            bossFirstKills = new Dictionary<string, bool>();
            permanentStatsDict = new Dictionary<string, CharacterPermanentStats>();
        }
    }

    private void OnApplicationQuit()
    {
        SaveData();
    }

    public bool IsCodexItemUnlocked(string itemID)
    {
        if (achievementsUnlocked.ContainsKey(itemID) && achievementsUnlocked[itemID])
        {
            return true;
        }
        if (bossFirstKills.ContainsKey(itemID) && bossFirstKills[itemID])
        {
            return true;
        }
        return false;
    }
}

public enum MetaCurrencyType
{
    KnowledgeShards,
    GenePoints
}

==================== SceneNames.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/SceneNames.cs) ====================
/// <summary>
/// 씬 이름들을 상수로 관리하는 클래스입니다.
/// </summary>
public static class SceneNames
{
    public const string MainMenu = "MainMenu";
    public const string CharacterSelect = "CharacterSelect";
    public const string PointAllocation = "PointAllocation";
    public const string GamePlay = "GamePlay";
    public const string CardReward = "CardReward";
    public const string Codex = "Codex";
    public const string Shop = "Shop";
    public const string Rest = "Rest";
    public const string Event = "Event";
    public const string Pause = "Pause"; // Pause는 씬이 아닐 수 있지만, UI 관리 등에서 사용할 수 있어 포함
}

==================== MapManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/MapManager.cs) ====================
// 파일명: MapManager.cs (리팩토링 완료)
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class MapManager : MonoBehaviour
{
    public bool IsMapInitialized { get; private set; }
    public List<MapNode> AllNodes { get; private set; }
    public int MapWidth { get; private set; }
    public int MapHeight { get; private set; }
    public MapNode CurrentNode { get; private set; }

    void Awake()
    {
        // ServiceLocator에 이미 등록된 인스턴스가 있는지 확인
        if (ServiceLocator.IsRegistered<MapManager>())
        {
            // 이미 있다면 나는 중복이므로 스스로 파괴
            Destroy(gameObject);
            return;
        }
        
        // 최초의 인스턴스일 경우, 등록하고 파괴되지 않도록 설정
        ServiceLocator.Register<MapManager>(this);
        DontDestroyOnLoad(gameObject);
    }
    
    /// <summary>
    /// 맵 데이터와 함께 맵의 크기 정보도 받아 초기화합니다.
    /// </summary>
    public void InitializeMap(List<MapNode> mapData, int width, int height)
    {
        AllNodes = mapData;
        MapWidth = width;
        MapHeight = height;
        CurrentNode = AllNodes.FirstOrDefault(n => n.Position.y == 0); // 시작 노드 설정
        IsMapInitialized = true;
        Debug.Log($"[MapManager] 맵 데이터 초기화 완료. (노드 수: {AllNodes.Count}, 너비: {width}, 높이: {height})");
    }

    /// <summary>
    /// 플레이어를 새 노드로 이동시키고, Gameplay 씬으로 전환을 요청합니다.
    /// </summary>
    public void MoveToNode(MapNode node)
    {
        if (AllNodes.Contains(node))
        {
            CurrentNode = node;
            Debug.Log($"[MapManager] 현재 위치를 노드 {node.Position}로 이동했습니다.");
        }
    }

    /// <summary>
    /// [추가된 함수] 씬을 전환하지 않고, 현재 노드 데이터만 업데이트합니다.
    /// </summary>
    public void MoveToNode_OnlyUpdateData(MapNode newNode)
    {
        if (CurrentNode != null && !CurrentNode.NextNodes.Contains(newNode))
        {
            Debug.LogError($"{newNode.Position}은(는) 현재 위치({CurrentNode.Position})에서 이동할 수 없는 노드입니다!");
            return;
        }
        CurrentNode = newNode;
        Debug.Log($"[MapManager] 현재 노드가 {newNode.Position}(으)로 업데이트되었습니다.");
    }

    /// <summary>
    /// 현재 플레이어가 이동할 수 있는 다음 노드들의 리스트를 반환합니다.
    /// </summary>
    public List<MapNode> GetReachableNodes()
    {
        if (CurrentNode == null)
        {
            return AllNodes.Where(node => node.Position.y == 0).ToList();
        }
        return CurrentNode.NextNodes;
    }
}

==================== UICursorManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/UICursorManager.cs) ====================
// ϸ: UICursorManager.cs (丵 Ϸ)
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class UICursorManager : MonoBehaviour
{
    [SerializeField]
    private Image globalCursorImage;

    private Sprite defaultCursorSprite;

    void Awake()
    {
        ServiceLocator.Register<UICursorManager>(this);
        if (globalCursorImage != null)
        {
            defaultCursorSprite = globalCursorImage.sprite;
        }
    }

    void Update()
    {
        if (globalCursorImage == null || EventSystem.current == null) return;

        GameObject selectedObject = EventSystem.current.currentSelectedGameObject;

        if (selectedObject != null)
        {
            globalCursorImage.gameObject.SetActive(true);
            globalCursorImage.rectTransform.position = selectedObject.transform.position;
        }
        else
        {
            globalCursorImage.gameObject.SetActive(false);
        }
    }

    public void ChangeCursorSprite(Sprite newSprite)
    {
        if (globalCursorImage == null) return;
        globalCursorImage.sprite = newSprite;
    }

    public void ResetCursorToDefault()
    {
        if (globalCursorImage == null || defaultCursorSprite == null) return;
        globalCursorImage.sprite = defaultCursorSprite;
    }
}

==================== EffectContext.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/EffectContext.cs) ====================
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// 카드 효과가 실행될 때 필요한 모든 맥락 정보를 담는 데이터 클래스입니다.
/// 이 객체는 EffectExecutor가 생성하여 각 CardEffectSO의 Execute 메소드에 전달합니다.
/// </summary>
public class EffectContext
{
    /// <summary>
    /// 효과를 발동시킨 주체(플레이어)의 CharacterStats입니다.
    /// </summary>
    public CharacterStats Caster;

    /// <summary>
    /// 효과가 시작되는 월드 좌표입니다. (예: 플레이어의 총구, 몬스터의 피격 위치)
    /// </summary>
    public Transform SpawnPoint;

    /// <summary>
    /// 최초 발사 시의 목표 대상입니다. (타겟팅 시스템에 의해 결정됨)
    /// </summary>
    public MonsterController InitialTarget;

    /// <summary>
    /// 효과가 적중한 월드 좌표입니다. (OnHit, OnCrit 등의 트리거에서 사용)
    /// </summary>
    public Vector3 HitPosition;

    /// <summary>
    /// 해당 효과 연쇄 반응에서 발생한 피해량입니다. (흡혈 등에서 사용)
    /// </summary>
    public float DamageDealt;

    /// <summary>
    /// 효과를 발동시킨 피격이 치명타였는지 여부입니다.
    /// </summary>
    public bool IsCritical;
    
    /// <summary>
    /// 효과를 발동시킨 피격으로 대상이 사망했는지 여부입니다.
    /// </summary>
    public bool IsKill;

    /// <summary>
    /// ShotgunPatternSO 같은 '수정' 옵션이 계산한 발사 궤적 목록입니다.
    /// 이 목록이 비어있지 않으면 ProjectileEffectSO는 이 궤적을 사용합니다.
    /// </summary>
    public List<Vector2> FiringDirections = new List<Vector2>();
}

==================== DebugManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/DebugManager.cs) ====================
// 파일명: DebugManager.cs (리팩토링 완료)
using UnityEngine;
using TMPro;
using System.Text;

/// <summary>
/// 개발 및 테스트 편의를 위한 디버그 기능을 관리하는 클래스입니다.
/// F1키로 디버그 UI를 토글하고, 게임 내 주요 변수를 실시간으로 확인하고 조작하는 기능을 제공합니다.
/// </summary>
public class DebugManager : MonoBehaviour
{
    [Header("디버그 UI 참조")]
    [SerializeField] private GameObject debugPanel;
    [SerializeField] private TextMeshProUGUI infoText;

    [Header("디버그 기능 설정")]
    [SerializeField] private float healthToAdd = 50f;

    private bool isDebugModeEnabled = false;
    private CharacterStats playerStats; // 외부에서 등록받을 플레이어 스탯 참조
    private StringBuilder infoBuilder = new StringBuilder();

    void Awake()
    {
        if (!ServiceLocator.IsRegistered<DebugManager>())
        {
            ServiceLocator.Register<DebugManager>(this);
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    void Start()
    {
        if (debugPanel != null) debugPanel.SetActive(false);
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.F1))
        {
            ToggleDebugMode();
        }
        if (isDebugModeEnabled && debugPanel != null)
        {
            UpdateDebugInfo();
        }
    }

    public void ToggleDebugMode()
    {
        isDebugModeEnabled = !isDebugModeEnabled;
        if (debugPanel != null) debugPanel.SetActive(isDebugModeEnabled);
        Debug.Log($"디버그 모드: {(isDebugModeEnabled ? "활성화" : "비활성화")}");
    }

    // --- 외부 컴포넌트 등록/해제 메서드 ---

    /// <summary>
    /// PlayerStats 컴포넌트를 디버그 매니저에 등록합니다.
    /// </summary>
    public void RegisterPlayer(CharacterStats player)
    {
        playerStats = player;
        Debug.Log("[DebugManager] PlayerStats 등록됨.");
    }

    /// <summary>
    /// 등록된 PlayerStats 컴포넌트를 해제합니다.
    /// </summary>
    public void UnregisterPlayer()
    {
        playerStats = null;
        Debug.Log("[DebugManager] PlayerStats 등록 해제됨.");
    }

    private void UpdateDebugInfo()
    {
        if (infoText == null) return;
        infoBuilder.Clear();

        if (playerStats != null)
        {
            infoBuilder.AppendLine("--- Player Stats ---");
            infoBuilder.AppendLine($"Health: {playerStats.currentHealth:F1} / {playerStats.FinalHealth:F1}");
            infoBuilder.AppendLine($"Is Invulnerable: {playerStats.isInvulnerable}");
            infoBuilder.AppendLine($"Damage: {playerStats.FinalDamage:F2}");
            infoBuilder.AppendLine($"Attack Speed: {playerStats.FinalAttackSpeed:F2}");
            infoBuilder.AppendLine($"Move Speed: {playerStats.FinalMoveSpeed:F2}");
            infoBuilder.AppendLine($"Crit Rate: {playerStats.FinalCritRate:P2}");
            infoBuilder.AppendLine($"Crit Damage: {playerStats.FinalCritDamage:P2}");
        }
        else
        {
            infoBuilder.AppendLine("PlayerStats not registered.");
        }

        infoBuilder.AppendLine("--- Game Info ---");

        // ▼▼▼ 이 부분을 ▼▼▼
        // infoBuilder.AppendLine($"Active Monsters: {FindObjectsOfType<MonsterController>().Length}");

        // ▼▼▼ 아래처럼 바꾸세요! ▼▼▼
        var monsterManager = ServiceLocator.Get<MonsterManager>();
        if (monsterManager != null)
        {
            infoBuilder.AppendLine($"Active Monsters: {monsterManager.ActiveMonsters.Count}");
        }

        infoText.text = infoBuilder.ToString();
    }

    // --- 디버그 UI의 버튼/슬라이더와 연결될 메서드들 ---

    public void GodMode(bool isOn)
    {
        if (playerStats != null)
        {
            playerStats.isInvulnerable = isOn;
            Debug.Log($"갓 모드: {isOn}");
        }
    }

    public void AddPlayerHealth()
    {
        if (playerStats != null)
        {
            playerStats.Heal(healthToAdd);
            Debug.Log($"플레이어 체력 {healthToAdd} 증가");
        }
    }

    public void KillAllMonsters()
    {
        MonsterController[] monsters = FindObjectsOfType<MonsterController>();
        foreach (var monster in monsters)
        {
            monster.TakeDamage(monster.currentHealth);
        }
        Debug.Log($"{monsters.Length}마리의 몬스터를 처치했습니다.");
    }
}

==================== ResourcePaths.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/ResourcePaths.cs) ====================
// 파일명: ResourcePaths.cs
public static class ResourcePaths
{
    public const string CardData = "CardData";
    public const string ArtifactData = "ArtifactData";
    public const string CharacterData = "CharacterData";
    public const string MonsterData = "MonsterData";
}

==================== DataManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/DataManager.cs) ====================
// --- 파일명: DataManager.cs (역할 축소) ---
// 경로: Assets/1.Scripts/Core/DataManager.cs
using UnityEngine;
using System.Collections.Generic;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;
using System.Collections;

public class DataManager : MonoBehaviour
{
    void Awake()
    {
        if (!ServiceLocator.IsRegistered<DataManager>())
        {
            ServiceLocator.Register<DataManager>(this);
            DontDestroyOnLoad(gameObject);
            StartCoroutine(LoadAllDataAsync());
        }
        else
        {
            Destroy(gameObject);
        }
    }

    // [삭제] 프리팹 관련 필드 모두 삭제

    private readonly Dictionary<string, CardDataSO> cardDataDict = new Dictionary<string, CardDataSO>();
    private readonly Dictionary<string, ArtifactDataSO> artifactDataDict = new Dictionary<string, ArtifactDataSO>();
    private readonly Dictionary<string, CharacterDataSO> characterDict = new Dictionary<string, CharacterDataSO>();
    private readonly Dictionary<string, MonsterDataSO> monsterDataDict = new Dictionary<string, MonsterDataSO>();

    // ▼▼▼ [3] 기존 InitializeDataSOs 함수를 아래 내용으로 완전히 교체합니다. ▼▼▼
    public IEnumerator LoadAllDataAsync()
    {
        Debug.Log("[DataManager] 모든 ScriptableObject 데이터 비동기 로드 시작...");

        var cardHandle = Addressables.LoadAssetsAsync<CardDataSO>("data_card", null);
        var artifactHandle = Addressables.LoadAssetsAsync<ArtifactDataSO>("data_artifact", null);
        var characterHandle = Addressables.LoadAssetsAsync<CharacterDataSO>("data_character", null);
        var monsterHandle = Addressables.LoadAssetsAsync<MonsterDataSO>("data_monster", null);

        var groupHandle = Addressables.ResourceManager.CreateGenericGroupOperation(
            new List<AsyncOperationHandle> { cardHandle, artifactHandle, characterHandle, monsterHandle }, true);

        yield return groupHandle;

        if (groupHandle.Status == AsyncOperationStatus.Succeeded)
        {
            foreach (var card in cardHandle.Result) { if (!cardDataDict.ContainsKey(card.cardID)) cardDataDict.Add(card.cardID, card); }
            foreach (var artifact in artifactHandle.Result) { if (!artifactDataDict.ContainsKey(artifact.artifactID)) artifactDataDict.Add(artifact.artifactID, artifact); }
            foreach (var character in characterHandle.Result) { if (!characterDict.ContainsKey(character.characterId)) characterDict.Add(character.characterId, character); }
            foreach (var monster in monsterHandle.Result) { if (!monsterDataDict.ContainsKey(monster.monsterID)) monsterDataDict.Add(monster.monsterID, monster); }
            
            Debug.Log("[DataManager] 모든 ScriptableObject 데이터 로드 완료.");
        }
        else
        {
            Debug.LogError("[DataManager] ScriptableObject 데이터 로딩 실패!");
        }
        
        Addressables.Release(cardHandle);
        Addressables.Release(artifactHandle);
        Addressables.Release(characterHandle);
        Addressables.Release(monsterHandle);
    }

    // [삭제] Get...Prefab 메서드들 삭제

    public CardDataSO GetCard(string id) => GetData(id, cardDataDict);
    public ArtifactDataSO GetArtifact(string id) => GetData(id, artifactDataDict);
    public CharacterDataSO GetCharacter(string id) => GetData(id, characterDict);
    public MonsterDataSO GetMonsterData(string id) => GetData(id, monsterDataDict);

    private T GetData<T>(string id, Dictionary<string, T> sourceDict) where T : class
    {
        sourceDict.TryGetValue(id, out T data);
        return data;
    }

    public List<CardDataSO> GetAllCards() => new List<CardDataSO>(cardDataDict.Values);
    public List<ArtifactDataSO> GetAllArtifacts() => new List<ArtifactDataSO>(artifactDataDict.Values);

    }


==================== CameraFollow.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/CameraFollow.cs) ====================
using UnityEngine;

public class CameraFollow : MonoBehaviour
{
    public Transform target; // ī޶   (÷̾)
    public float smoothSpeed = 0.125f; // ī޶ 󰡴 ε巯 
    public Vector3 offset; // ī޶   Ÿ

    // ÷̾    Ŀ ī޶ ̵ LateUpdate մϴ.
    void LateUpdate()
    {
        if (target != null)
        {
            Vector3 desiredPosition = target.position + offset;
            Vector3 smoothedPosition = Vector3.Lerp(transform.position, desiredPosition, smoothSpeed);
            transform.position = smoothedPosition;
        }
    }
}

==================== MonsterManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/MonsterManager.cs) ====================
// ϸ: MonsterManager.cs
using System.Collections.Generic;
using UnityEngine;

public class MonsterManager : MonoBehaviour
{
    private readonly List<MonsterController> activeMonsters = new List<MonsterController>();
    public IReadOnlyList<MonsterController> ActiveMonsters => activeMonsters;

    void Awake()
    {
        ServiceLocator.Register<MonsterManager>(this);
        //  Ŵ _GameplaySession տ ־θ DontDestroyOnLoad ʿ ϴ.
    }

    public void RegisterMonster(MonsterController monster)
    {
        if (!activeMonsters.Contains(monster))
        {
            activeMonsters.Add(monster);
        }
    }

    public void UnregisterMonster(MonsterController monster)
    {
        if (activeMonsters.Contains(monster))
        {
            activeMonsters.Remove(monster);
        }
    }
}

==================== TargetingSystem.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/TargetingSystem.cs) ====================
// --- ϸ: TargetingSystem.cs ---

using UnityEngine;
using System.Linq;
using System.Collections.Generic; // Added for IReadOnlyList

public static class TargetingSystem
{
    public static Transform FindTarget(TargetingType type, Transform origin)
    {
        var monsterManager = ServiceLocator.Get<MonsterManager>();
        if (monsterManager == null) return null;

        var activeMonsters = monsterManager.ActiveMonsters;
        if (activeMonsters.Count == 0) return null;

        switch (type)
        {
            case TargetingType.Nearest:
                return activeMonsters.OrderBy(m => Vector3.Distance(origin.position, m.transform.position)).FirstOrDefault()?.transform;

            case TargetingType.HighestHealth:
                // [] Yǥ    currentHealth  ü    ã 
                return activeMonsters.OrderByDescending(m => m.currentHealth).FirstOrDefault()?.transform;

            case TargetingType.LowestHealth:
                // [] Yǥ    currentHealth  ü    ã 
                return activeMonsters.OrderBy(m => m.currentHealth).FirstOrDefault()?.transform;

            case TargetingType.Random:
                return activeMonsters[Random.Range(0, activeMonsters.Count)].transform; // Changed .Length to .Count

            case TargetingType.Forward:
            default:
                return null;
        }
    }
}

==================== SceneTransitionManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/SceneTransitionManager.cs) ====================
﻿// 파일명: SceneTransitionManager.cs (리팩토링 완료)
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;
using System.Collections;

public class SceneTransitionManager : MonoBehaviour
{
    private Image fadeOverlay;

    private void Awake()
    {
        if (!ServiceLocator.IsRegistered<SceneTransitionManager>())
        {
            ServiceLocator.Register<SceneTransitionManager>(this);
            DontDestroyOnLoad(gameObject);
            InitializeFadeOverlay();
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void InitializeFadeOverlay()
    {
        GameObject canvasGo = new GameObject("SceneTransitionCanvas");
        canvasGo.transform.SetParent(this.transform);
        Canvas canvas = canvasGo.AddComponent<Canvas>();
        canvas.renderMode = RenderMode.ScreenSpaceOverlay;
        canvas.sortingOrder = 999;

        canvasGo.AddComponent<CanvasScaler>().uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;

        GameObject imageGo = new GameObject("FadeOverlayImage");
        imageGo.transform.SetParent(canvasGo.transform);
        fadeOverlay = imageGo.AddComponent<Image>();

        RectTransform rt = fadeOverlay.rectTransform;
        rt.anchorMin = Vector2.zero;
        rt.anchorMax = Vector2.one;
        rt.offsetMin = Vector2.zero;
        rt.offsetMax = Vector2.zero;

        fadeOverlay.color = new Color(0, 0, 0, 0);
        fadeOverlay.raycastTarget = false;
        fadeOverlay.gameObject.SetActive(false);
    }

    public void LoadScene(string sceneName)
    {
        StopAllCoroutines();
        StartCoroutine(FadeOutAndLoad(sceneName));
    }

    private IEnumerator FadeIn()
    {
        fadeOverlay.gameObject.SetActive(true);
        float t = 1f;
        while (t > 0f)
        {
            t -= Time.unscaledDeltaTime;
            fadeOverlay.color = new Color(0, 0, 0, t);
            yield return null;
        }
        fadeOverlay.gameObject.SetActive(false);
    }

    private IEnumerator FadeOutAndLoad(string sceneName)
    {
        SceneManager.sceneLoaded += OnSceneLoaded;

        fadeOverlay.gameObject.SetActive(true);
        float t = 0f;
        while (t < 1f)
        {
            t += Time.unscaledDeltaTime;
            fadeOverlay.color = new Color(0, 0, 0, t);
            yield return null;
        }

        SceneManager.LoadScene(sceneName);
    }

    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        SceneManager.sceneLoaded -= OnSceneLoaded;
        StartCoroutine(FadeIn());
    }
}

==================== EffectExecutor.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/EffectExecutor.cs) ====================
// [리팩토링 완료]
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;

public class EffectExecutor : MonoBehaviour
{
    private Dictionary<CardEffectType, ICardEffectHandler> effectHandlers;

    void Awake()
    {
        Debug.Log($"[생명주기] {GetType().Name} (ID: {gameObject.GetInstanceID()}) - Awake() 시작. (프레임: {Time.frameCount})");
        if (!ServiceLocator.IsRegistered<EffectExecutor>())
        {
            ServiceLocator.Register<EffectExecutor>(this);
            DontDestroyOnLoad(gameObject);
            InitializeHandlers();
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void InitializeHandlers()
    {
        effectHandlers = new Dictionary<CardEffectType, ICardEffectHandler>
        {
            { CardEffectType.SplitShot, new SplitShotHandler() },
            { CardEffectType.Wave, new WaveHandler() },
            { CardEffectType.Lightning, new LightningHandler() }
        };
    }

    // [리팩토링] 시전자(Caster)의 정보를 직접 매개변수로 받습니다.
    public void Execute(CardDataSO cardData, CharacterStats casterStats, Transform spawnPoint, float actualDamageDealt = 0f)
    {
        if (cardData == null || casterStats == null || spawnPoint == null)
        {
            Debug.LogError("[EffectExecutor] 필수 인자(CardData, CasterStats, SpawnPoint) 중 하나가 null입니다!");
            return;
        }

        

        // 카드 효과 타입에 따른 핸들러 실행
        if (effectHandlers.TryGetValue(cardData.effectType, out ICardEffectHandler handler))
        { 
            // 핸들러에게도 시전자 정보를 넘겨주어야 할 수 있습니다. (지금은 EffectExecutor만 넘김)
            handler.Execute(cardData, this, casterStats, spawnPoint);
        }
        else
        {
            Debug.LogError($"[EffectExecutor] '{cardData.effectType}' 타입에 대한 핸들러가 등록되어 있지 않습니다!");
        }
    }

    // [리팩토링] 데미지 계산 시에도 시전자의 스탯을 직접 받습니다.
    public float CalculateTotalDamage(CardDataSO cardData, CharacterStats casterStats)
    {
        if (casterStats == null || cardData == null)
        {
            return cardData != null ? cardData.baseDamage : 0f;
        }

        if (cardData.baseDamage <= 0)
        {
            return 0f;
        }

        // CharacterStats의 FinalDamage가 이제 '총 공격력 보너스'를 의미합니다.
        float totalAttackBonus = casterStats.FinalDamage;

        // 최종 대미지 = 카드 기본 대미지 * (1 + 총 공격력 보너스 / 100)
        float finalDamage = cardData.baseDamage * (1 + totalAttackBonus / 100f);

        return finalDamage;
    }

    // [리팩토링] 타겟팅 각도 계산 시에도 시전자의 위치 정보가 필요합니다.
    public float GetTargetingAngle(TargetingType targetingType, Transform casterTransform, Transform spawnPoint)
    {
        if (casterTransform == null || spawnPoint == null)
        {
             Debug.LogError("[EffectExecutor] GetTargetingAngle: casterTransform 또는 spawnPoint가 null입니다!");
            return 0f;
        }

        Transform target = TargetingSystem.FindTarget(targetingType, casterTransform);

        if (target != null)
        {
            Vector2 directionToTarget = (target.position - spawnPoint.position).normalized;
            return Mathf.Atan2(directionToTarget.y, directionToTarget.x) * Mathf.Rad2Deg;
        }
        else
        {
            return spawnPoint.eulerAngles.z;
        }
    }

    private void OnDestroy()
    {
        Debug.Log($"[생명주기] {GetType().Name} (ID: {gameObject.GetInstanceID()}) - OnDestroy() 시작. (프레임: {Time.frameCount})");
    }
}

==================== ServiceLocator.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/ServiceLocator.cs) ====================
// 파일명: ServiceLocator.cs (Unregister 메소드 추가)
using System;
using System.Collections.Generic;
using UnityEngine;

public static class ServiceLocator
{
    private static readonly Dictionary<Type, object> services = new Dictionary<Type, object>();

    // ▼▼▼ 이 부분을 새로 추가하세요 ▼▼▼
    // static 생성자는 클래스가 처음 사용될 때 딱 한 번 호출됩니다.
    static ServiceLocator()
    {
        // Unity 에디터가 종료되거나 플레이 모드가 중지될 때 Clear 서비스를 호출하도록 등록합니다.
        Application.quitting += Clear;
    }
    // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

    /// <summary>
    /// 특정 타입의 서비스가 이미 등록되어 있는지 확인합니다.
    /// </summary>
    public static bool IsRegistered<T>()
    {
        return services.ContainsKey(typeof(T));
    }

    public static void Register<T>(T service)
    {
        Type type = typeof(T);
        if (services.ContainsKey(type))
        {
            Debug.LogWarning($"[ServiceLocator] '{type.Name}' 서비스가 이미 등록되어 있습니다. 덮어씁니다.");
            services[type] = service;
        }
        else
        {
            services.Add(type, service);
            Debug.Log($"[ServiceLocator] '{type.Name}' 서비스가 새로 등록되었습니다.");
        }
    }

    public static T Get<T>()
    {
        Type type = typeof(T);
        if (!services.TryGetValue(type, out object service))
        {
            Debug.LogError($"[ServiceLocator] '{type.Name}' 타입의 서비스를 찾을 수 없습니다!");
            return default;
        }
        return (T)service;
    }

    /// <summary>
    /// [추가된 메소드] 특정 타입의 서비스를 등록 해제합니다.
    /// PlayerController처럼 씬이 변경될 때 파괴되는 객체를 위해 필요합니다.
    /// </summary>
    public static void Unregister<T>(T service)
    {
        Type type = typeof(T);
        if (services.ContainsKey(type) && services[type].Equals(service))
        {
            services.Remove(type);
            Debug.Log($"[ServiceLocator] '{type.Name}' 서비스가 등록 해제되었습니다.");
        }
    }

    public static void Clear()
    {
        services.Clear();
    }
}

==================== Tags.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/Tags.cs) ====================
// 파일명: Tags.cs
public static class Tags
{
    public const string Player = "Player";
    public const string Monster = "Monster";
}

==================== Enums.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/Enums.cs) ====================
public enum CardType
{
    Physical, 
    Magical
}

public enum CardRarity
{
    Common,
    Rare,
    Epic,
    Legendary
}

public enum TriggerType
{
    Interval,
    OnHit,
    OnCrit,
    OnSkillUse,
    OnLowHealth
}

public enum CardEffectType
{
    
    SplitShot,  // 분열샷
    Wave,       // 파동
    Lightning,  // 번개
    Spiral      // 나선형 발사
}

public enum StatType
{
    Attack,
    AttackSpeed,
    MoveSpeed,
    Health,
    CritMultiplier,
    CritRate
}

public enum TargetingType
{
    Forward,
    Nearest,
    HighestHealth,
    LowestHealth,
    Random
}


==================== AudioManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/AudioManager.cs) ====================
// 파일명: AudioManager.cs (리팩토링 완료)
using UnityEngine;

public class AudioManager : MonoBehaviour
{
    [Header("오디오 소스 (Audio Sources)")]
    [SerializeField] private AudioSource bgmSource;
    [SerializeField] private AudioSource sfxSource;

    private AudioCollection currentCollection;

    void Awake()
    {
        // ServiceLocator에 이미 등록된 인스턴스가 있는지 확인
        if (ServiceLocator.IsRegistered<AudioManager>())
        {
            // 이미 있다면 나는 중복이므로 스스로 파괴
            Destroy(gameObject);
            return;
        }
        
        // 최초의 인스턴스일 경우, 등록하고 파괴되지 않도록 설정
        ServiceLocator.Register<AudioManager>(this);
        DontDestroyOnLoad(gameObject);
    }

    public void LoadCollection(AudioCollection newCollection)
    {
        currentCollection = newCollection;
    }

    public void PlayBgm(string clipName, bool loop = true)
    {
        if (currentCollection == null)
        {
            Debug.LogWarning("AudioManager: 재생할 AudioCollection이 로드되지 않았습니다!");
            return;
        }

        AudioClip clipToPlay = currentCollection.GetBgmClip(clipName);
        if (clipToPlay != null)
        {
            bgmSource.clip = clipToPlay;
            bgmSource.loop = loop;
            bgmSource.Play();
        }
    }

    public void PlaySfx(string clipName)
    {
        if (currentCollection == null)
        {
            Debug.LogWarning("AudioManager: 재생할 AudioCollection이 로드되지 않았습니다!");
            return;
        }

        AudioClip clipToPlay = currentCollection.GetSfxClip(clipName);
        if (clipToPlay != null)
        {
            sfxSource.PlayOneShot(clipToPlay);
        }
    }

    public void StopBgm()
    {
        bgmSource.Stop();
    }

    public void SetVolume(float bgmVol, float sfxVol)
    {
        bgmSource.volume = bgmVol;
        sfxSource.volume = sfxVol;
    }

    public float GetBgmVolume() => bgmSource.volume;
    public float GetSfxVolume() => sfxSource.volume;
}

==================== GameManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/GameManager.cs) ====================
// 파일명: GameManager.cs (리팩토링 완료)
using System;
using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;
using UnityEngine.SceneManagement;

public class GameManager : MonoBehaviour
{

    public enum GameState { MainMenu, CharacterSelect, PointAllocation, Gameplay, Reward, Pause, Codex, GameOver, Shop, Rest, Event }
    public GameState CurrentState { get; private set; }
    public CharacterDataSO SelectedCharacter { get; set; }
    public int AllocatedPoints { get; set; }
    public bool isFirstRound = true;

    public event System.Action<GameState> OnGameStateChanged;

    private SceneTransitionManager sceneTransitionManager;
    

    private void Awake()
    {
        Debug.Log($"[GameManager] Awake() 호출됨. (ID: {GetInstanceID()})");
        if (!ServiceLocator.IsRegistered<GameManager>())
        {
            ServiceLocator.Register<GameManager>(this);
            DontDestroyOnLoad(transform.root.gameObject);
            SceneManager.sceneLoaded += OnSceneLoaded;
        }
        else
        {
            Destroy(transform.root.gameObject);
        }
    }
    private void OnDestroy()
    {
        Debug.Log($"[생명주기] GameManager (ID: {GetInstanceID()}) - OnDestroy() 호출됨.");
        SceneManager.sceneLoaded -= OnSceneLoaded;
    }

    private void OnEnable()
    {
        Debug.Log($"[GameManager] OnEnable() 호출됨. (ID: {GetInstanceID()})");
        Debug.Log($"[생명주기] GameManager (ID: {GetInstanceID()}) - OnEnable() 호출됨.");
    }

    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        Debug.Log($"[GameManager] '{scene.name}' 씬 로드 완료. Mode: {mode}");
        if (CurrentState == GameState.Gameplay && mode == LoadSceneMode.Single)
        {
            StartCoroutine(StartRoundAfterSceneLoad());
        }
    }

    private void Start()
    {
        sceneTransitionManager = ServiceLocator.Get<SceneTransitionManager>();
        if (sceneTransitionManager == null) Debug.LogError("!!! GameManager: SceneTransitionManager를 찾을 수 없음!!!");
    }

    public void ChangeState(GameState newState)
    {
        if (CurrentState == newState && CurrentState != GameState.Gameplay) return;

        Debug.Log($"[GameManager] 상태 변경: {CurrentState} -> {newState}");
        CurrentState = newState;
        OnGameStateChanged?.Invoke(newState);

        if (newState == GameState.Pause)
        {
            Time.timeScale = 0;
            return;
        }
        else if (newState == GameState.GameOver)
        {
            StartCoroutine(GameOverRoutine());
            return;
        }

        Time.timeScale = 1;

        string sceneName = GetSceneNameForState(newState);
        if (newState == GameState.Gameplay)
        {
            sceneName = SceneNames.GamePlay;
        }

        if (!string.IsNullOrEmpty(sceneName))
        {
            Debug.Log($"[GameManager] 씬 로드 요청: {sceneName}");
            sceneTransitionManager.LoadScene(sceneName);
        }
    }

    private string GetSceneNameForState(GameState state)
    {
        switch (state)
        {
            case GameState.MainMenu: return SceneNames.MainMenu;
            case GameState.CharacterSelect: return SceneNames.CharacterSelect;
            case GameState.PointAllocation: return SceneNames.PointAllocation;
            case GameState.Reward: return SceneNames.CardReward;
            case GameState.Codex: return SceneNames.Codex;
            case GameState.Shop: return SceneNames.Shop;
            case GameState.Rest: return SceneNames.Rest;
            case GameState.Event: return SceneNames.Event;
            default: return "";
        }
    }

    /// <summary>
    /// 지정된 라운드 데이터와 현재 장착 카드를 기반으로 필요한 에셋만 동적으로 프리로드합니다.
    /// </summary>
    public IEnumerator PreloadAssetsForRound(RoundDataSO roundData, System.Action onComplete)
    {
        Debug.Log("--- [GameManager] 동적 리소스 프리로딩 시작 ---");
        var poolManager = ServiceLocator.Get<PoolManager>();
        if (poolManager == null) { /* ... null 체크 ... */ yield break; }

        // 프리로드할 프리팹과, 요청된 최대 개수를 저장할 딕셔너리
        var preloadRequests = new Dictionary<GameObject, int>();

        // 헬퍼 함수: 딕셔너리에 프리로드 요청을 추가/갱신 (더 큰 값으로)
        void AddOrUpdatePreloadRequest(GameObject prefab, int count)
        {
            if (prefab == null) return;
            if (preloadRequests.ContainsKey(prefab))
            {
                // 이미 요청이 있다면, 더 큰 값으로 갱신
                preloadRequests[prefab] = Mathf.Max(preloadRequests[prefab], count);
            }
            else
            {
                preloadRequests.Add(prefab, count);
            }
        }

        // --- 데이터 수집 단계 ---

        // 1. 공용 프리팹 수집 (PrefabProvider)
        var prefabProvider = ServiceLocator.Get<PrefabProvider>();
        if (prefabProvider != null)
        {
            foreach (var item in prefabProvider.GetCommonPreloadItems())
            {
                AddOrUpdatePreloadRequest(item.prefab, item.count);
            }
        }

        // 2. 다음 라운드 몬스터 수집 (RoundData)
        if (roundData != null && roundData.waves != null)
        {
            foreach (var wave in roundData.waves)
            {
                if (wave.monsterData != null && wave.monsterData.prefab != null)
                {
                    // preloadCount가 0이면 웨이브의 전체 몬스터 수(count)를 사용
                    int count = wave.preloadCount > 0 ? wave.preloadCount : wave.count;
                    AddOrUpdatePreloadRequest(wave.monsterData.prefab, count);
                }
            }
        }

        // 3. 현재 장착 카드 프리팹 수집 (CardManager)
        var cardManager = ServiceLocator.Get<CardManager>();
        if (cardManager != null)
        {
            // ▼▼▼ 디버그 로그 수정 ▼▼▼
            cardManager.SendMessage("PrintEquippedCards", "PreloadAssetsForRound 시점");

            foreach (var card in cardManager.equippedCards)
            {
                AddOrUpdatePreloadRequest(card.bulletPrefab, card.bulletPreloadCount);
                AddOrUpdatePreloadRequest(card.effectPrefab, card.effectPreloadCount);
            }
        }

        // --- 프리로드 실행 단계 ---
        Debug.Log($"[GameManager] 총 {preloadRequests.Count} 종류의 프리팹에 대한 프리로드를 실행합니다.");
        foreach (var request in preloadRequests)
        {
            poolManager.Preload(request.Key, request.Value);
        }
        
        yield return null;
        Debug.Log("--- [GameManager] 동적 프리로딩 완료 ---");
        onComplete?.Invoke();
    }

    private IEnumerator GameOverRoutine()
    {
        // ▼▼▼ [추가] 씬을 전환하기 전에 모든 풀링된 오브젝트를 파괴합니다. ▼▼▼
        var poolManager = ServiceLocator.Get<PoolManager>();
        if (poolManager != null)
        {
            poolManager.DestroyAllPooledObjects();
        }
        // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

        var popupController = ServiceLocator.Get<PopupController>();
        if (popupController != null)
        {
            popupController.ShowError("GAME OVER", 3f);
        }
        yield return new WaitForSecondsRealtime(3f); // Use real-time seconds
        Time.timeScale = 1; // Resume game time before changing scene

        // ▼▼▼ 메인 메뉴 씬으로 바꾸기 직전에 이 부분을 추가하세요! ▼▼▼
        var cardManager = ServiceLocator.Get<CardManager>();
        if (cardManager != null)
        {
            cardManager.ClearAndResetDeck(); // 카드 매니저 초기화
        }

        // 만약 ArtifactManager도 초기화해야 한다면 비슷한 함수를 만들어 호출합니다.
        // var artifactManager = ServiceLocator.Get<ArtifactManager>();
        // if (artifactManager != null)
        // {
        //     artifactManager.ClearAndResetArtifacts(); 
        // }

        isFirstRound = true; // '첫 라운드'라는 표시도 다시 true로!

        ChangeState(GameState.MainMenu);
    }

    private IEnumerator StartRoundAfterSceneLoad()
    {
        Debug.Log("--- [GameManager] StartRoundAfterSceneLoad 코루틴 시작 ---");

        var mapManager = ServiceLocator.Get<MapManager>();
        var campaignManager = ServiceLocator.Get<CampaignManager>();

#if UNITY_EDITOR
        if (mapManager == null || !mapManager.IsMapInitialized)
        {
            Debug.LogWarning("[GameManager] 테스트 모드 감지: 필수 데이터 자동 설정 시작...");
            MapGenerator mapGenerator = FindObjectOfType<MapGenerator>();
            if (mapGenerator != null)
            {
                List<MapNode> mapData = mapGenerator.Generate();
                mapManager.InitializeMap(mapData, mapGenerator.MapWidth, mapGenerator.MapHeight);
                Debug.Log("[GameManager] 테스트용 맵 데이터 생성 및 초기화 완료.");
            }
            else
            {
                Debug.LogError("[GameManager] 테스트 모드 설정 실패: 씬에서 MapGenerator를 찾을 수 없습니다!");
                yield break;
            }

            if (SelectedCharacter == null)
            {
                SelectedCharacter = ServiceLocator.Get<DataManager>().GetCharacter(CharacterIDs.Warrior);
                Debug.Log("[GameManager] 테스트용 기본 캐릭터 'warrior' 설정 완료.");
            }
            AllocatedPoints = 0;
            isFirstRound = true;
        }
#endif
        yield return null;

        float timeout = 5f;
        float timer = 0f;
        RoundManager roundManager = null;
        while (roundManager == null || mapManager == null || campaignManager == null)
        {
            roundManager = FindObjectOfType<RoundManager>();
            timer += Time.deltaTime;
            if (timer > timeout)
            {
                Debug.LogError("[GameManager] 시간 초과! 씬 내 매니저(Round, Map, Campaign) 중 하나를 찾을 수 없습니다.");
                yield break;
            }
            yield return null;
        }
        Debug.Log("1. [GameManager] 모든 매니저 인스턴스를 성공적으로 찾았습니다.");

        timer = 0f;
        while (!mapManager.IsMapInitialized)
        {
            timer += Time.deltaTime;
            if (timer > timeout)
            {
                Debug.LogError("[GameManager] 시간 초과! MapManager가 초기화되지 않았습니다.");
                yield break;
            }
            yield return null;
        }
        Debug.Log("2. [GameManager] MapManager 초기화 완료됨을 확인했습니다.");

        MapNode currentNode = mapManager.CurrentNode;
        if (currentNode == null)
        {
            Debug.LogError("3. [GameManager] 에러! MapManager로부터 현재 노드 정보를 가져올 수 없습니다!");
            yield break;
        }

        Debug.Log($"3. [GameManager] 현재 노드(Y:{currentNode.Position.y})에 맞는 라운드 데이터를 찾습니다.");
        RoundDataSO roundToStart = campaignManager.GetRoundDataForNode(currentNode);

        if (roundToStart != null)
        {
            Debug.Log($"4. [GameManager] RoundManager에게 '{roundToStart.name}' 라운드 시작을 요청합니다.");
            yield return StartCoroutine(roundManager.StartRound(roundToStart));
            Time.timeScale = 1f;
        }
        else
        {
            Debug.LogError($"4. [GameManager] 에러! '{currentNode.Position}' 노드에 해당하는 라운드 데이터를 찾지 못했습니다!");
        }
        Debug.Log("--- [GameManager] StartRoundAfterSceneLoad 코루틴 정상 종료 ---");
    }
}


==================== PoolManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/PoolManager.cs) ====================
// 파일명: PoolManager.cs (리팩토링 완료)
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class PoolManager : MonoBehaviour
{
    private Dictionary<GameObject, Queue<GameObject>> poolDictionary = new Dictionary<GameObject, Queue<GameObject>>();
    
    // [추가] 현재 씬에 활성화된 모든 풀링 오브젝트를 추적하기 위한 HashSet
    private readonly HashSet<GameObject> activePooledObjects = new HashSet<GameObject>();

    void Awake()
    {
        Debug.Log($"[ 진단 ] PoolManager.Awake() 호출됨. (Frame: {Time.frameCount})");
        if (!ServiceLocator.IsRegistered<PoolManager>())
        {
            ServiceLocator.Register<PoolManager>(this);
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void Preload(GameObject prefab, int count)
    {
        if (prefab == null || count <= 0)
        {
            Debug.LogWarning("[PoolManager] Preload 실패: 프리팹이 null이거나 수량이 0 이하입니다.");
            return;
        }

        Debug.Log($"[ 진단-Preload ] 프리팹 '{prefab.name}' (ID: {prefab.GetInstanceID()}) {count}개 미리 생성 요청됨.");

        if (!poolDictionary.ContainsKey(prefab))
        {
            poolDictionary[prefab] = new Queue<GameObject>();
        }

        for (int i = 0; i < count; i++)
        {
            GameObject obj = Instantiate(prefab, transform);
            obj.SetActive(false);
            if (!obj.TryGetComponent<PooledObjectInfo>(out var pooledInfo))
            {
                pooledInfo = obj.AddComponent<PooledObjectInfo>();
            }
            pooledInfo.Initialize(prefab);
            poolDictionary[prefab].Enqueue(obj);
        }
    }

    

    public GameObject Get(GameObject prefab)
    {
        if (prefab == null)
        {
            Debug.LogError("[PoolManager] Get 실패: 요청한 프리팹이 null입니다.");
            return null;
        }

        if (!poolDictionary.ContainsKey(prefab) || poolDictionary[prefab].Count == 0)
        {
            Debug.LogWarning($"[PoolManager] {prefab.name} 풀이 비어있어 새로 생성합니다. Preload가 정상적으로 작동했는지 확인해보세요.");
            GameObject newObj = Instantiate(prefab);
            if (!newObj.TryGetComponent<PooledObjectInfo>(out var pooledInfo))
            {
                pooledInfo = newObj.AddComponent<PooledObjectInfo>();
            }
            pooledInfo.Initialize(prefab);
            return newObj;
        }

        GameObject obj = poolDictionary[prefab].Dequeue();
        obj.SetActive(true);

        // [추가] 오브젝트를 꺼내갈 때, 활성 목록에 등록합니다.
        activePooledObjects.Add(obj);

        return obj;
    }

    public void Release(GameObject instance)
    {
        if (instance == null) return;
        
        Debug.Log($"[PoolManager] Release 요청: {instance.name} (ID: {instance.GetInstanceID()})");

        // [추가] 오브젝트를 반납할 때, 활성 목록에서 제거합니다.
        activePooledObjects.Remove(instance);

        PooledObjectInfo pooledInfo = instance.GetComponent<PooledObjectInfo>();
        if (pooledInfo == null || pooledInfo.originalPrefab == null)
        {
            Debug.LogWarning($"[PoolManager] Release 실패: {instance.name} (ID: {instance.GetInstanceID()}) PooledObjectInfo 없음. 즉시 파괴.");
            Destroy(instance);
            return;
        }

        GameObject originalPrefab = pooledInfo.originalPrefab;

        if (!poolDictionary.ContainsKey(originalPrefab))
        {
            poolDictionary[originalPrefab] = new Queue<GameObject>();
        }

        instance.SetActive(false);
        Debug.Log($"[PoolManager] {instance.name} (ID: {instance.GetInstanceID()}) 비활성화 완료.");
        instance.transform.SetParent(transform);
        poolDictionary[originalPrefab].Enqueue(instance);
    }

    // [추가] 활성화된 모든 풀링 오브젝트를 정리하는 새로운 함수
    public void ClearAllActiveObjects()
    {
        Debug.Log($"[PoolManager] 활성화된 모든 풀 오브젝트 ({activePooledObjects.Count}개)를 정리합니다.");
        
        // HashSet을 직접 순회하면서 요소를 제거하면 오류가 발생하므로, 리스트로 복사한 뒤 순회합니다.
        foreach (var obj in activePooledObjects.ToList())
        {
            Release(obj);
        }
        
        // 모든 객체가 Release를 통해 개별적으로 제거되지만, 만약을 위해 마지막에 Clear를 호출합니다.
        activePooledObjects.Clear();
    }

    /// <summary>
    /// 모든 풀링된 오브젝트(활성 및 비활성)를 즉시 파괴하고 풀을 초기화합니다.
    /// 씬 전환 등 풀의 모든 오브젝트를 강제로 정리해야 할 때 사용합니다.
    /// </summary>
    public void DestroyAllPooledObjects()
    {
        Debug.Log($"[PoolManager] 모든 풀링된 오브젝트를 파괴합니다. (활성: {activePooledObjects.Count}개, 비활성 풀: {poolDictionary.Sum(kv => kv.Value.Count)}개)");

        // 활성 오브젝트 먼저 파괴
        foreach (var obj in activePooledObjects.ToList()) // ToList()로 복사하여 순회 중 수정 가능하게 함
        {
            Destroy(obj);
        }
        activePooledObjects.Clear();

        // 비활성 풀 오브젝트 파괴
        foreach (var kvp in poolDictionary)
        {
            foreach (var obj in kvp.Value)
            {
                Destroy(obj);
            }
        }
        poolDictionary.Clear();
        Debug.Log("[PoolManager] 모든 풀링된 오브젝트 파괴 완료.");
    }
}

==================== PrefabKeys.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/PrefabKeys.cs) ====================
// 파일명: PrefabKeys.cs
public static class PrefabKeys
{
    public const string Managers = "_Managers";
    public const string GameplaySession = "_GameplaySession";
    public const string DamageTextCanvas = "DamageTextCanvas";
}

==================== StatSources.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/StatSources.cs) ====================
// 파일명: StatSources.cs
public static class StatSources
{
    public const string Permanent = "Permanent";
    public const string Allocated = "Allocated";
}

==================== SceneAudioLoader.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/SceneAudioLoader.cs) ====================
//  : Assets/1.Scripts/Core/SceneAudioLoader.cs

using UnityEngine;

public class SceneAudioLoader : MonoBehaviour
{
    [Header("  ÷")]
    [SerializeField]
    private AudioCollection sceneAudioCollection;

    [Header(" BGM ̸ ( )")]
    [SerializeField]
    private string startingBgmName;

    void Start()
    {
        // [] ServiceLocator  AudioManager ɴϴ.
        var audioManager = ServiceLocator.Get<AudioManager>();
        if (audioManager == null)
        {
            Debug.LogError("SceneAudioLoader: AudioManager ã  ϴ!");
            return;
        }

        if (sceneAudioCollection != null)
        {
            // []  audioManager  մϴ.
            audioManager.LoadCollection(sceneAudioCollection);
            if (!string.IsNullOrEmpty(startingBgmName))
            {
                audioManager.PlayBgm(startingBgmName);
            }
        }
        else
        {
            Debug.LogWarning("SceneAudioLoader: AudioCollection Ҵ ʾҽϴ!", this.gameObject);
        }
    }
}

==================== InputManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/InputManager.cs) ====================
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using UnityEngine.SceneManagement; // Added for scene management events
using System.Collections;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations; // 코루틴 사용을 위해 추가

public class InputManager : MonoBehaviour
{
    // [삭제] 이 const 변수들은 더 이상 사용하지 않습니다.
    // private const string MANAGERS_PREFAB_PATH = PrefabKeys.Managers;
    // private const string SESSION_PREFAB_PATH = PrefabKeys.GameplaySession;

    

    public UnityEvent<Vector2> OnMove = new UnityEvent<Vector2>();
    private GameObject lastSelectedObject;

    void Awake()
    {
        ServiceLocator.Register<InputManager>(this);
        // DontDestroyOnLoad는 InitializeManagers에서 처리되므로 여기선 생략

        // 장면의 모든 GraphicRaycaster를 찾아 비활성화합니다.
        GraphicRaycaster[] allGraphicRaycasters = FindObjectsOfType<GraphicRaycaster>();
        foreach (GraphicRaycaster raycaster in allGraphicRaycasters)
        {
            raycaster.enabled = false;
        }

        // 장면의 모든 Physics2DRaycaster를 찾아 비활성화합니다.
        Physics2DRaycaster[] allPhysics2DRaycasters = FindObjectsOfType<Physics2DRaycaster>();
        foreach (Physics2DRaycaster raycaster in allPhysics2DRaycasters)
        {
            raycaster.enabled = false;
        }
    }

    void OnEnable()
    {
        SceneManager.sceneLoaded += OnSceneLoaded;
    }

    void OnDisable()
    {
        SceneManager.sceneLoaded -= OnSceneLoaded;
    }

    void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        // 기존 로직을 직접 실행하는 대신 코루틴을 시작시킵니다.
        StartCoroutine(OnSceneLoadedRoutine(scene, mode));
    }

    private IEnumerator OnSceneLoadedRoutine(Scene scene, LoadSceneMode mode)
    {
        // 한 프레임 대기하여 씬의 모든 오브젝트가 Awake() 및 OnEnable()을 마칠 시간을 줍니다.
        yield return null;

        Debug.Log($"[InputManager] 씬 로드됨: {scene.name}, 모드: {mode}");
        if (EventSystem.current == null)
        {
            Debug.LogWarning("[InputManager] 씬 로드 후 EventSystem.current가 null입니다.");
        }
        else
        {
            Debug.Log($"[InputManager] EventSystem.current: {EventSystem.current.gameObject.name}");
            if (EventSystem.current.currentInputModule != null)
            {
                Debug.Log($"[InputManager] 현재 입력 모듈: {EventSystem.current.currentInputModule.GetType().Name}, 활성화됨: {EventSystem.current.currentInputModule.enabled}");
            }
            else
            {
                // 이 코루틴 수정으로 인해 이 경고는 더 이상 나타나지 않을 것입니다.
                Debug.LogWarning("[InputManager] EventSystem.current.currentInputModule이 null입니다.");
            }
        }

        // 기존의 Raycaster 비활성화 로직은 그대로 유지합니다.
        GraphicRaycaster[] allGraphicRaycasters = FindObjectsOfType<GraphicRaycaster>();
        Debug.Log($"[InputManager] 씬 로드 후 {allGraphicRaycasters.Length}개의 GraphicRaycaster 발견.");
        foreach (GraphicRaycaster raycaster in allGraphicRaycasters)
        {
            if (raycaster.enabled)
            {
                Debug.LogWarning($"[InputManager] GraphicRaycaster '{raycaster.gameObject.name}'가 씬 로드 후 활성화되어 있습니다.");
                raycaster.enabled = false;
            }
        }

        Physics2DRaycaster[] allPhysics2DRaycasters = FindObjectsOfType<Physics2DRaycaster>();
        Debug.Log($"[InputManager] 씬 로드 후 {allPhysics2DRaycasters.Length}개의 Physics2DRaycaster 발견.");
        foreach (Physics2DRaycaster raycaster in allPhysics2DRaycasters)
        {
            if (raycaster.enabled)
            {
                Debug.LogWarning($"[InputManager] Physics2DRaycaster '{raycaster.gameObject.name}'가 씬 로드 후 활성화되어 있습니다.");
                raycaster.enabled = false;
            }
        }
    }

    void Update()
    {
        if (EventSystem.current == null) return;

        GameObject currentSelected = EventSystem.current.currentSelectedGameObject;

        // 1. 현재 무언가 선택되어 있고, 그게 Selectable(버튼, 토글 등)이라면 마지막 선택으로 기억합니다.
        if (currentSelected != null && currentSelected.GetComponent<Selectable>() != null)
        {
            lastSelectedObject = currentSelected;
        }
        // 2. 현재 선택된 것이 없거나, Selectable이 아닌 것(예: 배경 패널)이 선택되었다면
        else
        {
            // 3. 마지막으로 기억해 둔 Selectable이 있다면 강제로 포커스를 되돌립니다.
            if (lastSelectedObject != null && lastSelectedObject.activeInHierarchy)
            {
                EventSystem.current.SetSelectedGameObject(lastSelectedObject);
            }
        }

        // 게임플레이 중에는 키보드/게임패드 입력을 처리합니다.
        HandleGameplayInput();
    }

    private void HandleGameplayInput()
    {
        Vector2 move = new Vector2(Input.GetAxisRaw("Horizontal"), Input.GetAxisRaw("Vertical"));
        OnMove.Invoke(move.normalized);
    }
}

==================== CharacterIDs.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/CharacterIDs.cs) ====================
// 파일명: CharacterIDs.cs
public static class CharacterIDs
{
    public const string Warrior = "warrior";
    public const string Archer = "archer";
    public const string Mage = "mage";
}

==================== PooledObjectInfo.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Core/PooledObjectInfo.cs) ====================
using UnityEngine;

/// <summary>
/// 풀링된 오브젝트의 원본 프리팹 정보를 저장하는 컴포넌트입니다.
/// PoolManager가 오브젝트를 풀로 반환할 때 어떤 풀에 속하는지 식별하는 데 사용됩니다.
/// </summary>
public class PooledObjectInfo : MonoBehaviour
{
    public GameObject originalPrefab; // 이 오브젝트의 원본 프리팹

    /// <summary>
    /// 오브젝트 정보를 초기화합니다.
    /// </summary>
    /// <param name="prefab">이 오브젝트의 원본 프리팹</param>
    public void Initialize(GameObject prefab)
    {
        originalPrefab = prefab;
    }
}


==================== PlayerController.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Gameplay/PlayerController.cs) ====================
// 파일명: PlayerController.cs (리팩토링 완료)
using UnityEngine;

[RequireComponent(typeof(Rigidbody2D))]
public class PlayerController : MonoBehaviour
{
    private Rigidbody2D rb;
    private CharacterStats stats;
    private Vector2 moveInput;

    private CardManager cardManager;
    private EffectExecutor effectExecutor;
    private InputManager inputManager;

    [Header("공격 시작 위치")]
    public Transform firePoint;

    void Awake()
    {
        // 씬이 시작될 때 ServiceLocator에 자신을 등록합니다.
        ServiceLocator.Register<PlayerController>(this);
        Debug.Log($"[{GetType().Name}] ServiceLocator에 PlayerController를 등록했습니다.");

        rb = GetComponent<Rigidbody2D>();
        stats = GetComponent<CharacterStats>();

        cardManager = ServiceLocator.Get<CardManager>();
        effectExecutor = ServiceLocator.Get<EffectExecutor>();
        inputManager = ServiceLocator.Get<InputManager>();

        if (cardManager == null || effectExecutor == null || inputManager == null)
        {
            Debug.LogError($"[{GetType().Name}] Awake에서 필수 매니저 중 하나를 가져오지 못했습니다! ServiceLocator 등록 순서를 확인하세요.");
        }
    }

    void OnEnable()
    {
        if (inputManager != null)
        {
            inputManager.OnMove.AddListener(OnMove);
        }
        RoundManager.OnRoundEnded += HandleRoundEnd;
    }

    void OnDisable()
    {
        if (inputManager != null)
        {
            inputManager.OnMove.RemoveListener(OnMove);
        }
        RoundManager.OnRoundEnded -= HandleRoundEnd;
    }

    // 오브젝트가 파괴될 때 ServiceLocator에서 등록을 해제합니다.
    private void OnDestroy()
    {
        ServiceLocator.Unregister<PlayerController>(this);
        Debug.Log($"[{GetType().Name}] ServiceLocator에서 PlayerController를 등록 해제했습니다.");
    }

    private void HandleRoundEnd(bool success)
    {
        Debug.Log($"[{GetType().Name}] 라운드 종료(성공: {success}). 자동 공격을 중지합니다.");
        CancelInvoke(nameof(PerformAttack));
    }

    public void StartAutoAttackLoop()
    {
        CancelInvoke(nameof(PerformAttack));
        if (stats == null)
        {
            Debug.LogError($"[{GetType().Name}] CharacterStats가 없어 공격 루프를 시작할 수 없습니다!");
            return;
        }

        float interval = 1f / stats.FinalAttackSpeed;
        Debug.Log($"[{GetType().Name}] 공격 루프 시작. (공격 속도: {stats.FinalAttackSpeed}, 반복 주기: {interval}초)");

        if (float.IsInfinity(interval) || interval <= 0)
        {
            Debug.LogError($"[{GetType().Name}] 공격 주기가 비정상적({interval})이므로 공격을 시작할 수 없습니다!");
            return;
        }

        InvokeRepeating(nameof(PerformAttack), 0f, interval);
    }

    private void PerformAttack()
    {
        if (cardManager == null) return;
        if (cardManager.activeCard == null) return;
        if (effectExecutor == null) return;

        // 자신의 정보(stats, firePoint)를 인자로 넘겨줌
        effectExecutor.Execute(cardManager.activeCard, stats, firePoint);
    }

    void FixedUpdate()
    {
        if (stats == null || rb == null) return;
        Vector2 finalVelocity = moveInput * stats.FinalMoveSpeed;
        rb.velocity = finalVelocity;
    }

    private void OnMove(Vector2 input)
    {
        moveInput = input;
    }

    public void Heal(float amount)
    {
        if (stats != null)
        {
            Debug.Log($"[{GetType().Name}] {amount}만큼 체력을 회복합니다.");
            stats.Heal(amount);
        }
    }
}

==================== MonsterController.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Gameplay/MonsterController.cs) ====================
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

[RequireComponent(typeof(Rigidbody2D))]
public class MonsterController : MonoBehaviour
{
    public static event System.Action<float, Vector3> OnMonsterDamaged;
    public static event System.Action<MonsterController> OnMonsterDied;

    [HideInInspector] public float moveSpeed;
    [HideInInspector] public float contactDamage;
    [HideInInspector] public float maxHealth;
    public float currentHealth;

    private MonsterDataSO monsterData;
    private Transform playerTransform;
    private bool isInvulnerable = false;
    private Rigidbody2D rb;

    private const float DAMAGE_INTERVAL = 0.1f;
    private float damageTimer = 0f;
    private bool isTouchingPlayer = false;

    public HashSet<string> hitShotIDs = new HashSet<string>();

    private bool isDead = false;

    void Awake()
    {
        rb = GetComponent<Rigidbody2D>();
    }

    void OnEnable()
    {
        // ... 기존 코드 ...
        ServiceLocator.Get<MonsterManager>()?.RegisterMonster(this); // 활성화될 때 리스트에 추가
        hitShotIDs.Clear();
        isDead = false;
        if (monsterData != null)
        {
            currentHealth = monsterData.maxHealth;
        }
        isInvulnerable = false;
    }

    void OnDisable()
    {
        // 1. ServiceLocator에 MonsterManager가 아직 등록되어 있는지 먼저 확인합니다.
        if (ServiceLocator.IsRegistered<MonsterManager>())
        {
            // 2. 등록되어 있을 경우에만 안전하게 Get을 호출하여 Unregister를 실행합니다.
            ServiceLocator.Get<MonsterManager>()?.UnregisterMonster(this);
        }
    }

    

    public void Initialize(MonsterDataSO data)
    {
        monsterData = data;
        maxHealth = monsterData.maxHealth;
        moveSpeed = monsterData.moveSpeed;
        contactDamage = monsterData.contactDamage;
        currentHealth = maxHealth;
        hitShotIDs.Clear();
        isDead = false;
    }

    void Update()
    {
        if (isTouchingPlayer)
        {
            damageTimer += Time.deltaTime;
            if (damageTimer >= DAMAGE_INTERVAL)
            {
                ApplyContactDamage();
                damageTimer = 0f;
            }
        }
    }

    void FixedUpdate()
    {
        // --- [수정] ServiceLocator를 통해 PlayerController를 찾아옵니다. ---
        var playerController = ServiceLocator.Get<PlayerController>();
        if (playerController != null)
        {
            playerTransform = playerController.transform;
        }
        else
        {
            Debug.LogError($"[{gameObject.name}] PlayerController 인스턴스를 찾을 수 없습니다! 스크립트를 비활성화합니다.");
            this.enabled = false;
            return;
        }

        if (isInvulnerable || playerTransform == null || isDead)
        {
            rb.velocity = Vector2.zero;
            return;
        }
        Vector2 direction = (playerTransform.position - transform.position).normalized;
        rb.velocity = direction * moveSpeed;
    }

    void OnCollisionEnter2D(Collision2D collision)
    {
        CheckForPlayer(collision.gameObject);
    }

    void OnCollisionExit2D(Collision2D collision)
    {
        LeavePlayer(collision.gameObject);
    }

        void OnTriggerEnter2D(Collider2D other)
    {
        if (isDead) return;

        if (other.TryGetComponent<BulletController>(out var bullet))
        {
            if (bullet == null || bullet.SourceCard == null) return;

            if (hitShotIDs.Contains(bullet.shotInstanceID))
            {
                ServiceLocator.Get<PoolManager>().Release(other.gameObject);
                return;
            }
            hitShotIDs.Add(bullet.shotInstanceID);

            // --- 크리티컬 로직 시작 ---
            float finalDamage = bullet.damage; // 총알로부터 기본 데미지를 가져옵니다.

            var playerController = ServiceLocator.Get<PlayerController>();
            if (playerController != null)
            {
                var playerStats = playerController.GetComponent<CharacterStats>();
                if (playerStats != null)
                {
                    // 크리티컬 확률을 계산합니다.
                    if (Random.Range(0f, 100f) < playerStats.FinalCritRate)
                    {
                        // 크리티컬 발생!
                        Debug.Log("CRITICAL HIT!");
                        finalDamage *= (1 + playerStats.FinalCritDamage / 100f);

                        // 크리티컬 이펙트를 생성합니다.
                        var prefabProvider = ServiceLocator.Get<PrefabProvider>();
                        if (prefabProvider != null && prefabProvider.critEffectPrefab != null)
                        {
                            var poolManager = ServiceLocator.Get<PoolManager>();
                            if (poolManager != null)
                            {
                                GameObject critEffect = poolManager.Get(prefabProvider.critEffectPrefab);
                                if (critEffect != null)
                                {
                                    critEffect.transform.position = transform.position;
                                    critEffect.transform.rotation = Quaternion.identity;
                                }
                            }
                        }
                    }
                }
            }
            // --- 크리티컬 로직 끝 ---

            // 최종 계산된 데미지를 몬스터에게 적용합니다.
            TakeDamage(finalDamage);

            // --- 흡혈 로직 시작 ---
            if (playerController != null)
            {
                var playerStats = playerController.GetComponent<CharacterStats>();
                if (playerStats != null && bullet.SourceCard != null && bullet.SourceCard.triggerType == TriggerType.OnHit && bullet.SourceCard.lifestealPercentage > 0 && finalDamage > 0)
                {
                    Debug.Log($"[Lifesteal Debug] 흡혈 조건 충족! 카드: {bullet.SourceCard.cardName}, 입힌 데미지: {finalDamage:F2}");
                    float lifestealRatio = bullet.SourceCard.lifestealPercentage / 100f;
                    float healAmount = finalDamage * lifestealRatio;
                    Debug.Log($"[Lifesteal Debug] 흡혈 비율: {bullet.SourceCard.lifestealPercentage}% ({lifestealRatio:P2}), 회복량: {healAmount:F2}");
                    playerStats.Heal(healAmount);
                    Debug.Log($"[Lifesteal Debug] 플레이어 체력 {healAmount:F2} 회복 요청됨.");
                }
            }
            // --- 흡혈 로직 끝 ---

            // 상태 이상 적용 로직
            if (bullet.SourceCard != null && bullet.SourceCard.statusEffectToApply != null)
            {
                Debug.Log($"[StatusEffect] {bullet.SourceCard.statusEffectToApply.effectName} 효과를 적용합니다.");
                ServiceLocator.Get<StatusEffectManager>().ApplyStatusEffect(this.gameObject, bullet.SourceCard.statusEffectToApply);
            }

            // 기존 보조 효과 로직
            CardDataSO secondaryEffectCard = bullet.SourceCard.secondaryEffect;
            if (secondaryEffectCard != null)
            {
                var effectExecutor = ServiceLocator.Get<EffectExecutor>();
                if (effectExecutor != null && playerController != null)
                {
                    Debug.Log($"[디버그 1] 기본 카드 '{bullet.SourceCard.name}'가 명중. 보조 효과 '{secondaryEffectCard.name}'를 발동합니다.");
                    effectExecutor.Execute(secondaryEffectCard, playerController.GetComponent<CharacterStats>(), this.transform, finalDamage);
                }
            }

            Debug.Log($"[MonsterController] 총알 {other.gameObject.name} (ID: {other.gameObject.GetInstanceID()}) 풀로 반환 요청.");
            ServiceLocator.Get<PoolManager>().Release(other.gameObject);
        }
        else
        {
            CheckForPlayer(other.gameObject);
        }
    }

    void OnTriggerExit2D(Collider2D other)
    {
        LeavePlayer(other.gameObject);
    }

    private void CheckForPlayer(GameObject target)
    {
        if (target.GetComponent<CharacterStats>() != null)
        {
            isTouchingPlayer = true;
            damageTimer = DAMAGE_INTERVAL;
        }
    }

    private void LeavePlayer(GameObject target)
    {
        if (target.GetComponent<CharacterStats>() != null)
        {
            isTouchingPlayer = false;
            damageTimer = 0f;
        }
    }

    private void ApplyContactDamage()
    {
        if (playerTransform != null)
        {
            CharacterStats playerStats = playerTransform.GetComponent<CharacterStats>();
            if (playerStats != null)
            {
                playerStats.TakeDamage(contactDamage);
            }
        }
    }

    public void TakeDamage(float damage)
    {
        if (isDead || isInvulnerable) return;

        currentHealth -= damage;
        OnMonsterDamaged?.Invoke(damage, transform.position);

        if (currentHealth <= 0) Die();
    }

    private void Die()
    {
        if (isDead) return;

        isDead = true;
        OnMonsterDied?.Invoke(this);
        ServiceLocator.Get<PoolManager>().Release(gameObject);
    }

    public void SetInvulnerable(float duration)
    {
        StopCoroutine("InvulnerableRoutine");
        StartCoroutine(InvulnerableRoutine(duration));
    }

    private IEnumerator InvulnerableRoutine(float duration)
    {
        isInvulnerable = true;
        yield return new WaitForSeconds(duration);
        isInvulnerable = false;
    }
}

==================== MapGenerator.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Gameplay/MapGenerator.cs) ====================
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// 절차적 맵 생성을 담당하는 클래스입니다.
/// MonoBehaviour를 상속하여 Inspector에서 맵 생성 규칙을 쉽게 조정할 수 있습니다.
/// </summary>
public class MapGenerator : MonoBehaviour
{
    [Header("맵 크기 설정")]
    [SerializeField] private int mapHeight = 15; // y: 0 ~ 14
    [SerializeField] private int mapWidth = 5;   // x: 0 ~ 4

    // [추가됨] 다른 스크립트에서 맵 크기를 읽을 수 있도록 public getter를 추가합니다.
    public int MapHeight => mapHeight;
    public int MapWidth => mapWidth;

    [Header("노드 타입 생성 확률 (0~100%)")]
    [Range(0, 100)] [SerializeField] private float monsterChance = 60f;
    [Range(0, 100)] [SerializeField] private float restChance = 15f;
    [Range(0, 100)] [SerializeField] private float eventChance = 15f;
    [Range(0, 100)] [SerializeField] private float merchantChance = 10f; // 상점

    [Header("맵 경로 설정")]
    [SerializeField] private int numberOfPathsToGenerate = 4; // 생성할 경로의 개수

    [Header("디버그 옵션")]
    [SerializeField] private bool forceAllMonsters = true; // 이 옵션이 켜져 있으면 모든 노드를 몬스터로 강제합니다.

    /// <summary>
    /// 설정된 규칙에 따라 새로운 맵 데이터를 생성하고 노드 리스트를 반환합니다.
    /// </summary>
    /// <returns>생성된 모든 MapNode 객체의 리스트</returns>
    public List<MapNode> Generate()
    {

        // 맵 그리드 초기화 (모든 노드를 일단 생성)
        MapNode[,] grid = new MapNode[mapWidth, mapHeight];
        for (int y = 0; y < mapHeight; y++)
        {
            for (int x = 0; x < mapWidth; x++)
            {
                grid[x, y] = new MapNode { Position = new Vector2Int(x, y) };
            }
        }

        // 경로에 포함될 노드를 추적하기 위한 HashSet
        HashSet<MapNode> nodesInPaths = new HashSet<MapNode>();

        // 1. 고정된 시작/끝 노드 처리
        MapNode startNode = grid[mapWidth / 2, 0]; // y=0, x=2
        MapNode endNode = grid[mapWidth / 2, mapHeight - 1]; // y=14, x=2
        nodesInPaths.Add(startNode);
        nodesInPaths.Add(endNode);

        // 2. 지정된 개수만큼 경로 생성
        for (int i = 0; i < numberOfPathsToGenerate; i++)
        {
            GenerateSinglePath(grid, nodesInPaths, startNode, endNode);
        }

        // 3. 경로에 포함되지 않은 노드 삭제 및 최종 노드 리스트 생성
        List<MapNode> finalNodes = nodesInPaths.ToList();

        // 4. 노드 타입 할당 및 연결
        AssignNodeTypesAndConnectNodes(finalNodes, grid);

        return finalNodes;
    }

    /// <summary>
    /// 단일 경로를 생성하고, 경로에 포함된 노드들을 nodesInPaths에 추가합니다.
    /// </summary>
    private void GenerateSinglePath(MapNode[,] grid, HashSet<MapNode> nodesInPaths, MapNode startNode, MapNode endNode)
    {
        MapNode currentNode = startNode;
        nodesInPaths.Add(currentNode);

        for (int y = 0; y < mapHeight - 1; y++)
        {
            List<MapNode> possibleNextNodes = new List<MapNode>();

            if (y == 0) // y=0 -> y=1로 갈 때: y=1의 모든 x 노드로 연결 가능
            {
                for (int x = 0; x < mapWidth; x++)
                {
                    possibleNextNodes.Add(grid[x, y + 1]);
                }
            }
            else if (y == mapHeight - 2) // y=13 -> y=14로 갈 때: y=14의 x=2 노드로만 연결
            {
                possibleNextNodes.Add(endNode);
            }
            else // 일반적인 이동 규칙: x-1, x, x+1
            {
                int currentX = currentNode.Position.x;
                for (int dx = -1; dx <= 1; dx++)
                {
                    int nextX = currentX + dx;
                    if (nextX >= 0 && nextX < mapWidth)
                    {
                        possibleNextNodes.Add(grid[nextX, y + 1]);
                    }
                }
            }

            if (possibleNextNodes.Count > 0)
            {
                MapNode nextNode = possibleNextNodes[Random.Range(0, possibleNextNodes.Count)];
                nodesInPaths.Add(nextNode);
                currentNode = nextNode;
            }
            else
            {
                Debug.LogWarning($"[MapGenerator] 경로 생성 중 다음 노드를 찾을 수 없습니다. Y:{y}, X:{currentNode.Position.x}");
                break; // 경로 생성 실패
            }
        }
    }

    /// <summary>
    /// 최종 노드 리스트에 노드 타입을 할당하고, 노드 간 연결을 설정합니다.
    /// </summary>
    private void AssignNodeTypesAndConnectNodes(List<MapNode> finalNodes, MapNode[,] grid)
    {
        // 노드 타입 할당
        foreach (var node in finalNodes)
        {
            node.NodeType = GetNodeTypeForPosition(node.Position.y);
        }

        // 노드 연결
        foreach (var currentNode in finalNodes)
        {
            // y=14 노드는 다음 노드가 없습니다.
            if (currentNode.Position.y == mapHeight - 1) continue;

            List<MapNode> possibleNextLayerNodes = new List<MapNode>();

            if (currentNode.Position.y == 0) // y=0 노드: y=1에 있는 모든 노드와 연결
            {
                for (int x = 0; x < mapWidth; x++)
                {
                    MapNode nextNodeCandidate = grid[x, 1];
                    if (finalNodes.Contains(nextNodeCandidate))
                    {
                        possibleNextLayerNodes.Add(nextNodeCandidate);
                    }
                }
            }
            else if (currentNode.Position.y == mapHeight - 2) // y=13 노드: y=14의 x=2 노드와 연결
            {
                MapNode nextNodeCandidate = grid[mapWidth / 2, mapHeight - 1];
                if (finalNodes.Contains(nextNodeCandidate))
                {
                    possibleNextLayerNodes.Add(nextNodeCandidate);
                }
            }
            else // 일반적인 이동 규칙: x-1, x, x+1 범위 내의 다음 층 노드와 연결
            {
                int currentX = currentNode.Position.x;
                for (int dx = -1; dx <= 1; dx++)
                {
                    int nextX = currentX + dx;
                    if (nextX >= 0 && nextX < mapWidth)
                    {
                        MapNode nextNodeCandidate = grid[nextX, currentNode.Position.y + 1];
                        if (finalNodes.Contains(nextNodeCandidate))
                        {
                            possibleNextLayerNodes.Add(nextNodeCandidate);
                        }
                    }
                }
            }

            // 실제 연결
            foreach (var nextNode in possibleNextLayerNodes)
            {
                currentNode.NextNodes.Add(nextNode);
            }
        }
    }

    /// <summary>
    /// y 좌표에 따라 노드 타입을 결정합니다.
    /// </summary>
    private NodeType GetNodeTypeForPosition(int y)
    {
        // 시작(y=0)과 끝(y=14)은 항상 몬스터 노드
        if (y == 0 || y == mapHeight - 1)
        {
            return NodeType.Monster;
        }

        // 디버그 옵션이 켜져 있으면 항상 몬스터 반환
        if (forceAllMonsters)
        {
            return NodeType.Monster;
        }

        // ---- 향후 구현을 위한 확률 기반 노드 타입 결정 로직 ----
        // 현재는 주석 처리되어 있으며, forceAllMonsters가 false일 때 동작합니다.

        float totalChance = monsterChance + restChance + eventChance + merchantChance;
        float randomValue = Random.Range(0, totalChance);

        // if (randomValue < monsterChance)
        // {
        //     return NodeType.Monster;
        // }
        // else if (randomValue < monsterChance + restChance)
        // {
        //     // return NodeType.Rest; // 기능 구현 시 주석 해제
        //     return NodeType.Monster; // 현재는 몬스터로 대체
        // }
        // else if (randomValue < monsterChance + restChance + eventChance)
        // {
        //     // return NodeType.Event; // 기능 구현 시 주석 해제
        //     return NodeType.Monster; // 현재는 몬스터로 대체
        // }
        // else
        // {
        //     // return NodeType.Shop; // 기능 구현 시 주석 해제
        //     return NodeType.Monster; // 현재는 몬스터로 대체
        // }

        // 위 로직을 모두 주석처리하고 몬스터로 고정합니다.
        return NodeType.Monster;
    }
}

==================== PrefabProvider.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Gameplay/PrefabProvider.cs) ====================
// PrefabProvider.cs (최종 수정안)

using UnityEngine;
using System.Collections.Generic;

// ▼▼▼ [1] 프리팹과 개수를 묶는 클래스를 여기에 추가합니다. ▼▼▼
[System.Serializable]
public class PreloadItem
{
    public GameObject prefab;
    [Tooltip("미리 생성해 둘 개수입니다.")]
    public int count;
}

public class PrefabProvider : MonoBehaviour
{
    // ▼▼▼ [2] 리스트의 타입을 List<GameObject>에서 List<PreloadItem>으로 변경합니다. ▼▼▼
    [Header("공용 프리팹 목록 (Damage Text 등)")]
    [SerializeField] private List<PreloadItem> commonPreloadItems;

    [Header("특수 효과 프리팹")]
    [Tooltip("크리티컬 히트 시 생성될 이펙트 프리팹입니다.")]
    public GameObject critEffectPrefab;

    private readonly Dictionary<string, GameObject> prefabDictionary = new Dictionary<string, GameObject>();

    void Awake()
    {
        ServiceLocator.Register<PrefabProvider>(this);
        
        // commonPreloadItems 리스트를 기반으로 딕셔너리를 채웁니다.
        if (commonPreloadItems != null)
        {
            foreach (var item in commonPreloadItems)
            {
                if (item.prefab != null && !prefabDictionary.ContainsKey(item.prefab.name))
                {
                    // GetPrefab을 위해 이름-프리팹 쌍을 저장합니다.
                    prefabDictionary.Add(item.prefab.name, item.prefab);
                }
            }
        }
        Debug.Log($"[{GetType().Name}] 공용 프리팹 딕셔너리 초기화 완료. 총 {prefabDictionary.Count}개의 프리팹이 등록되었습니다.");
    }

    // GetPrefab 함수는 기존과 동일하게 유지됩니다.
    public GameObject GetPrefab(string name)
    {
        if (string.IsNullOrEmpty(name)) return null;
        prefabDictionary.TryGetValue(name, out GameObject prefab);
        if (prefab == null)
        {
            Debug.LogError($"[PrefabProvider] 프리팹 딕셔너리에서 '{name}'을(를) 찾을 수 없습니다.");
        }
        return prefab;
    }

    // ▼▼▼ [3] GameManager가 프리팹과 개수 정보를 함께 가져갈 수 있도록 새 함수를 추가합니다. ▼▼▼
    public List<PreloadItem> GetCommonPreloadItems() => commonPreloadItems;
}

==================== PointAllocationManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Gameplay/PointAllocationManager.cs) ====================
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class PointAllocationManager : MonoBehaviour
{
    [Header("UI 참조")]
    [SerializeField] private PointAllocationResultUI resultUI;
    [SerializeField] private TMP_InputField pointsToInvestInput_Actual;
    [SerializeField] private Button inputActivationButton;
    [SerializeField] private TextMeshProUGUI inputActivationButtonText;
    [SerializeField] private Button confirmButton;
    [SerializeField] private Button backButton;
    [SerializeField] private TextMeshProUGUI totalPointsText;

    [Header("코어 로직 참조")]
    [SerializeField] private MapGenerator mapGenerator;

    private CharacterDataSO selectedCharacter;
    private int totalCharacterPoints;

    private void Awake()
    {
        inputActivationButton.onClick.AddListener(ActivateInputMode);
        confirmButton.onClick.AddListener(OnConfirmAllocationClicked);
        backButton.onClick.AddListener(OnBackClicked);
        pointsToInvestInput_Actual.onEndEdit.AddListener(DeactivateInputMode);
    }

    void Start()
    {
        InitializeAllocation();
        if (resultUI != null)
        {
            resultUI.gameObject.SetActive(true);
            resultUI.UpdateDisplay(selectedCharacter.baseStats, null);
        }
        pointsToInvestInput_Actual.gameObject.SetActive(false);

        if (mapGenerator == null)
        {
            Debug.LogError("[PointAllocationManager] MapGenerator 참조가 설정되지 않았습니다! Inspector에서 연결해주세요.");
        }
    }

    private void OnConfirmAllocationClicked()
    {
        if (!int.TryParse(pointsToInvestInput_Actual.text, out int allocatedPoints))
        {
            allocatedPoints = 0;
        }

        // --- ServiceLocator를 통해 필요한 매니저들을 미리 가져옵니다. ---
        var gameManager = ServiceLocator.Get<GameManager>();
        var progressionManager = ServiceLocator.Get<ProgressionManager>();
        var mapManager = ServiceLocator.Get<MapManager>();
        var campaignManager = ServiceLocator.Get<CampaignManager>();

        gameManager.AllocatedPoints = allocatedPoints;

        CharacterPermanentStats permanentStats = progressionManager.GetPermanentStatsFor(selectedCharacter.characterId);
        Dictionary<StatType, int> distributedPoints = CalculateDistributedPoints(allocatedPoints, permanentStats);
        resultUI.UpdateDisplay(selectedCharacter.baseStats, distributedPoints);

        confirmButton.interactable = false;
        backButton.interactable = false;
        inputActivationButton.interactable = false;

        Debug.Log("[PointAllocationManager] 확인 버튼 클릭됨. 맵 생성을 시작합니다.");

        // 1. 맵 데이터를 먼저 생성하고 MapManager를 초기화합니다.
        if (mapGenerator != null && mapManager != null)
        {
            List<MapNode> mapData = mapGenerator.Generate();
            mapManager.InitializeMap(mapData, mapGenerator.MapWidth, mapGenerator.MapHeight);
            Debug.Log("[PointAllocationManager] MapManager 초기화 완료.");
        }
        else
        {
            Debug.LogError("[PointAllocationManager] MapGenerator 또는 MapManager 참조가 없어 맵을 생성할 수 없습니다!");
            confirmButton.interactable = true;
            backButton.interactable = true;
            inputActivationButton.interactable = true;
            return;
        }

        // 2. 캠페인 매니저를 통해 이번에 플레이할 캠페인을 미리 선택합니다.
        CampaignDataSO selectedCampaign = campaignManager.SelectRandomCampaign();
        if (selectedCampaign == null)
        {
            confirmButton.interactable = true;
            backButton.interactable = true;
            inputActivationButton.interactable = true;
            return;
        }

        // 3. 선택된 캠페인의 첫 번째 라운드 데이터를 가져옵니다.
        MapNode firstNode = mapManager.GetReachableNodes().FirstOrDefault();
        RoundDataSO firstRoundData = campaignManager.GetRoundDataForNode(firstNode);
        if (firstRoundData == null)
        {
            Debug.LogError("첫 라운드 데이터를 찾을 수 없어 프리로딩을 시작할 수 없습니다!");
            confirmButton.interactable = true;
            backButton.interactable = true;
            inputActivationButton.interactable = true;
            return;
        }

        // 4. GameManager의 준비 코루틴에 첫 라운드 데이터를 전달하여 프리로딩을 시작합니다.
        StartCoroutine(gameManager.PreloadAssetsForRound(firstRoundData, OnPreloadComplete));
    }

    private void OnPreloadComplete()
    {
        Debug.Log("[PointAllocationManager] 프리로딩 완료 신호를 받았습니다. Gameplay 씬으로 전환합니다.");
        ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.Gameplay);
    }

    public void ActivateInputMode()
    {
        inputActivationButton.gameObject.SetActive(false);
        pointsToInvestInput_Actual.gameObject.SetActive(true);
        EventSystem.current.SetSelectedGameObject(pointsToInvestInput_Actual.gameObject);
        pointsToInvestInput_Actual.ActivateInputField();
    }

    private void DeactivateInputMode(string text)
    {
        ValidateInputValue();
        string correctedText = pointsToInvestInput_Actual.text;
        if (string.IsNullOrEmpty(correctedText))
        {
            inputActivationButtonText.text = "포인트 입력...";
        }
        else
        {
            inputActivationButtonText.text = correctedText;
        }
        pointsToInvestInput_Actual.gameObject.SetActive(false);
        inputActivationButton.gameObject.SetActive(true);
        EventSystem.current.SetSelectedGameObject(inputActivationButton.gameObject);
    }

    private void InitializeAllocation()
    {
                        selectedCharacter = ServiceLocator.Get<GameManager>().SelectedCharacter ?? ServiceLocator.Get<DataManager>().GetCharacter(CharacterIDs.Warrior);
        totalCharacterPoints = selectedCharacter.initialAllocationPoints;
        if (totalPointsText != null) totalPointsText.text = $"Total Points: {totalCharacterPoints}";
    }

    private void ValidateInputValue()
    {
        if (!string.IsNullOrEmpty(pointsToInvestInput_Actual.text) && int.TryParse(pointsToInvestInput_Actual.text, out int points))
        {
            if (points > totalCharacterPoints)
            {
                pointsToInvestInput_Actual.text = totalCharacterPoints.ToString();
            }
            else if (points < 0)
            {
                pointsToInvestInput_Actual.text = "0";
            }
        }
    }

    public void OnBackClicked()
    {
        ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.CharacterSelect);
    }

    private Dictionary<StatType, int> CalculateDistributedPoints(int pointsToDistribute, CharacterPermanentStats permStats)
    {
        var pointCounts = new Dictionary<StatType, int>();
        foreach (StatType type in System.Enum.GetValues(typeof(StatType))) pointCounts[type] = 0;
        List<StatType> availableStats = permStats.GetUnlockedStats();
        if (availableStats.Count == 0) return pointCounts;
        for (int i = 0; i < pointsToDistribute; i++)
        {
            StatType targetStat = availableStats[Random.Range(0, availableStats.Count)];
            pointCounts[targetStat]++;
        }
        return pointCounts;
    }
}

==================== StatusEffectManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Gameplay/StatusEffectManager.cs) ====================
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// 게임 내 모든 캐릭터(플레이어, 몬스터)의 상태 효과(버프, 디버프)를 관리하는 클래스입니다.
/// </summary>
public class StatusEffectManager : MonoBehaviour
{
    private readonly Dictionary<GameObject, List<StatusEffect>> activeEffects = new Dictionary<GameObject, List<StatusEffect>>();
    private readonly List<StatusEffect> effectsToRemove = new List<StatusEffect>();
    private readonly List<GameObject> targetsToRemove = new List<GameObject>();

    void Awake()
    {
        ServiceLocator.Register<StatusEffectManager>(this);
    }

    void Update()
    {
        if (activeEffects.Count == 0) return;

        effectsToRemove.Clear();
        foreach (var entry in activeEffects.ToList()) // 순회 중 수정을 위해 ToList() 사용
        {
            GameObject target = entry.Key;
            if (target == null) // 대상이 파괴된 경우
            {
                targetsToRemove.Add(target);
                continue;
            }

            List<StatusEffect> effectsOnTarget = entry.Value;

            for (int i = effectsOnTarget.Count - 1; i >= 0; i--)
            {
                StatusEffect effect = effectsOnTarget[i];

                if (effect.effectData.damageOverTime > 0)
                {
                    if (target.CompareTag(Tags.Monster))
                    {
                        var monster = target.GetComponentInChildren<MonsterController>();
                        if (monster != null)
                        {
                            float damageThisFrame = effect.effectData.damageOverTime * monster.maxHealth * Time.deltaTime;
                            monster.TakeDamage(damageThisFrame);
                        }
                    }
                }

                effect.duration -= Time.deltaTime;
                if (effect.duration <= 0)
                {
                    effectsToRemove.Add(effect);
                }
            }
        }

        if (effectsToRemove.Count > 0)
        {
            foreach (StatusEffect effect in effectsToRemove) { RemoveStatusEffect(effect); }
        }

        if (targetsToRemove.Count > 0)
        {
            foreach (GameObject t in targetsToRemove) { activeEffects.Remove(t); }
            targetsToRemove.Clear();
        }
    }

    public void ApplyStatusEffect(GameObject target, StatusEffectDataSO effectData)
    { 
        if (target == null || effectData == null) return;

        StatusEffect newEffect = new StatusEffect(target, effectData);

        if (!activeEffects.ContainsKey(target))
        {
            activeEffects[target] = new List<StatusEffect>();
        }

        activeEffects[target].Add(newEffect);
        newEffect.ApplyEffect();
    }

    private void RemoveStatusEffect(StatusEffect effect)
    {
        if (effect == null || effect.target == null) return;

        if (activeEffects.TryGetValue(effect.target, out var effectList))
        {
            effect.RemoveEffect();
            effectList.Remove(effect);
        }
    }
}

/// <summary>
/// 활성화된 개별 상태 효과의 인스턴스 정보를 담는 클래스입니다.
/// </summary>
public class StatusEffect
{
    public GameObject target;
    public StatusEffectDataSO effectData;
    public float duration;

    public StatusEffect(GameObject target, StatusEffectDataSO effectData)
    {
        this.target = target;
        this.effectData = effectData;
        this.duration = effectData.duration;
    }

    // 이 효과가 적용될 때 즉시 실행되는 로직 (주로 스탯 버프/디버프)
    public void ApplyEffect()
    {
        if (target.TryGetComponent<CharacterStats>(out var stats))
        {
            effectData.ApplyEffect(stats);
        }
    }

    // 이 효과가 제거될 때 실행되는 로직 (스탯 원상복구)
    public void RemoveEffect()
    {
        if (target.TryGetComponent<CharacterStats>(out var stats))
        {
            effectData.RemoveEffect(stats);
        }
    }
}

==================== MonsterSpawner.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Gameplay/MonsterSpawner.cs) ====================
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class MonsterSpawner : MonoBehaviour
{
    [Header("스폰 위치 설정")]
    private Transform playerTransform;
    [SerializeField] private float minSpawnRadius = 10f;
    [SerializeField] private float maxSpawnRadius = 15f;

    private Coroutine spawnCoroutine;

    // ★★★ 핵심 수정: StartSpawning의 인자를 List<Wave>로 수정 (Assets.txt 기반) ★★★
    public void StartSpawning(List<Wave> waves)
    {
        Debug.Log("[MonsterSpawner] StartSpawning called.");
        if (spawnCoroutine != null) StopCoroutine(spawnCoroutine);
        spawnCoroutine = StartCoroutine(SpawnRoutine(waves));
    }

    // ★★★ 핵심 수정: StopSpawning() 함수 복원 (CS1061 오류 해결) ★★★
    public void StopSpawning()
    {
        Debug.Log("[MonsterSpawner] StopSpawning called.");
        if (spawnCoroutine != null)
        {
            StopCoroutine(spawnCoroutine);
            spawnCoroutine = null;
        }
    }

    private IEnumerator SpawnRoutine(List<Wave> waves)
    {
        // --- 기존 디버그 로그 보존 ---
        Debug.Log($"[MonsterSpawner] 스폰 루틴 시작. 전달받은 웨이브 개수: {waves.Count}");

        // playerTransform을 찾을 때까지 대기
        while (playerTransform == null)
        {
            var playerController = ServiceLocator.Get<PlayerController>();
            if (playerController != null)
            {
                playerTransform = playerController.transform;
                Debug.Log($"[MonsterSpawner] 성공: ServiceLocator를 통해 PlayerController를 찾아 playerTransform에 할당했습니다.");
            }
            else
            {
                // 아직 Player가 생성/등록되지 않았으면 한 프레임 대기 후 다시 시도
                yield return null; 
            }
        }

        yield return new WaitForSeconds(1f);

        foreach (var wave in waves)
        {
            if (wave.monsterData == null)
            {
                // --- 기존 디버그 로그 보존 ---
                Debug.LogWarning("Wave에 몬스터 데이터가 설정되지 않아 해당 웨이브를 건너뜁니다.");
                continue;
            }

            // ▼▼▼ 방어 코드 추가 ▼▼▼
            if (playerTransform == null)
            {
                Debug.LogWarning("[MonsterSpawner] Player가 파괴되어 스폰을 중단합니다.");
                yield break; // 코루틴 즉시 종료
            }
            // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲

            switch (wave.spawnType)
            {
                case SpawnType.Spread:
                    float spawnInterval = (wave.count > 1 && wave.duration > 0) ? wave.duration / wave.count : 0.5f;
                    for (int i = 0; i < wave.count; i++)
                    {
                        SpawnMonster(wave.monsterData, playerTransform.position);
                        yield return new WaitForSeconds(spawnInterval);
                    }
                    yield return new WaitForSeconds(wave.delayAfterWave);
                    break;

                case SpawnType.Burst:
                    yield return new WaitForSeconds(wave.delayAfterWave);
                    for (int i = 0; i < wave.count; i++)
                    {
                        SpawnMonster(wave.monsterData, playerTransform.position);
                    }
                    break;
            }
        }
    }

    // ★★★ 핵심 수정: MonsterData를 MonsterDataSO로 변경 (CS0246 오류 해결) ★★★
    private void SpawnMonster(MonsterDataSO monsterData, Vector3 center)
    {
        if (monsterData == null)
        {
            // --- 기존 디버그 로그 보존 ---
            Debug.LogWarning("[MonsterSpawner] 스폰 실패! 전달된 MonsterDataSO가 null입니다.");
            return;
        }

        GameObject monsterPrefab = monsterData.prefab;

        if (monsterPrefab == null)
        {
            // --- 기존 디버그 로그 보존 ---
            Debug.LogError($"[MonsterSpawner] 스폰 실패! '{monsterData.monsterName}' 데이터에 프리팹이 연결되지 않았습니다.");
            return;
        }

        Vector2 randomDirection = Random.insideUnitCircle.normalized;
        float randomDistance = Random.Range(minSpawnRadius, maxSpawnRadius);
        Vector3 spawnPosition = center + (Vector3)(randomDirection * randomDistance);

        GameObject monsterInstance = ServiceLocator.Get<PoolManager>().Get(monsterPrefab);

        monsterInstance.transform.position = spawnPosition;

        MonsterController mc = monsterInstance.GetComponent<MonsterController>();
        if (mc != null)
        {
            mc.Initialize(monsterData);
            mc.SetInvulnerable(0.3f);
        }
    }
}

==================== ArtifactManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Gameplay/ArtifactManager.cs) ====================
using System.Collections.Generic;
using UnityEngine;

public class ArtifactManager : MonoBehaviour
{
    [Header("소유 유물")]
    public List<ArtifactDataSO> ownedArtifacts = new List<ArtifactDataSO>();

    private CharacterStats playerStats;

    private void Awake()
    {
        if (!ServiceLocator.IsRegistered<ArtifactManager>())
        {
            ServiceLocator.Register<ArtifactManager>(this);
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void LinkToNewPlayer(CharacterStats newPlayerStats)
    {
        playerStats = newPlayerStats;
        RecalculateArtifactStats();
    }

    public void EquipArtifact(ArtifactDataSO artifact)
    {
        // 1. playerStats가 null이라는 이유로 함수가 조기 종료되지 않도록 조건을 수정합니다.
        if (ownedArtifacts.Contains(artifact)) return;
        
        ownedArtifacts.Add(artifact);
        
        // 2. 스탯 적용 로직은 playerStats 참조가 유효할 때만 실행되도록 if문으로 감싸줍니다.
        if (playerStats != null)
        {
            playerStats.AddModifier(StatType.Attack, new StatModifier(artifact.attackBoostRatio, artifact));
            playerStats.AddModifier(StatType.Health, new StatModifier(artifact.healthBoostRatio, artifact));
            playerStats.AddModifier(StatType.MoveSpeed, new StatModifier(artifact.moveSpeedBoostRatio, artifact));
            playerStats.AddModifier(StatType.CritRate, new StatModifier(artifact.critChanceBoostRatio, artifact));
            playerStats.AddModifier(StatType.CritMultiplier, new StatModifier(artifact.critDamageBoostRatio, artifact));
        }
    }

    private void RecalculateArtifactStats()
    {
        if (playerStats == null) return;

        var allOwnedArtifacts = new List<ArtifactDataSO>(ownedArtifacts);
        foreach (var artifact in allOwnedArtifacts)
        {
            playerStats.RemoveModifiersFromSource(artifact);
        }

        foreach (var artifact in allOwnedArtifacts)
        {
            EquipArtifact(artifact);
        }
    }
}

==================== BulletController.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Gameplay/BulletController.cs) ====================
using UnityEngine;
using System.Collections.Generic; // Added this line

/// <summary>
/// 총알의 행동(이동, 소멸)과 데이터(데미지)를 관리합니다.
/// </summary>
public class BulletController : MonoBehaviour
{
    private Vector2 _direction; // 총알의 이동 방향
    public float speed;       // 총알의 속도 (외부에서 접근 가능하도록 public으로 변경)
    public float damage;        // 총알의 데미지 (PlayerController가 설정해 줌)
    public string shotInstanceID; // [추가] 발사 인스턴스 고유 ID
    public float lifetime = 3f; // 총알의 최대 생존 시간
    public CardDataSO SourceCard { get; private set; } // [추가] 이 총알을 발사한 카드 데이터
    public int _currentPierceCount;
    public HashSet<GameObject> _hitMonsters = new HashSet<GameObject>();


    /// <summary>
    /// 총알을 초기화하고 발사합니다.
    /// </summary>
    /// <param name="direction">총알의 이동 방향 (정규화된 벡터)</param>
    /// <param name="initialSpeed">총알의 초기 속도</param>
    /// <param name="damage">총알이 줄 데미지</param>
    /// <param name="shotID">[추가] 발사 인스턴스 고유 ID</param>

    public void Initialize(Vector2 direction, float initialSpeed, float damage, string shotID, CardDataSO cardData, int pierceCount)
    {
        _direction = direction.normalized; // 방향 벡터 정규화
        speed = initialSpeed; // 초기 속도 설정
        this.damage = damage; // 전달받은 데미지 설정
        this.shotInstanceID = shotID; // [추가] 발사 ID 설정
        this.SourceCard = cardData; // [추가] 카드 데이터 저장
        this._currentPierceCount = pierceCount; // 현재 관통 횟수 저장
        this._hitMonsters.Clear(); // 풀링을 위해 이전에 맞춘 몬스터 목록 초기화

        // 총알의 초기 회전 설정 (선택 사항: 방향에 따라 총알 스프라이트 회전)
        // 예를 들어, Vector2.right가 기본 방향일 때
        float angle = Mathf.Atan2(_direction.y, _direction.x) * Mathf.Rad2Deg;
        transform.rotation = Quaternion.Euler(0, 0, angle);

        // 활성화될 때마다 소멸 타이머를 재시작합니다.
        // Invoke는 간단하지만, 성능이 중요한 경우 코루틴이나 Update에서 직접 시간을 빼는 것이 더 좋습니다.
        Invoke(nameof(Deactivate), lifetime);
    }

    void Update()
    {
        // 매 프레임 지정된 방향으로 이동합니다.
        transform.Translate(_direction * speed * Time.deltaTime, Space.World);
    }

    private void Deactivate()
    {
        ServiceLocator.Get<PoolManager>().Release(gameObject);
    }

    // 몬스터와 충돌했을 때 MonsterController가 이 메서드를 호출하지 않으므로,
    // 이 스크립스는 데미지 값을 가지고 있는 역할만 수행합니다.
    // 충돌 처리는 MonsterController의 OnTriggerEnter2D에서 담당합니다.
}



==================== RewardManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Gameplay/RewardManager.cs) ====================
// 파일 경로: Assets/1.Scripts/Gameplay/RewardManager.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// 게임 플레이 중 발생하는 모든 '보상' 관련 로직을 총괄하는 중앙 관리자입니다.
/// 라운드 승리/패배 여부를 기록하고, 카드 보상 큐를 관리하며, 보상 UI에 필요한 데이터를 제공합니다.
/// </summary>
public class RewardManager : MonoBehaviour
{
    // --- Public Properties --- //

    /// <summary>
    /// 마지막으로 플레이한 라운드에서 승리했는지 여부를 나타냅니다. (현재는 카드 보상에 직접적인 영향을 주지 않지만, 추후 다른 보상 시스템을 위해 유지됩니다.)
    /// </summary>
    public bool LastRoundWon { get; set; } = true;

    /// <summary>
    /// 현재 플레이어가 카드 보상 선택을 완료했는지 여부를 나타내는 중요한 상태 플래그입니다.
    /// true: 보상 선택이 끝났거나, 받을 보상이 없는 상태. (맵 노드 선택 가능)
    /// false: 보상 선택이 진행 중인 상태. (맵 노드 선택 불가, '보상 페이지로' 버튼 활성화)
    /// </summary>
    public bool IsRewardSelectionComplete { get; private set; } = true;


    // --- Private Fields --- //

    /// <summary>
    /// 제시할 카드 보상 목록을 순서대로 저장하는 큐(Queue)입니다.
    /// </summary>
    private Queue<List<CardDataSO>> cardRewardQueue = new Queue<List<CardDataSO>>();


    // --- Events --- //

    /// <summary>
    /// 처리할 새로운 카드 보상이 준비되었을 때 CardRewardUIManager에 알리는 static 이벤트입니다.
    /// </summary>
    public static event System.Action<List<CardDataSO>> OnCardRewardReady;

    /// <summary>
    /// 처리할 보상이 없어 즉시 맵 선택으로 건너뛰어야 할 때 UI에 알리는 static 이벤트입니다.
    /// </summary>
    public static event System.Action OnRewardSkipped;

    // --- Unity Lifecycle Methods --- //

    void Awake()
    {
        // ServiceLocator에 자기 자신을 등록하여 다른 시스템에서 접근할 수 있도록 합니다.
        if (!ServiceLocator.IsRegistered<RewardManager>())
        {
            ServiceLocator.Register<RewardManager>(this);
            // 씬이 전환되어도 파괴되지 않도록 설정합니다.
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    // --- Public Methods --- //

    /// <summary>
    /// 새로운 카드 보상 목록을 큐의 맨 뒤에 추가합니다.
    /// </summary>
    /// <param name="cardChoices">플레이어에게 보여줄 카드 선택지 목록</param>
    public void EnqueueReward(List<CardDataSO> cardChoices)
    {
        cardRewardQueue.Enqueue(cardChoices);
        Debug.Log($"[RewardManager] 새로운 카드 보상이 큐에 추가되었습니다. 현재 대기 중인 보상 수: {cardRewardQueue.Count}");
    }

    /// <summary>
    /// 처리 대기 중인 보상이 있는지 확인합니다.
    /// </summary>
    /// <returns>큐에 보상이 하나 이상 있으면 true, 아니면 false를 반환합니다.</returns>
    public bool HasPendingRewards()
    {
        return cardRewardQueue.Count > 0;
    }

    /// <summary>
    /// 큐에서 다음 보상을 꺼내어 처리하도록 이벤트를 발생시킵니다.
    /// </summary>
    public void ProcessNextReward()
    {
        Debug.Log("[RewardManager] ProcessNextReward() 호출됨.");
        if (cardRewardQueue.Count > 0)
        {
            // [핵심 로직] 보상 처리를 시작하므로, '선택 완료' 상태를 '진행 중' (false)으로 변경합니다.
            // 이 상태는 RouteSelectionController가 '보상 페이지로' 버튼을 활성화하는 데 사용됩니다.
            IsRewardSelectionComplete = false;

            List<CardDataSO> nextReward = cardRewardQueue.Dequeue();
            Debug.Log($"[RewardManager] 다음 보상을 처리합니다. 남은 보상 수: {cardRewardQueue.Count}. 'IsRewardSelectionComplete' 상태를 [false]로 설정.");

            // UI가 이벤트를 구독하고 있다면, 카드 선택지를 전달하여 화면에 표시하도록 합니다.
            Debug.Log("[RewardManager] OnCardRewardReady 이벤트 발생 시도.");
            OnCardRewardReady?.Invoke(nextReward);
        }
        else
        {
            // 처리할 보상이 없는 경우, 바로 완료 상태로 설정하고 '스킵' 이벤트를 발생시킵니다.
            IsRewardSelectionComplete = true;
            Debug.LogWarning("[RewardManager] 처리할 보상이 없어 즉시 맵 선택으로 건너뜁니다. 'IsRewardSelectionComplete' 상태를 [true]로 설정.");
            OnRewardSkipped?.Invoke();
        }
    }

    /// <summary>
    /// 플레이어가 카드 선택(획득, 합성, 스킵)을 완료했을 때 호출됩니다.
    /// </summary>
    public void CompleteRewardSelection()
    {
        // [핵심 로직] 보상 선택이 모두 끝났으므로, 상태를 '완료' (true)로 변경합니다.
        // 이 상태는 RouteSelectionController가 '보상 페이지로' 버튼을 비활성화하는 데 사용됩니다.
        IsRewardSelectionComplete = true;
        Debug.Log("[RewardManager] 카드 보상 선택이 완료되었습니다. 'IsRewardSelectionComplete' 상태를 [true]로 설정.");
    }
}

==================== CharacterStats.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Gameplay/CharacterStats.cs) ====================
using UnityEngine;
using UnityEngine.Events;
using System.Collections.Generic;
using System.Linq;

[RequireComponent(typeof(PlayerHealthBar))]
public class CharacterStats : MonoBehaviour
{
    [Header("기본 능력치")]
    public BaseStats stats;

    [Header("현재 상태 (런타임)")]
    public float currentHealth;
    public bool isInvulnerable = false;

    [Header("이벤트")]
    public UnityEvent OnFinalStatsCalculated = new UnityEvent();

    private PlayerHealthBar playerHealthBar;
    public float cardSelectionInterval = 10f;

    private readonly Dictionary<StatType, List<StatModifier>> statModifiers = new Dictionary<StatType, List<StatModifier>>();

    // [리팩토링] 최종 스탯을 실시간으로 계산하는 프로퍼티 (올바른 StatType 사용)
    public float FinalDamage
    {
        get
        {
            float totalBonusRatio = statModifiers[StatType.Attack].Sum(mod => mod.Value);
            return stats.baseDamage + totalBonusRatio;
        }
    }
    public float FinalAttackSpeed => Mathf.Max(0.1f, CalculateFinalValue(StatType.AttackSpeed, stats.baseAttackSpeed));
    public float FinalMoveSpeed => Mathf.Max(0f, CalculateFinalValue(StatType.MoveSpeed, stats.baseMoveSpeed));
    public float FinalHealth => Mathf.Max(1f, CalculateFinalValue(StatType.Health, stats.baseHealth));
    public float FinalCritRate => Mathf.Clamp(CalculateFinalValue(StatType.CritRate, stats.baseCritRate), 0f, 100f);
    public float FinalCritDamage => Mathf.Max(0f, CalculateFinalValue(StatType.CritMultiplier, stats.baseCritDamage));

    void Awake()
    {
        playerHealthBar = GetComponent<PlayerHealthBar>();
        foreach (StatType type in System.Enum.GetValues(typeof(StatType)))
        {
            statModifiers[type] = new List<StatModifier>();
        }
    }

    void OnDestroy()
    {
        var debugManager = ServiceLocator.Get<DebugManager>();
        if (debugManager != null)
        {
            debugManager.UnregisterPlayer();
        }
    }

    public void AddModifier(StatType type, StatModifier modifier)
    {
        statModifiers[type].Add(modifier);
        CalculateFinalStats();
    }

    public void RemoveModifiersFromSource(object source)
    {
        foreach (var key in statModifiers.Keys)
        {
            statModifiers[key].RemoveAll(mod => mod.Source == source);
        }
        CalculateFinalStats();
    }

    

    private float CalculateFinalValue(StatType type, float baseValue)
    {
        float totalBonusRatio = statModifiers[type].Sum(mod => mod.Value);
        return baseValue * (1 + totalBonusRatio / 100f);
    }

    public void CalculateFinalStats()
    {
        OnFinalStatsCalculated?.Invoke();
    }

    public void TakeDamage(float damage)
    {
        if (isInvulnerable) return;
        currentHealth -= damage;
        playerHealthBar.UpdateHealth(currentHealth, FinalHealth);
        if (currentHealth <= 0)
        {
            currentHealth = 0;
            Die();
        }
    }

    private void Die()
    {
        Debug.Log("[CharacterStats] 플레이어가 사망했습니다. 게임오버 상태로 전환합니다.");
        gameObject.SetActive(false);
        ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.GameOver);
    }

    public void Heal(float amount)
    {
        currentHealth += amount;
        if (currentHealth > FinalHealth) currentHealth = FinalHealth;
        playerHealthBar.UpdateHealth(currentHealth, FinalHealth);
    }

    public void ApplyPermanentStats(CharacterPermanentStats permanentStats)
    {
        if (permanentStats == null) return;
        RemoveModifiersFromSource(StatSources.Permanent);
        foreach (var stat in permanentStats.investedRatios)
        {
            AddModifier(stat.Key, new StatModifier(stat.Value, StatSources.Permanent));
        }
    }

    public void ApplyAllocatedPoints(int points, CharacterPermanentStats permStats)
    {
        if (points <= 0 || permStats == null) return;
        RemoveModifiersFromSource(StatSources.Allocated);

        List<StatType> availableStats = permStats.GetUnlockedStats();
        if (availableStats.Count == 0) return;

        for (int i = 0; i < points; i++)
        {
            StatType targetStat = availableStats[Random.Range(0, availableStats.Count)];
            float weight = GetWeightForStat(targetStat);
            AddModifier(targetStat, new StatModifier(weight, StatSources.Allocated));
        }
    }

    private float GetWeightForStat(StatType stat)
    {
        return stat == StatType.Health ? 2f : 1f;
    }

    public float GetCurrentHealth()
    {
        return currentHealth;
    }

    public static BaseStats CalculatePreviewStats(BaseStats baseStats, int allocatedPoints)
    {
        BaseStats previewStats = new BaseStats();
        float healthGeneBoosterRatio = allocatedPoints * 2f;
        float otherStatsGeneBoosterRatio = allocatedPoints * 1f;

        previewStats.baseHealth = baseStats.baseHealth * (1 + healthGeneBoosterRatio / 100f);
        previewStats.baseDamage = baseStats.baseDamage * (1 + otherStatsGeneBoosterRatio / 100f);
        previewStats.baseAttackSpeed = baseStats.baseAttackSpeed * (1 + otherStatsGeneBoosterRatio / 100f);
        previewStats.baseMoveSpeed = baseStats.baseMoveSpeed * (1 + otherStatsGeneBoosterRatio / 100f);
        previewStats.baseCritDamage = baseStats.baseCritDamage * (1 + otherStatsGeneBoosterRatio / 100f);
        previewStats.baseCritRate = baseStats.baseCritRate;
        return previewStats;
    }
}

==================== DamagingZone.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Gameplay/DamagingZone.cs) ====================
using UnityEngine;
using System.Collections.Generic;

public class DamagingZone : MonoBehaviour
{
    [Header(" ")]
    public float singleHitDamage = 0f;
    public float damagePerTick = 10f;
    [Tooltip("     ִ  (). ĵ   100 ̻ Էϼ.")]
    public float tickInterval = 1.0f;
    public float duration = 5.0f;

    [Header("ĵ/ Ȯ ")]
    public float expansionSpeed = 1.0f;
    public float expansionDuration = 2.0f;

    public string shotInstanceID;
    public bool isSingleHitWaveMode = true;

    private List<MonsterController> targets = new List<MonsterController>();
    private float tickTimer;
    private float durationTimer;
    private float expansionTimer;
    private CircleCollider2D circleCollider;
    private Vector3 initialScale;
    private float initialColliderRadius;

    void Awake()
    {
        initialScale = transform.localScale;
        circleCollider = GetComponent<CircleCollider2D>();
        if (circleCollider != null)
        {
            initialColliderRadius = circleCollider.radius;
        }
    }

    void OnEnable()
    {
        tickTimer = 0f;
        durationTimer = duration;
        expansionTimer = 0f;
        transform.localScale = initialScale;
        targets.Clear();
    }

    public void Initialize(float singleHitDmg, float continuousDmgPerTick, float tickInt, float totalDur, float expSpeed, float expDur, bool isWave, string shotID)
    {
        this.singleHitDamage = singleHitDmg;
        this.damagePerTick = continuousDmgPerTick;
        this.tickInterval = tickInt;
        this.duration = totalDur;
        this.expansionSpeed = expSpeed;
        this.expansionDuration = expDur;
        this.isSingleHitWaveMode = isWave;
        this.shotInstanceID = shotID;
        OnEnable();
    }

    void Update()
    {
        durationTimer -= Time.deltaTime;
        if (durationTimer <= 0)
        {
            // --- [] PoolManager ȣ ڵ带 ϳ մϴ. ---
            var poolManager = ServiceLocator.Get<PoolManager>();
            if (poolManager != null)
                poolManager.Release(gameObject);
            else
                Destroy(gameObject);
            return;
        }

        if (expansionTimer < expansionDuration)
        {
            expansionTimer += Time.deltaTime;
            transform.localScale += Vector3.one * expansionSpeed * Time.deltaTime;
        }

        if (!isSingleHitWaveMode)
        {
            tickTimer += Time.deltaTime;
            if (tickTimer >= tickInterval)
            {
                tickTimer = 0f;
                ApplyDamageToTargets();
            }
        }
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Monster"))
        {
            MonsterController monster = other.GetComponent<MonsterController>();
            if (monster == null) return;

            if (isSingleHitWaveMode)
            {
                if (!monster.hitShotIDs.Contains(this.shotInstanceID))
                {
                    monster.hitShotIDs.Add(this.shotInstanceID);
                    monster.TakeDamage(this.singleHitDamage);
                }
            }
            else
            {
                if (!targets.Contains(monster))
                {
                    targets.Add(monster);
                }
            }
        }
    }

    private void OnTriggerExit2D(Collider2D other)
    {
        if (other.CompareTag("Monster"))
        {
            MonsterController monster = other.GetComponent<MonsterController>();
            if (monster == null) return;

            if (!isSingleHitWaveMode)
            {
                if (targets.Contains(monster))
                {
                    targets.Remove(monster);
                }
            }
        }
    }

    private void ApplyDamageToTargets()
    {
        List<MonsterController> currentTargets = new List<MonsterController>(targets);
        foreach (var monster in currentTargets)
        {
            if (monster != null && monster.gameObject.activeInHierarchy)
            {
                monster.TakeDamage(damagePerTick);
            }
        }
    }
}

==================== RoundManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Gameplay/RoundManager.cs) ====================
using System.Collections;
using UnityEngine;
using System.Collections.Generic; // [1] using 문 추가
using System.Linq;                 // [2] using 문 추가

/// <summary>
/// 개별 전투 라운드의 시작, 진행, 종료를 관리하는 클래스입니다.
/// 몬스터 스폰, 킬 카운트, 제한 시간 등 라운드와 관련된 모든 핵심 로직을 담당합니다.
/// </summary>
public class RoundManager : MonoBehaviour
{
    // --- Events --- //
    public static event System.Action<RoundDataSO> OnRoundStarted;
    public static event System.Action<int, int> OnKillCountChanged;
    public static event System.Action<float> OnTimerChanged;
    public static event System.Action<bool> OnRoundEnded; // bool: 승리 여부

    // ▼▼▼ [3] Inspector에서 보상 카드 수를 설정할 변수 추가 ▼▼▼
    [Header("보상 설정")]
    [SerializeField] private int numberOfRewardChoices = 3;

    // --- Private State Fields --- //
    private MonsterSpawner monsterSpawner;
    private RoundDataSO currentRoundData;
    private int killCount;
    private float roundTimer;
    private bool isRoundActive;
    private Coroutine roundTimerCoroutine; // [1] 코루틴을 저장할 변수 추가

    // --- Unity Lifecycle Methods --- //
    void Awake()
    {
        monsterSpawner = GetComponent<MonsterSpawner>();
        if (monsterSpawner == null)
        {
            Debug.LogError($"[{GetType().Name}] CRITICAL: MonsterSpawner 컴포넌트를 찾을 수 없습니다! 몬스터가 스폰되지 않습니다.", this.gameObject);
        }
    }

    // ▼▼▼ [2] OnEnable, OnDisable 함수를 추가/수정하여 GameManager의 이벤트를 구독 ▼▼▼
    void OnEnable()
    {
        MonsterController.OnMonsterDied += HandleMonsterDied;
        
        // GameManager가 존재할 때만 이벤트를 구독하도록 예외 처리
        var gameManager = ServiceLocator.Get<GameManager>();
        if (gameManager != null)
        {
            gameManager.OnGameStateChanged += HandleGameStateChanged;
        }
    }

    void OnDisable()
    {
        MonsterController.OnMonsterDied -= HandleMonsterDied;

        var gameManager = ServiceLocator.Get<GameManager>();
        if (gameManager != null)
        {
            gameManager.OnGameStateChanged -= HandleGameStateChanged;
        }
    }
    
    // --- Public Methods --- //

    /// <summary>
    /// 새로운 라운드를 시작합니다.
    /// </summary>
    /// <param name="roundData">시작할 라운드의 데이터</param>
    public IEnumerator StartRound(RoundDataSO roundData)
    {
        if (isRoundActive)
        {
            Debug.LogWarning($"[{GetType().Name}] 경고: 이미 라운드가 진행 중일 때 StartRound가 호출되었습니다. 이전 라운드를 강제 종료하고 새 라운드를 시작합니다.");
            yield return StartCoroutine(EndRoundCoroutine(false));
        }

        currentRoundData = roundData;
        Debug.Log($"[{GetType().Name}] 새로운 라운드 시작: '{currentRoundData.name}' (목표 킬: {currentRoundData.killGoal}, 제한 시간: {currentRoundData.roundDuration}초)");

        // --- 플레이어 스탯 로그 (라운드 시작) ---
        var playerController = ServiceLocator.Get<PlayerController>();
        if (playerController != null)
        {
            var playerStats = playerController.GetComponent<CharacterStats>();
            if (playerStats != null)
            {
                System.Text.StringBuilder sb = new System.Text.StringBuilder();
                sb.AppendLine("--- 라운드 시작 플레이어 스탯 ---");
                sb.AppendLine($"체력: {playerStats.currentHealth:F1} / {playerStats.FinalHealth:F1}");
                sb.AppendLine($"공격력 보너스: {playerStats.FinalDamage:F2}%");
                sb.AppendLine($"공격 속도: {playerStats.FinalAttackSpeed:F2}");
                sb.AppendLine($"이동 속도: {playerStats.FinalMoveSpeed:F2}");
                sb.AppendLine($"치명타 확률: {playerStats.FinalCritRate:F2}%");
                sb.AppendLine($"치명타 피해: {playerStats.FinalCritDamage:F2}%");
                Debug.Log(sb.ToString());
            }
        }
        // --- 플레이어 스탯 로그 끝 ---

        // 라운드 상태 초기화
        killCount = 0;
        roundTimer = currentRoundData.roundDuration;
        isRoundActive = true;

        // 이벤트 구독
        // MonsterController.OnMonsterDied += HandleMonsterDied; // <-- 이 줄을 제거하세요!

        // UI 및 다른 시스템에 라운드 시작 알림
        OnRoundStarted?.Invoke(currentRoundData);

        // 몬스터 스폰 시작
        if (monsterSpawner != null)
        {
            // [수정] 사용자님이 공유해주신 RoundDataSO의 정확한 변수명인 'waves'를 사용합니다.
            monsterSpawner.StartSpawning(currentRoundData.waves);
        }

        // 라운드 타이머 코루틴 시작
        roundTimerCoroutine = StartCoroutine(RoundTimerCoroutine()); // 코루틴 참조를 저장
        yield return roundTimerCoroutine;
    }

    // --- Coroutines --- //

    private IEnumerator RoundTimerCoroutine()
    {
        Debug.Log($"[{GetType().Name}] 라운드 타이머 코루틴이 시작되었습니다.");
        while (roundTimer > 0 && isRoundActive)
        {
            roundTimer -= Time.deltaTime;
            OnTimerChanged?.Invoke(roundTimer);
            yield return null;
        }

        if (isRoundActive)
        {
            Debug.Log($"[{GetType().Name}] 시간 초과. 라운드를 종료합니다.");
            StartCoroutine(EndRoundCoroutine(false));
        }
    }

    private IEnumerator EndRoundCoroutine(bool wasKillGoalReached)
    {
        if (!isRoundActive) yield break;

        isRoundActive = false;
        roundTimerCoroutine = null; // 코루틴이 끝났으므로 참조를 비워줍니다.
        Debug.Log($"[{GetType().Name}] 라운드 종료 코루틴 시작. (승리: {wasKillGoalReached})");

        // --- 플레이어 스탯 로그 (라운드 종료) ---
        var playerController = ServiceLocator.Get<PlayerController>();
        if (playerController != null)
        {
            var playerStats = playerController.GetComponent<CharacterStats>();
            if (playerStats != null)
            {
                System.Text.StringBuilder sb = new System.Text.StringBuilder();
                sb.AppendLine("--- 라운드 종료 플레이어 스탯 ---");
                sb.AppendLine($"체력: {playerStats.currentHealth:F1} / {playerStats.FinalHealth:F1}");
                sb.AppendLine($"공격력 보너스: {playerStats.FinalDamage:F2}%");
                sb.AppendLine($"공격 속도: {playerStats.FinalAttackSpeed:F2}");
                sb.AppendLine($"이동 속도: {playerStats.FinalMoveSpeed:F2}");
                sb.AppendLine($"치명타 확률: {playerStats.FinalCritRate:F2}%");
                sb.AppendLine($"치명타 피해: {playerStats.FinalCritDamage:F2}%");
                Debug.Log(sb.ToString());
            }
        }
        // --- 플레이어 스탯 로그 끝 ---

        MonsterController.OnMonsterDied -= HandleMonsterDied;
        OnRoundEnded?.Invoke(wasKillGoalReached);

        if (monsterSpawner != null)
        {
            monsterSpawner.StopSpawning();
        }

        var rewardManager = ServiceLocator.Get<RewardManager>();
        if (rewardManager != null)
        {
            rewardManager.LastRoundWon = wasKillGoalReached;
            Debug.Log($"[{GetType().Name}] RewardManager에 라운드 결과({(wasKillGoalReached ? "승리" : "패배")})를 기록했습니다.");

        // ============ [핵심 추가 기능: 승리 시 보상 생성] ============
        if (wasKillGoalReached)
        {
            Debug.Log($"[{GetType().Name}] 라운드 승리! 카드 보상을 생성합니다.");
            var dataManager = ServiceLocator.Get<DataManager>();
            if (dataManager != null)
            {
                List<CardDataSO> allCards = dataManager.GetAllCards();
                List<CardDataSO> rewardChoices = new List<CardDataSO>();
                
                // 카드 데이터가 충분한지 확인
                if (allCards.Count >= numberOfRewardChoices)
                {
                    // 가중치에 따라 랜덤 카드 선택 (중복 없음)
                    List<CardDataSO> selectableCards = new List<CardDataSO>(allCards);
                    for (int i = 0; i < numberOfRewardChoices; i++)
                    {
                        if (selectableCards.Count == 0) break;

                        float totalWeight = selectableCards.Sum(card => card.rewardAppearanceWeight);

                        // ▼▼▼▼▼ [핵심 수정] 이 부분을 추가하세요 ▼▼▼▼▼
                        // 만약 모든 카드의 가중치가 0이라면, 가중치 없이 완전 랜덤으로 하나를 고릅니다.
                        if (totalWeight <= 0)
                        {
                            int randomIndex = Random.Range(0, selectableCards.Count);
                            rewardChoices.Add(selectableCards[randomIndex]);
                            selectableCards.RemoveAt(randomIndex);
                            continue; // 다음 카드를 뽑기 위해 for문의 다음 루프로 넘어갑니다.
                        }
                        // ▲▲▲▲▲ [여기까지 추가] ▲▲▲▲▲

                        float randomPoint = Random.Range(0, totalWeight);
                        float currentWeight = 0f;
                        CardDataSO selectedCard = null;

                        foreach (var card in selectableCards)
                        {
                            currentWeight += card.rewardAppearanceWeight;
                            if (randomPoint <= currentWeight)
                            {
                                selectedCard = card;
                                break;
                            }
                        }

                        // 만약 부동소수점 오류 등으로 선택이 안된 경우 마지막 카드를 선택
                        if (selectedCard == null && selectableCards.Count > 0)
                        {
                            selectedCard = selectableCards.Last();
                        }

                        if (selectedCard != null)
                        {
                            rewardChoices.Add(selectedCard);
                            selectableCards.Remove(selectedCard);
                        }
                    }
                }

                // 생성된 보상이 있으면 RewardManager의 대기열에 추가
                if (rewardChoices.Count > 0)
                {
                    rewardManager.EnqueueReward(rewardChoices);
                }
                else
                {
                    Debug.LogWarning($"[{GetType().Name}] 보상으로 제시할 카드를 생성하지 못했습니다. (카드 데이터 부족 가능성)");
                }
            }
        }
        else
        {
            Debug.Log($"[{GetType().Name}] 라운드 패배. 카드 보상을 생성하지 않습니다.");
        }
        // =============================================================
        }
        else
        {
            Debug.LogError($"[{GetType().Name}] CRITICAL: RewardManager를 찾을 수 없어 라운드 결과를 기록할 수 없습니다!");
        }

        // PoolManager를 통해 활성화된 모든 오브젝트(몬스터, 총알 등)를 정리합니다.
        var poolManager = ServiceLocator.Get<PoolManager>();
        if (poolManager != null)
        {
            poolManager.ClearAllActiveObjects();
        }

        Debug.Log($"[{GetType().Name}] GameManager 상태 변경 요청: {GameManager.GameState.Reward}");
        ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.Reward);
    }

    // --- Event Handlers --- //

    // ▼▼▼ [4] GameManager의 상태 변경을 감지할 핸들러 함수 추가 ▼▼▼
    private void HandleGameStateChanged(GameManager.GameState newState)
    {
        // 게임 상태가 '게임오버'로 바뀌면, 라운드 매니저의 모든 활동을 즉시 중단시킵니다.
        if (newState == GameManager.GameState.GameOver)
        {
            Debug.Log($"[{GetType().Name}] 게임오버 상태를 감지했습니다. 라운드 타이머를 강제 종료합니다.");
            isRoundActive = false;
            
            // 실행 중인 타이머 코루틴이 있다면 중지시킵니다.
            if (roundTimerCoroutine != null)
            {
                StopCoroutine(roundTimerCoroutine);
                roundTimerCoroutine = null;
            }
        }
    }

    // --- Event Handlers --- //

    private void HandleMonsterDied(MonsterController monster)
    {
        if (!isRoundActive) return;

        killCount++;
        Debug.Log($"[{GetType().Name}] 몬스터 처치. 현재 킬 수: {killCount}/{currentRoundData.killGoal}");
        OnKillCountChanged?.Invoke(killCount, currentRoundData.killGoal);

        if (killCount >= currentRoundData.killGoal)
        {
            Debug.Log($"[{GetType().Name}] 목표 킬 수를 달성했습니다! 라운드를 승리로 종료합니다.");
            StartCoroutine(EndRoundCoroutine(true));
        }
    }
}

==================== PlayerInitializer.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Gameplay/PlayerInitializer.cs) ====================
// --- 파일 위치: Assets/1/Scripts/Gameplay/PlayerInitializer.cs ---

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;

/// <summary>
/// 게임 시작 시 플레이어 오브젝트를 초기화하는 역할을 담당합니다. (최종 수정 버전)
/// </summary>
public class PlayerInitializer : MonoBehaviour
{
    [Header("테스트용 시작 카드 목록")]
    [Tooltip("캐릭터 데이터(SO)에 시작 카드가 설정되어 있으면, 이 목록은 무시됩니다.")]
    [SerializeField] private List<CardDataSO> testStartingCards;

    void Start()
    {
        EventSystem.current.SetSelectedGameObject(null);

        var playerStats = GetComponent<CharacterStats>();
        var playerController = GetComponent<PlayerController>();
        var gameManager = ServiceLocator.Get<GameManager>();
        var playerSpriteRenderer = GetComponent<SpriteRenderer>();
        var debugManager = ServiceLocator.Get<DebugManager>();

        if (debugManager != null)
        {
            debugManager.RegisterPlayer(playerStats);
        }

        CharacterDataSO characterToLoad = gameManager.SelectedCharacter ?? ServiceLocator.Get<DataManager>().GetCharacter(CharacterIDs.Warrior);
        if (characterToLoad == null)
        {
            Debug.LogError("CRITICAL: 적용할 캐릭터 데이터를 찾을 수 없습니다!");
            return;
        }

        playerStats.stats = characterToLoad.baseStats;
        playerSpriteRenderer.sprite = characterToLoad.illustration;

        var cardManager = ServiceLocator.Get<CardManager>();
        var artifactManager = ServiceLocator.Get<ArtifactManager>();

        if (gameManager.isFirstRound)
        {
            Debug.Log("<color=lime>[PlayerInitializer] 첫 라운드입니다. 시작 아이템과 영구 스탯을 적용합니다.</color>");

            // 매니저들에게 새로운 플레이어 정보를 연결합니다.
            if (cardManager != null) cardManager.LinkToNewPlayer(playerStats);
            if (artifactManager != null) artifactManager.LinkToNewPlayer(playerStats);

            // 첫 라운드에만 영구 스탯 적용 및 시작 아이템을 지급합니다.
            var progressionManager = ServiceLocator.Get<ProgressionManager>();
            CharacterPermanentStats permanentStats = progressionManager.GetPermanentStatsFor(characterToLoad.characterId);
            playerStats.ApplyPermanentStats(permanentStats);
            playerStats.ApplyAllocatedPoints(gameManager.AllocatedPoints, permanentStats);
            EquipStartingItems(characterToLoad, cardManager, artifactManager);

            gameManager.isFirstRound = false;
        }
        else
        {
            // ▼▼▼ [핵심 수정] 로그를 먼저 출력하고, 이후에 LinkToNewPlayer를 호출합니다. ▼▼▼
            Debug.Log("<color=yellow>[PlayerInitializer] 이후 라운드입니다. 기존 카드/유물 정보를 유지(재계산)합니다.</color>");

            // 이후 라운드에서는 새 플레이어 정보만 연결해주면, LinkToNewPlayer가 알아서 기존 상태를 복원합니다.
            if (cardManager != null) cardManager.LinkToNewPlayer(playerStats);
            if (artifactManager != null) artifactManager.LinkToNewPlayer(playerStats);
        }

        // 공통 마무리 (매 라운드 실행)
        playerStats.CalculateFinalStats();
        playerStats.currentHealth = playerStats.FinalHealth;
        if (cardManager != null) cardManager.StartCardSelectionLoop();
        if (playerController != null) playerController.StartAutoAttackLoop();
    }

    private void EquipStartingItems(CharacterDataSO characterData, CardManager cardManager, ArtifactManager artifactManager)
    {
        List<CardDataSO> cardsToEquip = new List<CardDataSO>();
        if (testStartingCards != null && testStartingCards.Count > 0)
        {
            cardsToEquip.AddRange(testStartingCards);
        }
        else if (characterData.startingCard != null)
        {
            cardsToEquip.Add(characterData.startingCard);
        }

        if (cardsToEquip.Count > 0 && cardManager != null)
        {
            foreach (var card in cardsToEquip)
            {
                if (card != null)
                {
                    cardManager.AddCard(card);
                    cardManager.Equip(card);
                }
            }
        }

        if (characterData.startingArtifacts != null && characterData.startingArtifacts.Count > 0)
        {
            if (artifactManager != null)
            {
                foreach (var artifact in characterData.startingArtifacts)
                {
                    if (artifact != null) artifactManager.EquipArtifact(artifact);
                }
            }
        }
    }
}

==================== CardManager.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Gameplay/CardManager.cs) ====================
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class CardManager : MonoBehaviour
{
    [Header("카드 목록")]
    public List<CardDataSO> ownedCards = new List<CardDataSO>();
    public List<CardDataSO> equippedCards = new List<CardDataSO>();

    [Header("슬롯 설정")]
    public int maxOwnedSlots = 7;
    public int maxEquipSlots = 5;

    [Header("실시간 카드 상태")]
    public CardDataSO activeCard;

    private CharacterStats playerStats;

    private void Awake()
    {
        // ServiceLocator에 CardManager가 아직 등록되지 않았다면,
        if (!ServiceLocator.IsRegistered<CardManager>())
        {
            // 자기 자신을 최초의 인스턴스로 등록하고 파괴되지 않도록 설정합니다.
            ServiceLocator.Register<CardManager>(this);
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            // 만약 이미 등록된 CardManager가 있다면, 지금 생성된 나는 중복이므로 스스로를 파괴합니다.
            Destroy(gameObject);
        }
    }

    void OnEnable()
    {
        RoundManager.OnRoundEnded += HandleRoundEnd;
    }

    void OnDisable()
    {
        RoundManager.OnRoundEnded -= HandleRoundEnd;
    }

    private void HandleRoundEnd(bool success)
    {
        CancelInvoke(nameof(SelectActiveCard));
    }

    public void LinkToNewPlayer(CharacterStats newPlayerStats)
    {
        playerStats = newPlayerStats;
        RecalculateCardStats();
    }

    public void AcquireNewCard(CardDataSO newCard)
    {
        if (ownedCards.Count >= maxOwnedSlots)
        {
            CardDataSO cardToRemoveFromOwned = ownedCards[0];
            if (equippedCards.Contains(cardToRemoveFromOwned))
            {
                Unequip(cardToRemoveFromOwned);
            }
            ownedCards.RemoveAt(0);
        }
        ownedCards.Add(newCard);
        Debug.Log($"[CardManager] 카드 획득: <color=green>{newCard.cardName}</color>. 현재 보유 카드 수: {ownedCards.Count}");

        if (equippedCards.Count < maxEquipSlots)
        {
            Equip(newCard);
        }
        else
        {
            int randomIndex = Random.Range(0, equippedCards.Count);
            CardDataSO cardToUnequip = equippedCards[randomIndex];
            Debug.LogWarning($"[CardManager] 장착 슬롯이 가득 차({equippedCards.Count}/{maxEquipSlots}), 랜덤 카드 '<color=orange>{cardToUnequip.cardName}</color>'을(를) 제거하고 '<color=yellow>{newCard.cardName}</color>'을(를) 장착합니다.");
            Unequip(cardToUnequip);
            Equip(newCard);
        }

        PrintEquippedCards("AcquireNewCard 직후");
    }

    public void AddCard(CardDataSO cardToAdd)
    {
        if (ownedCards.Count >= maxOwnedSlots) return;
        ownedCards.Add(cardToAdd);
    }

    public bool Equip(CardDataSO card)
    {
        // 1. playerStats가 null이라는 이유만으로 함수가 종료되지 않도록 조건을 수정합니다.
        if (equippedCards.Count >= maxEquipSlots || !ownedCards.Contains(card) || equippedCards.Contains(card))
        {
            // 실패 로그는 그대로 두거나 필요에 맞게 수정합니다.
            // Debug.LogError($"[Equip 실패] 슬롯 부족, 미소유, 또는 중복 장착 시도: {card.cardName}");
            return false;
        }

        equippedCards.Add(card);

        // 2. 스탯 적용 로직은 playerStats 참조가 유효할 때만 실행되도록 합니다.
        if (playerStats != null)
        {
            playerStats.AddModifier(StatType.Attack, new StatModifier(card.damageMultiplier, card));
            playerStats.AddModifier(StatType.AttackSpeed, new StatModifier(card.attackSpeedMultiplier, card));
            playerStats.AddModifier(StatType.MoveSpeed, new StatModifier(card.moveSpeedMultiplier, card));
            playerStats.AddModifier(StatType.Health, new StatModifier(card.healthMultiplier, card));
            playerStats.AddModifier(StatType.CritRate, new StatModifier(card.critRateMultiplier, card));
            playerStats.AddModifier(StatType.CritMultiplier, new StatModifier(card.critDamageMultiplier, card));
        }

        return true;
    }
    public bool Unequip(CardDataSO card)
    {
        // playerStats와 무관하게 리스트에서는 항상 제거되도록 합니다.
        bool removed = equippedCards.Remove(card);

        if (removed && playerStats != null) // 제거에 성공했고, playerStats가 유효할 때만 스탯을 되돌립니다.
        {
            playerStats.RemoveModifiersFromSource(card);
        }

        return removed;
    }
    private void RecalculateCardStats()
    {
        if (playerStats == null) return;

        // ▼▼▼ 1. 함수 진입 직후 상태 ▼▼▼
        PrintEquippedCards("RecalculateCardStats 진입");

        var allOwnedCards = new List<CardDataSO>(ownedCards);
        foreach (var card in allOwnedCards)
        {
            playerStats.RemoveModifiersFromSource(card);
        }

        var currentEquippedCards = new List<CardDataSO>(equippedCards);
        
        // ▼▼▼ 2. 임시 리스트 복사 후 상태 ▼▼▼
        var tempCardNames = currentEquippedCards.Select(c => c.cardName).ToArray();
        Debug.Log($"[디버그 추적] 임시 리스트 복사 완료 | 개수: {currentEquippedCards.Count} | 목록: [{string.Join(", ", tempCardNames)}]");

        equippedCards.Clear();
        
        // ▼▼▼ 3. Clear() 직후 상태 ▼▼▼
        PrintEquippedCards("equippedCards.Clear() 직후");

        foreach (var card in currentEquippedCards)
        {
            // ▼▼▼ 4. 재장착 시도하는 카드 정보 ▼▼▼
            Debug.Log($"[디버그 추적] '{card.cardName}' 재장착 시도...");
            Equip(card);
        }
        
        // ▼▼▼ 5. 함수 종료 직전 최종 상태 ▼▼▼
        PrintEquippedCards("RecalculateCardStats 종료");
    }

    public List<CardDataSO> GetEquippedCards()
    {
        return new List<CardDataSO>(equippedCards);
    }

    public void StartCardSelectionLoop()
    {
        CancelInvoke(nameof(SelectActiveCard));
        float interval = (playerStats != null) ? playerStats.cardSelectionInterval : 10f;
        InvokeRepeating(nameof(SelectActiveCard), 0f, interval);
        SelectActiveCard();
    }

    // ▼▼▼ [핵심 수정] SelectActiveCard 함수를 아래 내용으로 완전히 교체합니다. ▼▼▼
    private void SelectActiveCard()
    {
        if (equippedCards.Count == 0)
        {
            activeCard = null;
            return;
        }

        // 가중치가 0보다 큰 카드만 선택 후보로 간주합니다.
        var selectableCards = equippedCards.Where(c => c.selectionWeight > 0).ToList();
        if (selectableCards.Count == 0)
        {
            // 모든 카드의 가중치가 0이라면, 그냥 첫 번째 카드를 선택합니다.
            activeCard = equippedCards[0];
        }
        else
        {
            float totalWeight = selectableCards.Sum(card => card.selectionWeight);
            float randomPoint = Random.Range(0, totalWeight);
            float currentWeightSum = 0f;

            foreach (var card in selectableCards)
            {
                currentWeightSum += card.selectionWeight;
                if (randomPoint <= currentWeightSum)
                {
                    activeCard = card;
                    break; // 카드를 선택했으므로 루프를 즉시 종료합니다.
                }
            }
        }

        if (activeCard != null)
        {
            Debug.Log($"[CardManager] <color=cyan>활성 카드 선택됨: {activeCard.cardName}</color>");
        }
    }

    public bool HasSynthesizablePair(CardDataSO card)
    {
        if (card == null) return false;
        return ownedCards.Any(ownedCard => ownedCard.type == card.type && ownedCard.rarity == card.rarity);
    }

    public List<CardDataSO> GetSynthesizablePairs(CardDataSO card)
    {
        return ownedCards.Where(ownedCard => ownedCard.type == card.type && ownedCard.rarity == card.rarity).ToList();
    }

    public void SynthesizeCards(CardDataSO rewardCard, CardDataSO materialCard)
    {
        bool wasEquipped = equippedCards.Contains(materialCard);
        if (wasEquipped) Unequip(materialCard);
        ownedCards.Remove(materialCard);

        CardDataSO baseCard = Random.Range(0, 2) == 0 ? rewardCard : materialCard;
        CardDataSO enhancedCard = Instantiate(baseCard);
        enhancedCard.name = baseCard.name + "_Synth";
        enhancedCard.cardName = baseCard.cardName + "+";
        if (enhancedCard.baseDamage > 0) enhancedCard.baseDamage *= 1.1f;

        ownedCards.Add(enhancedCard);
        if (wasEquipped) Equip(enhancedCard);
    }

    public void ClearAndResetDeck()
    {
        ownedCards.Clear();
        equippedCards.Clear();
        Debug.LogWarning("[CardManager] 새 게임 시작. 모든 보유/장착 카드 목록을 초기화합니다.");
    }

    private void PrintEquippedCards(string context)
    {
        var cardNames = equippedCards.Select(c => c.cardName).ToArray();
        string cardList = string.Join(", ", cardNames);
        Debug.Log($"[디버그 추적] {context} | 장착 카드 수: {equippedCards.Count} | 목록: [{cardList}]");
    }
}

==================== WaveHandler.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Gameplay/CardEffectHandlers/WaveHandler.cs) ====================
using UnityEngine;
using System;

/// <summary>
/// 'Wave' 타입의 카드 효과(파동, 장판 등)를 처리하는 클래스입니다.
/// </summary>
public class WaveHandler : ICardEffectHandler
{
    public void Execute(CardDataSO cardData, EffectExecutor executor, CharacterStats casterStats, Transform spawnPoint)
    {
        GameObject wavePrefab = cardData.effectPrefab;
        if (wavePrefab == null)
        { 
            Debug.LogError($"[WaveHandler] 오류: 웨이브 카드 '{cardData.cardName}'에 effectPrefab이 할당되지 않았습니다!");
            return;
        }

        // 풀 매니저에서 웨이브 오브젝트를 가져옵니다.
        GameObject waveGO = ServiceLocator.Get<PoolManager>().Get(wavePrefab);

        if (waveGO == null) return;

        // 효과 생성 위치를 지정합니다.
        waveGO.transform.position = spawnPoint.position;

        if (waveGO.TryGetComponent<DamagingZone>(out var zone))
        {
            float totalDamage = executor.CalculateTotalDamage(cardData, casterStats);
            string shotID = Guid.NewGuid().ToString();

            Debug.Log($"[디버그 최종 확인] DamagingZone 초기화 정보:" +
              $"\n - 카드 이름: <color=yellow>{cardData.name}</color>" +
              $"\n - 지속 대미지(effectDamagePerTick): <color=red>{cardData.effectDamagePerTick}</color>" +
              $"\n - 단일 대미지(baseDamage): {cardData.baseDamage}" +
              $"\n - 장판 모드(isSingleHitWaveMode): {!cardData.isEffectSingleHitWaveMode}");


            // DamagingZone을 카드 데이터에 맞게 초기화합니다.
            zone.Initialize(
                singleHitDmg: totalDamage,
                continuousDmgPerTick: cardData.effectDamagePerTick,
                tickInt: cardData.effectTickInterval,
                totalDur: cardData.effectDuration,
                expSpeed: cardData.effectExpansionSpeed,
                expDur: cardData.effectExpansionDuration,
                isWave: cardData.isEffectSingleHitWaveMode,
                shotID: shotID
            );
        }
        else
        {
            Debug.LogError($"[WaveHandler] 오류: '{wavePrefab.name}' 프리팹에 DamagingZone.cs 스크립트가 없습니다!");
        }
    }
}

==================== ICardEffectHandler.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Gameplay/CardEffectHandlers/ICardEffectHandler.cs) ====================
using UnityEngine;

/// <summary>
/// 모든 카드 효과 처리기(Handler)가 구현해야 하는 인터페이스입니다.
/// 전략 패턴(Strategy Pattern)을 사용하여 각 카드 효과를 별도 클래스로 캡슐화합니다.
/// </summary>
public interface ICardEffectHandler
{
    /// <summary>
    /// 카드 효과를 실행합니다.
    /// </summary>
    /// <param name="cardData">실행할 효과가 담긴 카드 데이터입니다.</param>
    /// <param name="executor">다른 시스템에 접근할 때 사용하는 EffectExecutor의 인스턴스입니다.</param>
    /// <param name="casterStats">효과를 시전하는 주체의 CharacterStats입니다.</param>
    /// <param name="spawnPoint">효과가 생성될 위치입니다. (예: 총구 위치, 플레이어의 발사 지점)</param>
    void Execute(CardDataSO cardData, EffectExecutor executor, CharacterStats casterStats, Transform spawnPoint);
}

==================== SplitShotHandler.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Gameplay/CardEffectHandlers/SplitShotHandler.cs) ====================
using UnityEngine;
using System;

/// <summary>
/// 'SplitShot' 타입의 카드 효과를 처리하는 클래스입니다.
/// </summary>
public class SplitShotHandler : ICardEffectHandler
{
    public void Execute(CardDataSO cardData, EffectExecutor executor, CharacterStats casterStats, Transform spawnPoint)
    {
        GameObject bulletPrefab = cardData.bulletPrefab;
        if (bulletPrefab == null)
        {
            Debug.LogError($"[SplitShotHandler] 오류: 스플릿샷 카드 '{cardData.cardName}'에 bulletPrefab이 할당되지 않았습니다!");
            return;
        }


        // 기본 발사 각도를 계산합니다.
        float baseAngle = executor.GetTargetingAngle(cardData.targetingType, casterStats.transform, spawnPoint);

        // 발사할 총알의 개수, 각도 등을 계산합니다.
        int projectileCount = Mathf.Max(1, (int)cardData.triggerValue);
        float angleStep = 360f / projectileCount;
        float totalDamage = executor.CalculateTotalDamage(cardData, casterStats);
        string shotID = Guid.NewGuid().ToString(); // 모든 총알에 대해 동일한 관통 ID를 사용합니다.

        for (int i = 0; i < projectileCount; i++)
        {
            // 현재 총알의 발사 각도를 계산합니다.
            float currentAngle = baseAngle + (angleStep * i);
            Quaternion rotation = Quaternion.Euler(0, 0, currentAngle);
            Vector2 direction = rotation * Vector2.right;

            GameObject bulletGO = ServiceLocator.Get<PoolManager>().Get(bulletPrefab);

            if (bulletGO == null) continue;

            // 총알 위치와 회전을 설정합니다.
            bulletGO.transform.position = spawnPoint.position;
            bulletGO.transform.rotation = rotation;

            if (bulletGO.TryGetComponent<BulletController>(out var bullet))
            {
                bullet.Initialize(direction, cardData.bulletSpeed, totalDamage, shotID, cardData, cardData.bulletPierceCount);
            }
        }
    }
}

==================== LightningHandler.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/1.Scripts/Gameplay/CardEffectHandlers/LightningHandler.cs) ====================
using UnityEngine;

public class LightningHandler : ICardEffectHandler
{
    public void Execute(CardDataSO cardData, EffectExecutor executor, CharacterStats casterStats, Transform spawnPoint)
    {
        Debug.Log($"[LightningHandler] Lightning effect executed for card: {cardData.cardName}");
        // 여기에 번개 효과 로직을 구현합니다.
        // 예: 특정 위치에 번개 이펙트 생성, 주변 적에게 데미지 적용 등
    }
}


==================== FindMissingScripts.cs (경로: ./TTttTT/Assets/1.Scripts/TTttTT/Assets/Editor/FindMissingScripts.cs) ====================
using UnityEditor;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEditor.SceneManagement;

public class FindMissingScripts
{
    // Ƽ   ޴ "Tools/Find Missing Scripts In All Scenes" ׸ ߰մϴ.
    [MenuItem("Tools/Find Missing Scripts In All Scenes")]
    public static void FindAndSelectMissingScripts()
    {
        Debug.Log("---   Missing Script ˻縦 մϴ. ---");

        //  ִ  θ صӴϴ. (˻簡  ƿ )
        string originalScenePath = EditorSceneManager.GetActiveScene().path;

        // Build Settings ϵ    ɴϴ.
        foreach (EditorBuildSettingsScene scene in EditorBuildSettings.scenes)
        {
            // Ȱȭ  ˻մϴ.
            if (scene.enabled)
            {
                // ش  ϴ.
                EditorSceneManager.OpenScene(scene.path, OpenSceneMode.Single);

                //   ִ   Ʈ ɴϴ.
                GameObject[] allObjects = GameObject.FindObjectsOfType<GameObject>();

                foreach (GameObject go in allObjects)
                {
                    // Ʈ پִ  Ʈ ɴϴ.
                    Component[] components = go.GetComponents<Component>();
                    foreach (Component c in components)
                    {
                        // Ʈ null ̶, ̰ ٷ "Missing Script" Դϴ.
                        if (c == null)
                        {
                            // ֿܼ    Ʈ  ִ  ޽ մϴ.
                            Debug.LogError($"[Missing Script ߰!] : '{scene.path}' / Ʈ: '{go.name}'", go);
                        }
                    }
                }
            }
        }

        // ˻簡   ۾ϴ  ưϴ.
        EditorSceneManager.OpenScene(originalScenePath);
        Debug.Log("---   ˻ Ϸ. ---");
    }
}

==================== CampaignManager.cs (경로: ./TTttTT/Assets/1.Scripts/Core/CampaignManager.cs) ====================
// 파일명: CampaignManager.cs (리팩토링 완료)
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class CampaignManager : MonoBehaviour
{
    [Header("캠페인 목록")]
    [Tooltip("여기에 캠페인으로 사용될 모든 캠페인 SO 목록을 추가하세요.")]
    public List<CampaignDataSO> availableCampaigns;

    private CampaignDataSO currentCampaign;

    void Awake()
    {
        Debug.Log($"[생명주기] {GetType().Name} (ID: {gameObject.GetInstanceID()}) - Awake() 시작. (프레임: {Time.frameCount})");
        if (!ServiceLocator.IsRegistered<CampaignManager>())
        {
            ServiceLocator.Register<CampaignManager>(this);
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    /// <summary>
    /// [주 함수] 사용 가능한 캠페인 중 하나를 무작위로 선택합니다.
    /// </summary>
    public CampaignDataSO SelectRandomCampaign()
    {
        if (availableCampaigns == null || availableCampaigns.Count == 0)
        {
            Debug.LogError("[CampaignManager] 사용 가능한 캠페인이 없습니다!");
            currentCampaign = null;
            return null;
        }

        currentCampaign = availableCampaigns[Random.Range(0, availableCampaigns.Count)];
        Debug.Log($"[CampaignManager] 새로운 캠페인 '{currentCampaign.name}'이(가) 선택되었습니다. (아직 시작은 안 함)");
        return currentCampaign;
    }

    public CampaignDataSO GetCurrentCampaign()
    {
        return currentCampaign;
    }

    /// <summary>
    /// 노드의 Y좌표(인덱스)에 해당하는 라운드 데이터를 반환합니다.
    /// </summary>
    public RoundDataSO GetRoundDataForNode(MapNode node)
    {
        if (currentCampaign == null)
        {
            Debug.LogError("### 오류 ### GetRoundDataForNode 호출: currentCampaign이 null입니다! 인스펙터에 캠페인이 등록되었는지 확인하세요.");
            return null;
        }

        if (node == null) return null;

        int roundIndex = node.Position.y;

        if (roundIndex >= 0 && roundIndex < currentCampaign.rounds.Count)
        {
            Debug.Log($"요청한 노드(Y:{roundIndex})에 맞는 라운드 데이터 '{currentCampaign.rounds[roundIndex].name}'을 반환합니다.");
            return currentCampaign.rounds[roundIndex];
        }
        else
        {
            Debug.LogError($"잘못된 라운드 인덱스({roundIndex})가 요청되었습니다!");
            return null;
        }
    }

    public void ResetCampaign()
    {
    }

    private void OnDestroy()
    {
        Debug.Log($"[생명주기] {GetType().Name} (ID: {gameObject.GetInstanceID()}) - OnDestroy() 시작. (프레임: {Time.frameCount})");
    }
}

==================== ProgressionManager.cs (경로: ./TTttTT/Assets/1.Scripts/Core/ProgressionManager.cs) ====================
// 파일명: ProgressionManager.cs (리팩토링 완료)
using UnityEngine;
using System.Collections.Generic;
using System.IO;
using System.Linq;

/// <summary>
/// 메타 프로그레션(도전 과제, 영구 재화 등) 데이터를 관리하고,
/// 관련 시스템에 데이터를 제공하는 중앙 관리자입니다.
/// </summary>
public class ProgressionManager : MonoBehaviour
{
    public int KnowledgeShards { get; private set; }
    public int GenePoints { get; private set; }
    private Dictionary<string, bool> achievementsUnlocked = new Dictionary<string, bool>();
    private Dictionary<string, bool> bossFirstKills = new Dictionary<string, bool>();
    private Dictionary<string, CharacterPermanentStats> permanentStatsDict = new Dictionary<string, CharacterPermanentStats>();

    private string savePath;

    void Awake()
    {
        if (!ServiceLocator.IsRegistered<ProgressionManager>())
        {
            ServiceLocator.Register<ProgressionManager>(this);
            DontDestroyOnLoad(gameObject);

            savePath = Path.Combine(Application.persistentDataPath, "progression.json");
            LoadData();
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void AddCurrency(MetaCurrencyType type, int amount)
    {
        if (amount < 0)
        {
            Debug.LogError("재화는 음수 값을 추가할 수 없습니다.");
            return;
        }

        switch (type)
        {
            case MetaCurrencyType.KnowledgeShards:
                KnowledgeShards += amount;
                Debug.Log($"지식의 파편 {amount} 획득. 현재: {KnowledgeShards}");
                break;
            case MetaCurrencyType.GenePoints:
                GenePoints += amount;
                Debug.Log($"유전자 증폭제 포인트 {amount} 획득. 현재: {GenePoints}");
                break;
        }
        SaveData();
    }

    public bool SpendCurrency(MetaCurrencyType type, int amount)
    {
        if (amount < 0)
        {
            Debug.LogError("재화는 음수 값을 사용할 수 없습니다.");
            return false;
        }

        bool success = false;
        switch (type)
        {
            case MetaCurrencyType.KnowledgeShards:
                if (KnowledgeShards >= amount)
                {
                    KnowledgeShards -= amount;
                    Debug.Log($"지식의 파편 {amount} 사용. 현재: {KnowledgeShards}");
                    success = true;
                }
                break;
            case MetaCurrencyType.GenePoints:
                if (GenePoints >= amount)
                {
                    GenePoints -= amount;
                    Debug.Log($"유전자 증폭제 포인트 {amount} 사용. 현재: {GenePoints}");
                    success = true;
                }
                break;
        }

        if (success)
        {
            SaveData();
            return true;
        }
        else
        {
            Debug.LogWarning($"{type} 재화가 부족하여 {amount}를 사용할 수 없습니다.");
            return false;
        }
    }

    public void TrackAchievement(string achievementID)
    {
        if (!achievementsUnlocked.ContainsKey(achievementID) || achievementsUnlocked[achievementID] == false)
        {
            achievementsUnlocked[achievementID] = true;
            Debug.Log($"도전 과제 달성: {achievementID}");
            SaveData();
        }
    }

    public void RegisterBossFirstKill(string bossID)
    {
        if (!bossFirstKills.ContainsKey(bossID) || bossFirstKills[bossID] == false)
        {
            bossFirstKills[bossID] = true;
            Debug.Log($"보스 최초 처치: {bossID}");
            SaveData();
        }
    }

    public CharacterPermanentStats GetPermanentStatsFor(string characterId)
    {
        if (!permanentStatsDict.TryGetValue(characterId, out var stats))
        {
            stats = new CharacterPermanentStats(characterId);
            permanentStatsDict[characterId] = stats;
            Debug.Log($"{characterId}에 대한 새로운 영구 스탯 데이터를 생성했습니다.");
        }
        return stats;
    }

    public void SaveData()
    {
        ProgressionData data = new ProgressionData
        {
            knowledgeShards = this.KnowledgeShards,
            genePoints = this.GenePoints,
            achievementIDs = achievementsUnlocked.Keys.ToList(),
            achievementStates = achievementsUnlocked.Values.ToList(),
            bossKillIDs = bossFirstKills.Keys.ToList(),
            bossKillStates = bossFirstKills.Values.ToList(),
            characterPermanentStats = permanentStatsDict.Values.ToList()
        };

        string json = JsonUtility.ToJson(data, true);
        File.WriteAllText(savePath, json);
        Debug.Log($"데이터 저장 완료: {savePath}");
    }

    public void LoadData()
    {
        if (File.Exists(savePath))
        {
            string json = File.ReadAllText(savePath);
            ProgressionData data = JsonUtility.FromJson<ProgressionData>(json);

            permanentStatsDict = new Dictionary<string, CharacterPermanentStats>();
            foreach (var stats in data.characterPermanentStats)
            {
                stats.statData = new StatDictionaryData
                {
                    statTypes = stats.statData.statTypes,
                    unlockedStatuses = stats.statData.unlockedStatuses,
                    investedRatios = stats.statData.investedRatios
                };
                permanentStatsDict[stats.characterId] = stats;
            }

            Debug.Log($"데이터 로드 완료: {savePath}");
        }
        else
        {
            Debug.Log("세이브 파일이 없어 새 게임을 시작합니다.");
            KnowledgeShards = 0;
            GenePoints = 0;
            achievementsUnlocked = new Dictionary<string, bool>();
            bossFirstKills = new Dictionary<string, bool>();
            permanentStatsDict = new Dictionary<string, CharacterPermanentStats>();
        }
    }

    private void OnApplicationQuit()
    {
        SaveData();
    }

    public bool IsCodexItemUnlocked(string itemID)
    {
        if (achievementsUnlocked.ContainsKey(itemID) && achievementsUnlocked[itemID])
        {
            return true;
        }
        if (bossFirstKills.ContainsKey(itemID) && bossFirstKills[itemID])
        {
            return true;
        }
        return false;
    }
}

public enum MetaCurrencyType
{
    KnowledgeShards,
    GenePoints
}

==================== SceneNames.cs (경로: ./TTttTT/Assets/1.Scripts/Core/SceneNames.cs) ====================
/// <summary>
/// 씬 이름들을 상수로 관리하는 클래스입니다.
/// </summary>
public static class SceneNames
{
    public const string MainMenu = "MainMenu";
    public const string CharacterSelect = "CharacterSelect";
    public const string PointAllocation = "PointAllocation";
    public const string GamePlay = "GamePlay";
    public const string CardReward = "CardReward";
    public const string Codex = "Codex";
    public const string Shop = "Shop";
    public const string Rest = "Rest";
    public const string Event = "Event";
    public const string Pause = "Pause"; // Pause는 씬이 아닐 수 있지만, UI 관리 등에서 사용할 수 있어 포함
}

==================== MapManager.cs (경로: ./TTttTT/Assets/1.Scripts/Core/MapManager.cs) ====================
// 파일명: MapManager.cs (리팩토링 완료)
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class MapManager : MonoBehaviour
{
    public bool IsMapInitialized { get; private set; }
    public List<MapNode> AllNodes { get; private set; }
    public int MapWidth { get; private set; }
    public int MapHeight { get; private set; }
    public MapNode CurrentNode { get; private set; }

    void Awake()
    {
        // ServiceLocator에 이미 등록된 인스턴스가 있는지 확인
        if (ServiceLocator.IsRegistered<MapManager>())
        {
            // 이미 있다면 나는 중복이므로 스스로 파괴
            Destroy(gameObject);
            return;
        }
        
        // 최초의 인스턴스일 경우, 등록하고 파괴되지 않도록 설정
        ServiceLocator.Register<MapManager>(this);
        DontDestroyOnLoad(gameObject);
    }
    
    /// <summary>
    /// 맵 데이터와 함께 맵의 크기 정보도 받아 초기화합니다.
    /// </summary>
    public void InitializeMap(List<MapNode> mapData, int width, int height)
    {
        AllNodes = mapData;
        MapWidth = width;
        MapHeight = height;
        CurrentNode = AllNodes.FirstOrDefault(n => n.Position.y == 0); // 시작 노드 설정
        IsMapInitialized = true;
        Debug.Log($"[MapManager] 맵 데이터 초기화 완료. (노드 수: {AllNodes.Count}, 너비: {width}, 높이: {height})");
    }

    /// <summary>
    /// 플레이어를 새 노드로 이동시키고, Gameplay 씬으로 전환을 요청합니다.
    /// </summary>
    public void MoveToNode(MapNode node)
    {
        if (AllNodes.Contains(node))
        {
            CurrentNode = node;
            Debug.Log($"[MapManager] 현재 위치를 노드 {node.Position}로 이동했습니다.");
        }
    }

    /// <summary>
    /// [추가된 함수] 씬을 전환하지 않고, 현재 노드 데이터만 업데이트합니다.
    /// </summary>
    public void MoveToNode_OnlyUpdateData(MapNode newNode)
    {
        if (CurrentNode != null && !CurrentNode.NextNodes.Contains(newNode))
        {
            Debug.LogError($"{newNode.Position}은(는) 현재 위치({CurrentNode.Position})에서 이동할 수 없는 노드입니다!");
            return;
        }
        CurrentNode = newNode;
        Debug.Log($"[MapManager] 현재 노드가 {newNode.Position}(으)로 업데이트되었습니다.");
    }

    /// <summary>
    /// 현재 플레이어가 이동할 수 있는 다음 노드들의 리스트를 반환합니다.
    /// </summary>
    public List<MapNode> GetReachableNodes()
    {
        if (CurrentNode == null)
        {
            return AllNodes.Where(node => node.Position.y == 0).ToList();
        }
        return CurrentNode.NextNodes;
    }
}

==================== VFXManager.cs (경로: ./TTttTT/Assets/1.Scripts/Core/VFXManager.cs) ====================
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// 게임 내 모든 일회성 시각 효과(VFX)의 생성 및 관리를 전담하는 중앙 관리자입니다.
/// 다른 시스템은 이 매니저를 통해 키(ID)값으로 VFX 재생을 요청합니다.
/// </summary>
public class VFXManager : MonoBehaviour
{
    private PoolManager poolManager;
    private PrefabProvider prefabProvider;

    void Awake()
    {
        if (!ServiceLocator.IsRegistered<VFXManager>())
        {
            ServiceLocator.Register<VFXManager>(this);
            // 이 매니저는 _Managers 프리팹의 일부이므로 DontDestroyOnLoad가 이미 적용됩니다.
        }
        else
        {
            Destroy(gameObject);
        }
    }

    void Start()
    {
        // ServiceLocator를 통해 다른 핵심 매니저들을 참조합니다.
        poolManager = ServiceLocator.Get<PoolManager>();
        prefabProvider = ServiceLocator.Get<PrefabProvider>();

        if (poolManager == null || prefabProvider == null)
        {
            Debug.LogError($"<color=red>[VFXManager]</color> CRITICAL: PoolManager 또는 PrefabProvider를 찾을 수 없습니다!");
        }
    }

    /// <summary>
    /// 지정된 키(ID)에 해당하는 VFX 프리팹을 특정 위치에 재생합니다.
    /// </summary>
    /// <param name="vfxKey">재생할 VFX의 이름 (PrefabProvider에 등록된 이름)</param>
    /// <param name="position">VFX가 생성될 월드 좌표</param>
    public void PlayVFX(string vfxKey, Vector3 position)
    {
        if (string.IsNullOrEmpty(vfxKey) || poolManager == null || prefabProvider == null)
        {
            // 키가 비어있거나 매니저를 찾을 수 없으면 아무것도 하지 않습니다.
            return;
        }

        // PrefabProvider를 통해 vfxKey에 해당하는 프리팹을 찾습니다.
        GameObject vfxPrefab = prefabProvider.GetPrefab(vfxKey);
        
        if (vfxPrefab == null)
        {
            Debug.LogWarning($"<color=yellow>[VFXManager]</color> '{vfxKey}'에 해당하는 VFX 프리팹을 찾을 수 없습니다.");
            return;
        }

        // PoolManager를 통해 VFX 오브젝트를 가져옵니다.
        GameObject vfxInstance = poolManager.Get(vfxPrefab);

        if (vfxInstance != null)
        {
            vfxInstance.transform.position = position;
            // 필요하다면 파티클 시스템의 Play()를 호출하거나 다른 초기화 로직을 추가할 수 있습니다.
            // 예: vfxInstance.GetComponent<ParticleSystem>()?.Play();
            Debug.Log($"<color=green>[VFXManager]</color> '{vfxKey}' VFX를 [{position}] 위치에 재생했습니다.");
        }
    }
}

==================== UICursorManager.cs (경로: ./TTttTT/Assets/1.Scripts/Core/UICursorManager.cs) ====================
// ϸ: UICursorManager.cs (丵 Ϸ)
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class UICursorManager : MonoBehaviour
{
    [SerializeField]
    private Image globalCursorImage;

    private Sprite defaultCursorSprite;

    void Awake()
    {
        ServiceLocator.Register<UICursorManager>(this);
        if (globalCursorImage != null)
        {
            defaultCursorSprite = globalCursorImage.sprite;
        }
    }

    void Update()
    {
        if (globalCursorImage == null || EventSystem.current == null) return;

        GameObject selectedObject = EventSystem.current.currentSelectedGameObject;

        if (selectedObject != null)
        {
            globalCursorImage.gameObject.SetActive(true);
            globalCursorImage.rectTransform.position = selectedObject.transform.position;
        }
        else
        {
            globalCursorImage.gameObject.SetActive(false);
        }
    }

    public void ChangeCursorSprite(Sprite newSprite)
    {
        if (globalCursorImage == null) return;
        globalCursorImage.sprite = newSprite;
    }

    public void ResetCursorToDefault()
    {
        if (globalCursorImage == null || defaultCursorSprite == null) return;
        globalCursorImage.sprite = defaultCursorSprite;
    }
}

==================== EffectContext.cs (경로: ./TTttTT/Assets/1.Scripts/Core/EffectContext.cs) ====================
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// 카드 효과가 실행될 때 필요한 모든 맥락 정보를 담는 데이터 클래스입니다.
/// 이 객체는 EffectExecutor가 생성하여 각 CardEffectSO의 Execute 메소드에 전달합니다.
/// </summary>
public class EffectContext
{
    /// <summary>
    /// 효과를 발동시킨 주체(플레이어)의 CharacterStats입니다.
    /// </summary>
    public CharacterStats Caster;

    /// <summary>
    /// 효과가 시작되는 월드 좌표입니다. (예: 플레이어의 총구, 몬스터의 피격 위치)
    /// </summary>
    public Transform SpawnPoint;

    /// <summary>
    /// 최초 발사 시의 목표 대상입니다. (타겟팅 시스템에 의해 결정됨)
    /// </summary>
    public MonsterController InitialTarget;

    /// <summary>
    /// 효과가 적중한 월드 좌표입니다. (OnHit, OnCrit 등의 트리거에서 사용)
    /// </summary>
    public Vector3 HitPosition;

    /// <summary>
    /// 해당 효과 연쇄 반응에서 발생한 피해량입니다. (흡혈 등에서 사용)
    /// </summary>
    public float DamageDealt;

    /// <summary>
    /// 효과를 발동시킨 피격이 치명타였는지 여부입니다.
    /// </summary>
    public bool IsCritical;
    
    /// <summary>
    /// 효과를 발동시킨 피격으로 대상이 사망했는지 여부입니다.
    /// </summary>
    public bool IsKill;

    /// <summary>
    /// ShotgunPatternSO 같은 '수정' 옵션이 계산한 발사 궤적 목록입니다.
    /// 이 목록이 비어있지 않으면 ProjectileEffectSO는 이 궤적을 사용합니다.
    /// </summary>
    public List<Vector2> FiringDirections = new List<Vector2>();


    public MonsterController HitTarget;
}

==================== DebugManager.cs (경로: ./TTttTT/Assets/1.Scripts/Core/DebugManager.cs) ====================
// 파일명: DebugManager.cs (리팩토링 완료)
using UnityEngine;
using TMPro;
using System.Text;

/// <summary>
/// 개발 및 테스트 편의를 위한 디버그 기능을 관리하는 클래스입니다.
/// F1키로 디버그 UI를 토글하고, 게임 내 주요 변수를 실시간으로 확인하고 조작하는 기능을 제공합니다.
/// </summary>
public class DebugManager : MonoBehaviour
{
    [Header("디버그 UI 참조")]
    [SerializeField] private GameObject debugPanel;
    [SerializeField] private TextMeshProUGUI infoText;

    [Header("디버그 기능 설정")]
    [SerializeField] private float healthToAdd = 50f;

    private bool isDebugModeEnabled = false;
    private CharacterStats playerStats; // 외부에서 등록받을 플레이어 스탯 참조
    private StringBuilder infoBuilder = new StringBuilder();

    void Awake()
    {
        if (!ServiceLocator.IsRegistered<DebugManager>())
        {
            ServiceLocator.Register<DebugManager>(this);
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    void Start()
    {
        if (debugPanel != null) debugPanel.SetActive(false);
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.F1))
        {
            ToggleDebugMode();
        }
        if (isDebugModeEnabled && debugPanel != null)
        {
            UpdateDebugInfo();
        }
    }

    public void ToggleDebugMode()
    {
        isDebugModeEnabled = !isDebugModeEnabled;
        if (debugPanel != null) debugPanel.SetActive(isDebugModeEnabled);
        Debug.Log($"디버그 모드: {(isDebugModeEnabled ? "활성화" : "비활성화")}");
    }

    // --- 외부 컴포넌트 등록/해제 메서드 ---

    /// <summary>
    /// PlayerStats 컴포넌트를 디버그 매니저에 등록합니다.
    /// </summary>
    public void RegisterPlayer(CharacterStats player)
    {
        playerStats = player;
        Debug.Log("[DebugManager] PlayerStats 등록됨.");
    }

    /// <summary>
    /// 등록된 PlayerStats 컴포넌트를 해제합니다.
    /// </summary>
    public void UnregisterPlayer()
    {
        playerStats = null;
        Debug.Log("[DebugManager] PlayerStats 등록 해제됨.");
    }

    private void UpdateDebugInfo()
    {
        if (infoText == null) return;
        infoBuilder.Clear();

        if (playerStats != null)
        {
            infoBuilder.AppendLine("--- Player Stats ---");
            infoBuilder.AppendLine($"Health: {playerStats.currentHealth:F1} / {playerStats.FinalHealth:F1}");
            infoBuilder.AppendLine($"Is Invulnerable: {playerStats.isInvulnerable}");
            infoBuilder.AppendLine($"Damage: {playerStats.FinalDamage:F2}");
            infoBuilder.AppendLine($"Attack Speed: {playerStats.FinalAttackSpeed:F2}");
            infoBuilder.AppendLine($"Move Speed: {playerStats.FinalMoveSpeed:F2}");
            infoBuilder.AppendLine($"Crit Rate: {playerStats.FinalCritRate:P2}");
            infoBuilder.AppendLine($"Crit Damage: {playerStats.FinalCritDamage:P2}");
        }
        else
        {
            infoBuilder.AppendLine("PlayerStats not registered.");
        }

        infoBuilder.AppendLine("--- Game Info ---");

        // ▼▼▼ 이 부분을 ▼▼▼
        // infoBuilder.AppendLine($"Active Monsters: {FindObjectsOfType<MonsterController>().Length}");

        // ▼▼▼ 아래처럼 바꾸세요! ▼▼▼
        var monsterManager = ServiceLocator.Get<MonsterManager>();
        if (monsterManager != null)
        {
            infoBuilder.AppendLine($"Active Monsters: {monsterManager.ActiveMonsters.Count}");
        }

        infoText.text = infoBuilder.ToString();
    }

    // --- 디버그 UI의 버튼/슬라이더와 연결될 메서드들 ---

    public void GodMode(bool isOn)
    {
        if (playerStats != null)
        {
            playerStats.isInvulnerable = isOn;
            Debug.Log($"갓 모드: {isOn}");
        }
    }

    public void AddPlayerHealth()
    {
        if (playerStats != null)
        {
            playerStats.Heal(healthToAdd);
            Debug.Log($"플레이어 체력 {healthToAdd} 증가");
        }
    }

    public void KillAllMonsters()
    {
        MonsterController[] monsters = FindObjectsOfType<MonsterController>();
        foreach (var monster in monsters)
        {
            monster.TakeDamage(monster.currentHealth);
        }
        Debug.Log($"{monsters.Length}마리의 몬스터를 처치했습니다.");
    }
}

==================== ResourcePaths.cs (경로: ./TTttTT/Assets/1.Scripts/Core/ResourcePaths.cs) ====================
// 파일명: ResourcePaths.cs
public static class ResourcePaths
{
    public const string CardData = "CardData";
    public const string ArtifactData = "ArtifactData";
    public const string CharacterData = "CharacterData";
    public const string MonsterData = "MonsterData";
}

==================== DataManager.cs (경로: ./TTttTT/Assets/1.Scripts/Core/DataManager.cs) ====================
using UnityEngine;
using System.Collections.Generic;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;
using System.Collections;

public class DataManager : MonoBehaviour
{
    // --- 기존 코드와 동일 ---
    void Awake()
    {
        if (!ServiceLocator.IsRegistered<DataManager>())
        {
            ServiceLocator.Register<DataManager>(this);
            DontDestroyOnLoad(gameObject);
            // StartCoroutine(LoadAllDataAsync()); // Start에서 호출되도록 변경될 수 있음
        }
        else
        {
            Destroy(gameObject);
        }
    }

    // --- 데이터 저장소 확장 ---
    private readonly Dictionary<string, CardDataSO> cardDataDict = new Dictionary<string, CardDataSO>();
    private readonly Dictionary<string, ArtifactDataSO> artifactDataDict = new Dictionary<string, ArtifactDataSO>();
    private readonly Dictionary<string, CharacterDataSO> characterDict = new Dictionary<string, CharacterDataSO>();
    private readonly Dictionary<string, MonsterDataSO> monsterDataDict = new Dictionary<string, MonsterDataSO>();
    
    // ▼▼▼ [추가] '옵션' 부품들을 저장할 새로운 딕셔너리 ▼▼▼
    private readonly Dictionary<string, CardEffectSO> effectDataDict = new Dictionary<string, CardEffectSO>();


    public IEnumerator LoadAllDataAsync()
    {
        Debug.Log("[DataManager] 모든 ScriptableObject 데이터 비동기 로드 시작...");
        
        // --- 기존 로딩 핸들 ---
        var cardHandle = Addressables.LoadAssetsAsync<CardDataSO>("data_card", null);
        var artifactHandle = Addressables.LoadAssetsAsync<ArtifactDataSO>("data_artifact", null);
        var characterHandle = Addressables.LoadAssetsAsync<CharacterDataSO>("data_character", null);
        var monsterHandle = Addressables.LoadAssetsAsync<MonsterDataSO>("data_monster", null);

        // ▼▼▼ [추가] 'data_effect' 레이블을 가진 모든 CardEffectSO를 로드하는 핸들 ▼▼▼
        var effectHandle = Addressables.LoadAssetsAsync<CardEffectSO>("data_effect", null);

        // --- 모든 로딩 작업을 하나의 그룹으로 묶어 처리 ---
        var groupHandle = Addressables.ResourceManager.CreateGenericGroupOperation(
            new List<AsyncOperationHandle> { cardHandle, artifactHandle, characterHandle, monsterHandle, effectHandle }, true);
        
        yield return groupHandle;

        if (groupHandle.Status == AsyncOperationStatus.Succeeded)
        {
            // --- 기존 데이터 저장 로직 ---
            foreach (var card in cardHandle.Result) { if (!cardDataDict.ContainsKey(card.basicInfo.cardID)) cardDataDict.Add(card.basicInfo.cardID, card); }
            foreach (var artifact in artifactHandle.Result) { if (!artifactDataDict.ContainsKey(artifact.artifactID)) artifactDataDict.Add(artifact.artifactID, artifact); }
            foreach (var character in characterHandle.Result) { if (!characterDict.ContainsKey(character.characterId)) characterDict.Add(character.characterId, character); }
            foreach (var monster in monsterHandle.Result) { if (!monsterDataDict.ContainsKey(monster.monsterID)) monsterDataDict.Add(monster.monsterID, monster); }
            
            // ▼▼▼ [추가] 로딩된 '옵션' 부품들을 딕셔너리에 저장 (key는 에셋 파일명) ▼▼▼
            foreach (var effect in effectHandle.Result) { if (!effectDataDict.ContainsKey(effect.name)) effectDataDict.Add(effect.name, effect); }

            Debug.Log("[DataManager] 모든 ScriptableObject 데이터 로드 완료.");
        }
        else
        {
            Debug.LogError("[DataManager] ScriptableObject 데이터 로딩 실패!");
        }
        
        // --- 핸들 릴리즈 ---
        Addressables.Release(cardHandle);
        Addressables.Release(artifactHandle);
        Addressables.Release(characterHandle);
        Addressables.Release(monsterHandle);
        Addressables.Release(effectHandle); // [추가]
    }

    // --- Getter 메소드 확장 ---
    public CardDataSO GetCard(string id) => GetData(id, cardDataDict);
    public ArtifactDataSO GetArtifact(string id) => GetData(id, artifactDataDict);
    public CharacterDataSO GetCharacter(string id) => GetData(id, characterDict);
    public MonsterDataSO GetMonsterData(string id) => GetData(id, monsterDataDict);

    // ▼▼▼ [추가] ID로 '옵션' 부품을 가져오는 새로운 Getter ▼▼▼
    public CardEffectSO GetEffect(string id) => GetData(id, effectDataDict);

    // --- 범용 Getter (기존과 동일) ---
    private T GetData<T>(string id, Dictionary<string, T> sourceDict) where T : class
    {
        if (sourceDict.TryGetValue(id, out T data))
        {
            return data;
        }
        Debug.LogError($"[DataManager] '{typeof(T).Name}' 타입의 데이터 '{id}'를 찾을 수 없습니다.");
        return null;
    }

    // --- 목록 반환 함수 (기존과 동일) ---
    public List<CardDataSO> GetAllCards() => new List<CardDataSO>(cardDataDict.Values);
    public List<ArtifactDataSO> GetAllArtifacts() => new List<ArtifactDataSO>(artifactDataDict.Values);
}

==================== CameraFollow.cs (경로: ./TTttTT/Assets/1.Scripts/Core/CameraFollow.cs) ====================
using UnityEngine;

public class CameraFollow : MonoBehaviour
{
    public Transform target; // ī޶   (÷̾)
    public float smoothSpeed = 0.125f; // ī޶ 󰡴 ε巯 
    public Vector3 offset; // ī޶   Ÿ

    // ÷̾    Ŀ ī޶ ̵ LateUpdate մϴ.
    void LateUpdate()
    {
        if (target != null)
        {
            Vector3 desiredPosition = target.position + offset;
            Vector3 smoothedPosition = Vector3.Lerp(transform.position, desiredPosition, smoothSpeed);
            transform.position = smoothedPosition;
        }
    }
}

==================== MonsterManager.cs (경로: ./TTttTT/Assets/1.Scripts/Core/MonsterManager.cs) ====================
// ϸ: MonsterManager.cs
using System.Collections.Generic;
using UnityEngine;

public class MonsterManager : MonoBehaviour
{
    private readonly List<MonsterController> activeMonsters = new List<MonsterController>();
    public IReadOnlyList<MonsterController> ActiveMonsters => activeMonsters;

    void Awake()
    {
        ServiceLocator.Register<MonsterManager>(this);
        //  Ŵ _GameplaySession տ ־θ DontDestroyOnLoad ʿ ϴ.
    }

    public void RegisterMonster(MonsterController monster)
    {
        if (!activeMonsters.Contains(monster))
        {
            activeMonsters.Add(monster);
        }
    }

    public void UnregisterMonster(MonsterController monster)
    {
        if (activeMonsters.Contains(monster))
        {
            activeMonsters.Remove(monster);
        }
    }
}

==================== TargetingSystem.cs (경로: ./TTttTT/Assets/1.Scripts/Core/TargetingSystem.cs) ====================
// 파일 경로: Assets/1.Scripts/Core/TargetingSystem.cs

using UnityEngine;
using System.Linq;
using System.Collections.Generic;

public static class TargetingSystem
{
    public static Transform FindTarget(ProjectileEffectSO.TargetingType type, Transform origin)
    {
        var monsterManager = ServiceLocator.Get<MonsterManager>();
        if (monsterManager == null) return null;

        var activeMonsters = monsterManager.ActiveMonsters;
        if (activeMonsters.Count == 0) return null;

        switch (type)
        {
            case ProjectileEffectSO.TargetingType.Nearest:
                return activeMonsters.OrderBy(m => Vector3.Distance(origin.position, m.transform.position)).FirstOrDefault()?.transform;
            case ProjectileEffectSO.TargetingType.HighestHealth:
                return activeMonsters.OrderByDescending(m => m.currentHealth).FirstOrDefault()?.transform;
            case ProjectileEffectSO.TargetingType.LowestHealth:
                return activeMonsters.OrderBy(m => m.currentHealth).FirstOrDefault()?.transform;
            // TargetingType.Random, Forward 등 다른 케이스는 BulletController에서 직접 처리하거나 여기에 추가할 수 있습니다.
            default:
                return null; // Forward의 경우 방향만 필요하므로 타겟이 없음
        }
    }

    /// <summary>
    /// [추가된 메소드] 지정된 타겟팅 방식에 따라 실제 발사 각도를 계산하여 반환합니다.
    /// </summary>
    public static float GetTargetingAngle(ProjectileEffectSO.TargetingType targetingType, Transform casterTransform, Transform spawnPoint)
    {
        if (casterTransform == null || spawnPoint == null) return 0f;

        // 먼저 타겟을 찾습니다.
        Transform target = FindTarget(targetingType, casterTransform);

        if (target != null)
        {
            // 타겟이 있으면 해당 방향으로의 각도를 계산합니다.
            Vector2 directionToTarget = (target.position - spawnPoint.position).normalized;
            return Mathf.Atan2(directionToTarget.y, directionToTarget.x) * Mathf.Rad2Deg;
        }
        else
        {
            // 타겟이 없으면(Forward 등) 시전자의 전방 각도를 반환합니다.
            return casterTransform.eulerAngles.z;
        }
    }
}

==================== SceneTransitionManager.cs (경로: ./TTttTT/Assets/1.Scripts/Core/SceneTransitionManager.cs) ====================
﻿// 파일명: SceneTransitionManager.cs (리팩토링 완료)
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;
using System.Collections;

public class SceneTransitionManager : MonoBehaviour
{
    private Image fadeOverlay;

    private void Awake()
    {
        if (!ServiceLocator.IsRegistered<SceneTransitionManager>())
        {
            ServiceLocator.Register<SceneTransitionManager>(this);
            DontDestroyOnLoad(gameObject);
            InitializeFadeOverlay();
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void InitializeFadeOverlay()
    {
        GameObject canvasGo = new GameObject("SceneTransitionCanvas");
        canvasGo.transform.SetParent(this.transform);
        Canvas canvas = canvasGo.AddComponent<Canvas>();
        canvas.renderMode = RenderMode.ScreenSpaceOverlay;
        canvas.sortingOrder = 999;

        canvasGo.AddComponent<CanvasScaler>().uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;

        GameObject imageGo = new GameObject("FadeOverlayImage");
        imageGo.transform.SetParent(canvasGo.transform);
        fadeOverlay = imageGo.AddComponent<Image>();

        RectTransform rt = fadeOverlay.rectTransform;
        rt.anchorMin = Vector2.zero;
        rt.anchorMax = Vector2.one;
        rt.offsetMin = Vector2.zero;
        rt.offsetMax = Vector2.zero;

        fadeOverlay.color = new Color(0, 0, 0, 0);
        fadeOverlay.raycastTarget = false;
        fadeOverlay.gameObject.SetActive(false);
    }

    public void LoadScene(string sceneName)
    {
        StopAllCoroutines();
        StartCoroutine(FadeOutAndLoad(sceneName));
    }

    private IEnumerator FadeIn()
    {
        fadeOverlay.gameObject.SetActive(true);
        float t = 1f;
        while (t > 0f)
        {
            t -= Time.unscaledDeltaTime;
            fadeOverlay.color = new Color(0, 0, 0, t);
            yield return null;
        }
        fadeOverlay.gameObject.SetActive(false);
    }

    private IEnumerator FadeOutAndLoad(string sceneName)
    {
        SceneManager.sceneLoaded += OnSceneLoaded;

        fadeOverlay.gameObject.SetActive(true);
        float t = 0f;
        while (t < 1f)
        {
            t += Time.unscaledDeltaTime;
            fadeOverlay.color = new Color(0, 0, 0, t);
            yield return null;
        }

        SceneManager.LoadScene(sceneName);
    }

    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        SceneManager.sceneLoaded -= OnSceneLoaded;
        StartCoroutine(FadeIn());
    }
}

==================== EffectExecutor.cs (경로: ./TTttTT/Assets/1.Scripts/Core/EffectExecutor.cs) ====================
// 파일 경로: Assets/1.Scripts/Core/EffectExecutor.cs

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;

/// <summary>
/// 카드의 '옵션' 부품(CardEffectSO)들을 조립하여 실제 효과를 발동시키는 중앙 지휘자입니다.
/// </summary>
public class EffectExecutor : MonoBehaviour
{
    private DataManager dataManager;

    void Awake()
    {
        if (!ServiceLocator.IsRegistered<EffectExecutor>())
        {
            ServiceLocator.Register<EffectExecutor>(this);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    void Start()
    {
        dataManager = ServiceLocator.Get<DataManager>();
        if (dataManager == null)
        {
            Debug.LogError($"<color=red>[EffectExecutor]</color> CRITICAL: DataManager를 찾을 수 없습니다!");
        }
    }

    /// <summary>
    /// 카드를 발동시키는 메인 함수입니다. PlayerController에 의해 호출됩니다.
    /// </summary>
    public void Execute(CardDataSO card, CharacterStats caster, Transform spawnPoint)
    {
        if (card == null || caster == null || spawnPoint == null) return;
        Debug.Log($"<color=yellow>[EffectExecutor]</color> 카드 '{card.basicInfo.cardName}' 실행 시작.");
        StartCoroutine(LoadAndExecuteEffects(card, caster, spawnPoint));
    }

    /// <summary>
    /// 카드의 AssetReference 목록을 실제 CardEffectSO 객체로 로드한 뒤, OnFire 효과를 실행합니다.
    /// </summary>
    private IEnumerator LoadAndExecuteEffects(CardDataSO card, CharacterStats caster, Transform spawnPoint)
    {
        var handles = new List<AsyncOperationHandle<CardEffectSO>>();
        var loadedEffects = new List<CardEffectSO>();

        Debug.Log($"[EffectExecutor] >>> 시작: 카드 '{card.basicInfo.cardName}' 옵션 로드 (총 {card.attachedEffectReferences.Count}개)");

        foreach (var effectRef in card.attachedEffectReferences)
        {
            // AssetReference 자체 정보 출력
            Debug.Log($"[EffectExecutor] -- Reference Info --\n" +
                  $"   AssetGUID: {effectRef.AssetGUID}\n" +
                  $"   RuntimeKey: {effectRef.RuntimeKey}\n" +
                  $"   IsValid(): {effectRef.IsValid()}\n" +
                  $"   EditorAsset: {effectRef.editorAsset}");

            if (effectRef.IsValid())
            {
                var handle = effectRef.LoadAssetAsync<CardEffectSO>();
                handle.Completed += op =>
                {
                    Debug.Log($"[EffectExecutor] ** Asset Load Completed **\n" +
                          $"   GUID: {effectRef.AssetGUID}\n" +
                          $"   Status: {op.Status}\n" +
                          $"   Result IsNull: {op.Result == null}");
                };
                handles.Add(handle);
            }
            else
            {
                Debug.LogWarning($"[EffectExecutor] -- INVALID Reference -- GUID: {effectRef.AssetGUID}");
            }
        }

        if (handles.Count > 0)
        {
            var groupHandle = Addressables.ResourceManager.CreateGenericGroupOperation(handles.Cast<AsyncOperationHandle>().ToList());
            Debug.Log($"[EffectExecutor] >>> 그룹 로드 시작 (핸들 수: {handles.Count})");
            yield return groupHandle;
            Debug.Log($"[EffectExecutor] >>> 그룹 로드 완료. Status: {groupHandle.Status}");

            foreach (var handle in handles)
            {
                Debug.Log($"[EffectExecutor] -- 개별 핸들 상태 --\n" +
                      $"   DebugName: {handle.DebugName}\n" +
                      $"   Status: {handle.Status}\n" +
                      $"   Result IsNull: {handle.Result == null}");

                if (handle.Status == AsyncOperationStatus.Succeeded && handle.Result != null)
                    loadedEffects.Add(handle.Result);
                else
                    Debug.LogError($"[EffectExecutor] !!! 로드 실패 카드 '{card.basicInfo.cardName}' 옵션: {handle.DebugName}");
            }

            Addressables.Release(groupHandle);
        }

        if (loadedEffects.Count == 0)
        {
            Debug.LogWarning($"[EffectExecutor] 카드 '{card.basicInfo.cardName}'에 실행할 유효한 옵션이 없습니다.");
            yield break;
        }

        // --- 이후 로직은 이전과 동일 ---
        ProjectileEffectSO mainProjectileEffect = loadedEffects.OfType<ProjectileEffectSO>().FirstOrDefault();
        float baseAngle = caster.transform.eulerAngles.z;
        MonsterController initialTarget = null;

        if (mainProjectileEffect != null)
        {
            baseAngle = TargetingSystem.GetTargetingAngle(mainProjectileEffect.targetingType, caster.transform, spawnPoint);
            Transform targetTransform = TargetingSystem.FindTarget(mainProjectileEffect.targetingType, caster.transform);
            if (targetTransform != null) initialTarget = targetTransform.GetComponent<MonsterController>();
        }

        var context = new EffectContext { Caster = caster, SpawnPoint = spawnPoint, InitialTarget = initialTarget };

        if (card.projectileCount > 1)
        {
            float angleStep = (card.projectileCount > 1) ? card.spreadAngle / (card.projectileCount - 1) : 0;
            float startAngle = baseAngle - (card.spreadAngle / 2f);
            for (int i = 0; i < card.projectileCount; i++)
            {
                context.FiringDirections.Add(Quaternion.Euler(0, 0, startAngle + (angleStep * i)) * Vector2.right);
            }
        }
        else
        {
            context.FiringDirections.Add(Quaternion.Euler(0, 0, baseAngle) * Vector2.right);
        }

        foreach (var effect in loadedEffects.Where(e => e.trigger == CardEffectSO.EffectTrigger.OnFire))
        {
            Debug.Log($"<color=yellow>[EffectExecutor]</color> -> 옵션 '{effect.name}' 실행 (트리거: {effect.trigger}).");
            effect.Execute(context);
        }
    }
}


==================== ServiceLocator.cs (경로: ./TTttTT/Assets/1.Scripts/Core/ServiceLocator.cs) ====================
// 파일명: ServiceLocator.cs (Unregister 메소드 추가)
using System;
using System.Collections.Generic;
using UnityEngine;

public static class ServiceLocator
{
    private static readonly Dictionary<Type, object> services = new Dictionary<Type, object>();

    // ▼▼▼ 이 부분을 새로 추가하세요 ▼▼▼
    // static 생성자는 클래스가 처음 사용될 때 딱 한 번 호출됩니다.
    static ServiceLocator()
    {
        // Unity 에디터가 종료되거나 플레이 모드가 중지될 때 Clear 서비스를 호출하도록 등록합니다.
        Application.quitting += Clear;
    }
    // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

    /// <summary>
    /// 특정 타입의 서비스가 이미 등록되어 있는지 확인합니다.
    /// </summary>
    public static bool IsRegistered<T>()
    {
        return services.ContainsKey(typeof(T));
    }

    public static void Register<T>(T service)
    {
        Type type = typeof(T);
        if (services.ContainsKey(type))
        {
            Debug.LogWarning($"[ServiceLocator] '{type.Name}' 서비스가 이미 등록되어 있습니다. 덮어씁니다.");
            services[type] = service;
        }
        else
        {
            services.Add(type, service);
            Debug.Log($"[ServiceLocator] '{type.Name}' 서비스가 새로 등록되었습니다.");
        }
    }

    public static T Get<T>()
    {
        Type type = typeof(T);
        if (!services.TryGetValue(type, out object service))
        {
            Debug.LogError($"[ServiceLocator] '{type.Name}' 타입의 서비스를 찾을 수 없습니다!");
            return default;
        }
        return (T)service;
    }

    /// <summary>
    /// [추가된 메소드] 특정 타입의 서비스를 등록 해제합니다.
    /// PlayerController처럼 씬이 변경될 때 파괴되는 객체를 위해 필요합니다.
    /// </summary>
    public static void Unregister<T>(T service)
    {
        Type type = typeof(T);
        if (services.ContainsKey(type) && services[type].Equals(service))
        {
            services.Remove(type);
            Debug.Log($"[ServiceLocator] '{type.Name}' 서비스가 등록 해제되었습니다.");
        }
    }

    public static void Clear()
    {
        services.Clear();
    }
}

==================== Tags.cs (경로: ./TTttTT/Assets/1.Scripts/Core/Tags.cs) ====================
// 파일명: Tags.cs
public static class Tags
{
    public const string Player = "Player";
    public const string Monster = "Monster";
}

==================== Enums.cs (경로: ./TTttTT/Assets/1.Scripts/Core/Enums.cs) ====================
public enum CardType
{
    Physical, 
    Magical
}

public enum CardRarity
{
    Common,
    Rare,
    Epic,
    Legendary
}

public enum TriggerType
{
    Interval,
    OnHit,
    OnCrit,
    OnSkillUse,
    OnLowHealth
}

public enum CardEffectType
{
    
    SplitShot,  // 분열샷
    Wave,       // 파동
    Lightning,  // 번개
    Spiral      // 나선형 발사
}

public enum StatType
{
    Attack,
    AttackSpeed,
    MoveSpeed,
    Health,
    CritMultiplier,
    CritRate
}

public enum TargetingType
{
    Forward,
    Nearest,
    HighestHealth,
    LowestHealth,
    Random
}


==================== AudioManager.cs (경로: ./TTttTT/Assets/1.Scripts/Core/AudioManager.cs) ====================
// 파일명: AudioManager.cs (리팩토링 완료)
using UnityEngine;

public class AudioManager : MonoBehaviour
{
    [Header("오디오 소스 (Audio Sources)")]
    [SerializeField] private AudioSource bgmSource;
    [SerializeField] private AudioSource sfxSource;

    private AudioCollection currentCollection;

    void Awake()
    {
        // ServiceLocator에 이미 등록된 인스턴스가 있는지 확인
        if (ServiceLocator.IsRegistered<AudioManager>())
        {
            // 이미 있다면 나는 중복이므로 스스로 파괴
            Destroy(gameObject);
            return;
        }
        
        // 최초의 인스턴스일 경우, 등록하고 파괴되지 않도록 설정
        ServiceLocator.Register<AudioManager>(this);
        DontDestroyOnLoad(gameObject);
    }

    public void LoadCollection(AudioCollection newCollection)
    {
        currentCollection = newCollection;
    }

    public void PlayBgm(string clipName, bool loop = true)
    {
        if (currentCollection == null)
        {
            Debug.LogWarning("AudioManager: 재생할 AudioCollection이 로드되지 않았습니다!");
            return;
        }

        AudioClip clipToPlay = currentCollection.GetBgmClip(clipName);
        if (clipToPlay != null)
        {
            bgmSource.clip = clipToPlay;
            bgmSource.loop = loop;
            bgmSource.Play();
        }
    }

    public void PlaySfx(string clipName)
    {
        if (currentCollection == null)
        {
            Debug.LogWarning("AudioManager: 재생할 AudioCollection이 로드되지 않았습니다!");
            return;
        }

        AudioClip clipToPlay = currentCollection.GetSfxClip(clipName);
        if (clipToPlay != null)
        {
            sfxSource.PlayOneShot(clipToPlay);
        }
    }

    public void StopBgm()
    {
        bgmSource.Stop();
    }

    public void SetVolume(float bgmVol, float sfxVol)
    {
        bgmSource.volume = bgmVol;
        sfxSource.volume = sfxVol;
    }

    public float GetBgmVolume() => bgmSource.volume;
    public float GetSfxVolume() => sfxSource.volume;
}

==================== GameManager.cs (경로: ./TTttTT/Assets/1.Scripts/Core/GameManager.cs) ====================
// 파일명: GameManager.cs (리팩토링 완료)
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;
using UnityEngine.SceneManagement;
using System.Linq; // [수정] CS1061 오류 해결: .All() 메소드 사용을 위해 추가

public class GameManager : MonoBehaviour
{

    public enum GameState { MainMenu, CharacterSelect, PointAllocation, Gameplay, Reward, Pause, Codex, GameOver, Shop, Rest, Event }
    public GameState CurrentState { get; private set; }
    public CharacterDataSO SelectedCharacter { get; set; }
    public int AllocatedPoints { get; set; }
    public bool isFirstRound = true;

    public event System.Action<GameState> OnGameStateChanged;

    private SceneTransitionManager sceneTransitionManager;
    

    private void Awake()
    {
        Debug.Log($"[GameManager] Awake() 호출됨. (ID: {GetInstanceID()})");
        if (!ServiceLocator.IsRegistered<GameManager>())
        {
            ServiceLocator.Register<GameManager>(this);
            DontDestroyOnLoad(transform.root.gameObject);
            SceneManager.sceneLoaded += OnSceneLoaded;
        }
        else
        {
            Destroy(transform.root.gameObject);
        }
    }
    private void OnDestroy()
    {
        Debug.Log($"[생명주기] GameManager (ID: {GetInstanceID()}) - OnDestroy() 호출됨.");
        SceneManager.sceneLoaded -= OnSceneLoaded;
    }

    private void OnEnable()
    {
        Debug.Log($"[GameManager] OnEnable() 호출됨. (ID: {GetInstanceID()})");
        Debug.Log($"[생명주기] GameManager (ID: {GetInstanceID()}) - OnEnable() 호출됨.");
    }

    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        Debug.Log($"[GameManager] '{scene.name}' 씬 로드 완료. Mode: {mode}");
        if (CurrentState == GameState.Gameplay && mode == LoadSceneMode.Single)
        {
            StartCoroutine(StartRoundAfterSceneLoad());
        }
    }

    private void Start()
    {
        sceneTransitionManager = ServiceLocator.Get<SceneTransitionManager>();
        if (sceneTransitionManager == null) Debug.LogError("!!! GameManager: SceneTransitionManager를 찾을 수 없음!!!");
    }

    public void ChangeState(GameState newState)
    {
        if (CurrentState == newState && CurrentState != GameState.Gameplay) return;

        Debug.Log($"[GameManager] 상태 변경: {CurrentState} -> {newState}");
        CurrentState = newState;
        OnGameStateChanged?.Invoke(newState);

        if (newState == GameState.Pause)
        {
            Time.timeScale = 0;
            return;
        }
        else if (newState == GameState.GameOver)
        {
            StartCoroutine(GameOverRoutine());
            return;
        }

        Time.timeScale = 1;

        string sceneName = GetSceneNameForState(newState);
        if (newState == GameState.Gameplay)
        {
            sceneName = SceneNames.GamePlay;
        }

        if (!string.IsNullOrEmpty(sceneName))
        {
            Debug.Log($"[GameManager] 씬 로드 요청: {sceneName}");
            sceneTransitionManager.LoadScene(sceneName);
        }
    }

    private string GetSceneNameForState(GameState state)
    {
        switch (state)
        {
            case GameState.MainMenu: return SceneNames.MainMenu;
            case GameState.CharacterSelect: return SceneNames.CharacterSelect;
            case GameState.PointAllocation: return SceneNames.PointAllocation;
            case GameState.Reward: return SceneNames.CardReward;
            case GameState.Codex: return SceneNames.Codex;
            case GameState.Shop: return SceneNames.Shop;
            case GameState.Rest: return SceneNames.Rest;
            case GameState.Event: return SceneNames.Event;
            default: return "";
        }
    }

    /// <summary>
    /// [전면 재설계] 라운드에 필요한 모든 에셋(몬스터, 카드 효과 등)을 지능적으로 프리로드합니다.
    /// </summary>
    public IEnumerator PreloadAssetsForRound(RoundDataSO roundData, System.Action onComplete)
    {
        Debug.Log("--- [GameManager] 지능형 프리로딩 시작 ---");
        var poolManager = ServiceLocator.Get<PoolManager>();
        var cardManager = ServiceLocator.Get<CardManager>();
        if (poolManager == null || cardManager == null)
        {
            Debug.LogError("[GameManager] PoolManager 또는 CardManager를 찾을 수 없어 프리로딩을 중단합니다.");
            yield break;
        }

        var preloadRequests = new Dictionary<GameObject, int>();
        void AddOrUpdatePreloadRequest(GameObject prefab, int count)
        {
            if (prefab == null || count <= 0) return;
            if (preloadRequests.ContainsKey(prefab))
                preloadRequests[prefab] = Mathf.Max(preloadRequests[prefab], count);
            else
                preloadRequests.Add(prefab, count);
        }

        // --- 1. 몬스터 및 공용 프리팹 수집 (기존과 동일) ---
        // ... (PrefabProvider, RoundData를 통한 수집 로직) ...

        // --- 2. [신규 로직] 장착된 카드의 '옵션 부품'을 분석하여 프리팹 수집 ---
        Debug.Log($"<color=yellow>[Preload]</color> 장착된 카드 {cardManager.equippedCards.Count}개의 프리로드를 시작합니다.");
        
        // Task를 사용하여 모든 카드의 비동기 프리팹 로딩이 끝날 때까지 기다립니다.
        var cardPreloadTasks = new List<Task>();

        foreach (var card in cardManager.equippedCards)
        {
            // 각 카드에 대한 프리로드 작업을 Task로 만듭니다.
            Task cardTask = PreloadPrefabsFromCard(card, AddOrUpdatePreloadRequest);
            cardPreloadTasks.Add(cardTask);
        }

        // 모든 카드의 프리로드 작업이 완료될 때까지 대기
        yield return new WaitUntil(() => cardPreloadTasks.All(t => t.IsCompleted));
        
        Debug.Log($"<color=yellow>[Preload]</color> 모든 카드의 프리팹 분석 완료.");

        // --- 3. 최종 프리로드 실행 ---
        Debug.Log($"<color=yellow>[Preload]</color> 총 {preloadRequests.Count} 종류의 프리팹에 대한 프리로드를 실행합니다.");
        foreach (var request in preloadRequests)
        {
            poolManager.Preload(request.Key, request.Value);
        }
        
        Debug.Log("--- [GameManager] 지능형 프리로딩 완료 ---");
        onComplete?.Invoke();
    }
    
    /// <summary>
    /// 카드 하나에 포함된 모든 옵션 부품을 분석하여 필요한 프리팹을 로드하는 비동기 헬퍼 메소드입니다.
    /// </summary>
    private async Task PreloadPrefabsFromCard(CardDataSO card, Action<GameObject, int> AddOrUpdatePreloadRequest)
    {
        int requiredCount = card.preloadCount;
        Debug.Log($"<color=yellow>[Preload]</color> 카드 '{card.basicInfo.cardName}'에서 {card.attachedEffectReferences.Count}개의 옵션을 확인합니다.");

        foreach (var effectRef in card.attachedEffectReferences)
        {
            if (!effectRef.IsValid()) continue;

            // 옵션 부품(CardEffectSO)을 비동기로 로드
            var handle = effectRef.LoadAssetAsync<CardEffectSO>();
            await handle.Task;

            if (handle.Status == AsyncOperationStatus.Succeeded)
            {
                CardEffectSO effect = handle.Result;
                Task prefabLoadTask = null;

                // 옵션 부품의 종류에 따라 필요한 프리팹을 다시 비동기로 로드
                if (effect is ProjectileEffectSO pEffect && pEffect.bulletPrefabReference.IsValid())
                {
                    prefabLoadTask = pEffect.bulletPrefabReference.LoadAssetAsync<GameObject>().Task.ContinueWith(task =>
                    {
                        if (task.Status == TaskStatus.RanToCompletion)
                            AddOrUpdatePreloadRequest(task.Result, requiredCount);
                    });
                }
                else if (effect is AreaEffectSO aEffect && aEffect.effectPrefab != null)
                {
                    // AreaEffect는 GameObject를 직접 참조하므로 바로 추가
                     AddOrUpdatePreloadRequest(aEffect.effectPrefab, requiredCount);
                }
                
                if (prefabLoadTask != null) await prefabLoadTask;
            }
            
            // 사용한 핸들은 반드시 릴리즈
            Addressables.Release(handle);
        }
    }

    private IEnumerator GameOverRoutine()
    {
        // ▼▼▼ [추가] 씬을 전환하기 전에 모든 풀링된 오브젝트를 파괴합니다. ▼▼▼
        var poolManager = ServiceLocator.Get<PoolManager>();
        if (poolManager != null)
        {
            poolManager.DestroyAllPooledObjects();
        }
        // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

        var popupController = ServiceLocator.Get<PopupController>();
        if (popupController != null)
        {
            popupController.ShowError("GAME OVER", 3f);
        }
        yield return new WaitForSecondsRealtime(3f); // Use real-time seconds
        Time.timeScale = 1; // Resume game time before changing scene

        // ▼▼▼ 메인 메뉴 씬으로 바꾸기 직전에 이 부분을 추가하세요! ▼▼▼
        var cardManager = ServiceLocator.Get<CardManager>();
        if (cardManager != null)
        {
            cardManager.ClearAndResetDeck(); // 카드 매니저 초기화
        }

        // 만약 ArtifactManager도 초기화해야 한다면 비슷한 함수를 만들어 호출합니다.
        // var artifactManager = ServiceLocator.Get<ArtifactManager>();
        // if (artifactManager != null)
        // {
        //     artifactManager.ClearAndResetArtifacts(); 
        // }

        isFirstRound = true; // '첫 라운드'라는 표시도 다시 true로!

        ChangeState(GameState.MainMenu);
    }

    private IEnumerator StartRoundAfterSceneLoad()
    {
        Debug.Log("--- [GameManager] StartRoundAfterSceneLoad 코루틴 시작 ---");

        var mapManager = ServiceLocator.Get<MapManager>();
        var campaignManager = ServiceLocator.Get<CampaignManager>();

#if UNITY_EDITOR
        if (mapManager == null || !mapManager.IsMapInitialized)
        {
            Debug.LogWarning("[GameManager] 테스트 모드 감지: 필수 데이터 자동 설정 시작...");
            MapGenerator mapGenerator = FindObjectOfType<MapGenerator>();
            if (mapGenerator != null)
            {
                List<MapNode> mapData = mapGenerator.Generate();
                mapManager.InitializeMap(mapData, mapGenerator.MapWidth, mapGenerator.MapHeight);
                Debug.Log("[GameManager] 테스트용 맵 데이터 생성 및 초기화 완료.");
            }
            else
            {
                Debug.LogError("[GameManager] 테스트 모드 설정 실패: 씬에서 MapGenerator를 찾을 수 없습니다!");
                yield break;
            }

            if (SelectedCharacter == null)
            {
                SelectedCharacter = ServiceLocator.Get<DataManager>().GetCharacter(CharacterIDs.Warrior);
                Debug.Log("[GameManager] 테스트용 기본 캐릭터 'warrior' 설정 완료.");
            }
            AllocatedPoints = 0;
            isFirstRound = true;
        }
#endif
        yield return null;

        float timeout = 5f;
        float timer = 0f;
        RoundManager roundManager = null;
        while (roundManager == null || mapManager == null || campaignManager == null)
        {
            roundManager = FindObjectOfType<RoundManager>();
            timer += Time.deltaTime;
            if (timer > timeout)
            {
                Debug.LogError("[GameManager] 시간 초과! 씬 내 매니저(Round, Map, Campaign) 중 하나를 찾을 수 없습니다.");
                yield break;
            }
            yield return null;
        }
        Debug.Log("1. [GameManager] 모든 매니저 인스턴스를 성공적으로 찾았습니다.");

        timer = 0f;
        while (!mapManager.IsMapInitialized)
        {
            timer += Time.deltaTime;
            if (timer > timeout)
            {
                Debug.LogError("[GameManager] 시간 초과! MapManager가 초기화되지 않았습니다.");
                yield break;
            }
            yield return null;
        }
        Debug.Log("2. [GameManager] MapManager 초기화 완료됨을 확인했습니다.");

        MapNode currentNode = mapManager.CurrentNode;
        if (currentNode == null)
        {
            Debug.LogError("3. [GameManager] 에러! MapManager로부터 현재 노드 정보를 가져올 수 없습니다!");
            yield break;
        }

        Debug.Log($"3. [GameManager] 현재 노드(Y:{currentNode.Position.y})에 맞는 라운드 데이터를 찾습니다.");
        RoundDataSO roundToStart = campaignManager.GetRoundDataForNode(currentNode);

        if (roundToStart != null)
        {
            Debug.Log($"4. [GameManager] RoundManager에게 '{roundToStart.name}' 라운드 시작을 요청합니다.");
            yield return StartCoroutine(roundManager.StartRound(roundToStart));
            Time.timeScale = 1f;
        }
        else
        {
            Debug.LogError($"4. [GameManager] 에러! '{currentNode.Position}' 노드에 해당하는 라운드 데이터를 찾지 못했습니다!");
        }
        Debug.Log("--- [GameManager] StartRoundAfterSceneLoad 코루틴 정상 종료 ---");
    }
}


==================== PoolManager.cs (경로: ./TTttTT/Assets/1.Scripts/Core/PoolManager.cs) ====================
// 파일명: PoolManager.cs (리팩토링 완료)
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class PoolManager : MonoBehaviour
{
    private Dictionary<GameObject, Queue<GameObject>> poolDictionary = new Dictionary<GameObject, Queue<GameObject>>();
    
    // [추가] 현재 씬에 활성화된 모든 풀링 오브젝트를 추적하기 위한 HashSet
    private readonly HashSet<GameObject> activePooledObjects = new HashSet<GameObject>();

    void Awake()
    {
        Debug.Log($"[ 진단 ] PoolManager.Awake() 호출됨. (Frame: {Time.frameCount})");
        if (!ServiceLocator.IsRegistered<PoolManager>())
        {
            ServiceLocator.Register<PoolManager>(this);
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void Preload(GameObject prefab, int count)
    {
        if (prefab == null || count <= 0)
        {
            Debug.LogWarning("[PoolManager] Preload 실패: 프리팹이 null이거나 수량이 0 이하입니다.");
            return;
        }

        Debug.Log($"[ 진단-Preload ] 프리팹 '{prefab.name}' (ID: {prefab.GetInstanceID()}) {count}개 미리 생성 요청됨.");

        if (!poolDictionary.ContainsKey(prefab))
        {
            poolDictionary[prefab] = new Queue<GameObject>();
        }

        for (int i = 0; i < count; i++)
        {
            GameObject obj = Instantiate(prefab, transform);
            obj.SetActive(false);
            if (!obj.TryGetComponent<PooledObjectInfo>(out var pooledInfo))
            {
                pooledInfo = obj.AddComponent<PooledObjectInfo>();
            }
            pooledInfo.Initialize(prefab);
            poolDictionary[prefab].Enqueue(obj);
        }
    }

    

    public GameObject Get(GameObject prefab)
    {
        if (prefab == null)
        {
            Debug.LogError("[PoolManager] Get 실패: 요청한 프리팹이 null입니다.");
            return null;
        }

        if (!poolDictionary.ContainsKey(prefab) || poolDictionary[prefab].Count == 0)
        {
            Debug.LogWarning($"[PoolManager] {prefab.name} 풀이 비어있어 새로 생성합니다. Preload가 정상적으로 작동했는지 확인해보세요.");
            GameObject newObj = Instantiate(prefab);
            if (!newObj.TryGetComponent<PooledObjectInfo>(out var pooledInfo))
            {
                pooledInfo = newObj.AddComponent<PooledObjectInfo>();
            }
            pooledInfo.Initialize(prefab);
            return newObj;
        }

        GameObject obj = poolDictionary[prefab].Dequeue();
        obj.SetActive(true);

        // [추가] 오브젝트를 꺼내갈 때, 활성 목록에 등록합니다.
        activePooledObjects.Add(obj);

        return obj;
    }

    public void Release(GameObject instance)
    {
        if (instance == null) return;
        
        Debug.Log($"[PoolManager] Release 요청: {instance.name} (ID: {instance.GetInstanceID()})");

        // [추가] 오브젝트를 반납할 때, 활성 목록에서 제거합니다.
        activePooledObjects.Remove(instance);

        PooledObjectInfo pooledInfo = instance.GetComponent<PooledObjectInfo>();
        if (pooledInfo == null || pooledInfo.originalPrefab == null)
        {
            Debug.LogWarning($"[PoolManager] Release 실패: {instance.name} (ID: {instance.GetInstanceID()}) PooledObjectInfo 없음. 즉시 파괴.");
            Destroy(instance);
            return;
        }

        GameObject originalPrefab = pooledInfo.originalPrefab;

        if (!poolDictionary.ContainsKey(originalPrefab))
        {
            poolDictionary[originalPrefab] = new Queue<GameObject>();
        }

        instance.SetActive(false);
        Debug.Log($"[PoolManager] {instance.name} (ID: {instance.GetInstanceID()}) 비활성화 완료.");
        instance.transform.SetParent(transform);
        poolDictionary[originalPrefab].Enqueue(instance);
    }

    // [추가] 활성화된 모든 풀링 오브젝트를 정리하는 새로운 함수
    public void ClearAllActiveObjects()
    {
        Debug.Log($"[PoolManager] 활성화된 모든 풀 오브젝트 ({activePooledObjects.Count}개)를 정리합니다.");
        
        // HashSet을 직접 순회하면서 요소를 제거하면 오류가 발생하므로, 리스트로 복사한 뒤 순회합니다.
        foreach (var obj in activePooledObjects.ToList())
        {
            Release(obj);
        }
        
        // 모든 객체가 Release를 통해 개별적으로 제거되지만, 만약을 위해 마지막에 Clear를 호출합니다.
        activePooledObjects.Clear();
    }

    /// <summary>
    /// 모든 풀링된 오브젝트(활성 및 비활성)를 즉시 파괴하고 풀을 초기화합니다.
    /// 씬 전환 등 풀의 모든 오브젝트를 강제로 정리해야 할 때 사용합니다.
    /// </summary>
    public void DestroyAllPooledObjects()
    {
        Debug.Log($"[PoolManager] 모든 풀링된 오브젝트를 파괴합니다. (활성: {activePooledObjects.Count}개, 비활성 풀: {poolDictionary.Sum(kv => kv.Value.Count)}개)");

        // 활성 오브젝트 먼저 파괴
        foreach (var obj in activePooledObjects.ToList()) // ToList()로 복사하여 순회 중 수정 가능하게 함
        {
            Destroy(obj);
        }
        activePooledObjects.Clear();

        // 비활성 풀 오브젝트 파괴
        foreach (var kvp in poolDictionary)
        {
            foreach (var obj in kvp.Value)
            {
                Destroy(obj);
            }
        }
        poolDictionary.Clear();
        Debug.Log("[PoolManager] 모든 풀링된 오브젝트 파괴 완료.");
    }
}

==================== PrefabKeys.cs (경로: ./TTttTT/Assets/1.Scripts/Core/PrefabKeys.cs) ====================
// 파일명: PrefabKeys.cs
public static class PrefabKeys
{
    public const string Managers = "_Managers";
    public const string GameplaySession = "_GameplaySession";
    public const string DamageTextCanvas = "DamageTextCanvas";
}

==================== StatSources.cs (경로: ./TTttTT/Assets/1.Scripts/Core/StatSources.cs) ====================
// 파일명: StatSources.cs
public static class StatSources
{
    public const string Permanent = "Permanent";
    public const string Allocated = "Allocated";
}

==================== SceneAudioLoader.cs (경로: ./TTttTT/Assets/1.Scripts/Core/SceneAudioLoader.cs) ====================
//  : Assets/1.Scripts/Core/SceneAudioLoader.cs

using UnityEngine;

public class SceneAudioLoader : MonoBehaviour
{
    [Header("  ÷")]
    [SerializeField]
    private AudioCollection sceneAudioCollection;

    [Header(" BGM ̸ ( )")]
    [SerializeField]
    private string startingBgmName;

    void Start()
    {
        // [] ServiceLocator  AudioManager ɴϴ.
        var audioManager = ServiceLocator.Get<AudioManager>();
        if (audioManager == null)
        {
            Debug.LogError("SceneAudioLoader: AudioManager ã  ϴ!");
            return;
        }

        if (sceneAudioCollection != null)
        {
            // []  audioManager  մϴ.
            audioManager.LoadCollection(sceneAudioCollection);
            if (!string.IsNullOrEmpty(startingBgmName))
            {
                audioManager.PlayBgm(startingBgmName);
            }
        }
        else
        {
            Debug.LogWarning("SceneAudioLoader: AudioCollection Ҵ ʾҽϴ!", this.gameObject);
        }
    }
}

==================== InputManager.cs (경로: ./TTttTT/Assets/1.Scripts/Core/InputManager.cs) ====================
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using UnityEngine.SceneManagement; // Added for scene management events
using System.Collections;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations; // 코루틴 사용을 위해 추가

public class InputManager : MonoBehaviour
{
    // [삭제] 이 const 변수들은 더 이상 사용하지 않습니다.
    // private const string MANAGERS_PREFAB_PATH = PrefabKeys.Managers;
    // private const string SESSION_PREFAB_PATH = PrefabKeys.GameplaySession;

    

    public UnityEvent<Vector2> OnMove = new UnityEvent<Vector2>();
    private GameObject lastSelectedObject;

    void Awake()
    {
        ServiceLocator.Register<InputManager>(this);
        // DontDestroyOnLoad는 InitializeManagers에서 처리되므로 여기선 생략

        // 장면의 모든 GraphicRaycaster를 찾아 비활성화합니다.
        GraphicRaycaster[] allGraphicRaycasters = FindObjectsOfType<GraphicRaycaster>();
        foreach (GraphicRaycaster raycaster in allGraphicRaycasters)
        {
            raycaster.enabled = false;
        }

        // 장면의 모든 Physics2DRaycaster를 찾아 비활성화합니다.
        Physics2DRaycaster[] allPhysics2DRaycasters = FindObjectsOfType<Physics2DRaycaster>();
        foreach (Physics2DRaycaster raycaster in allPhysics2DRaycasters)
        {
            raycaster.enabled = false;
        }
    }

    void OnEnable()
    {
        SceneManager.sceneLoaded += OnSceneLoaded;
    }

    void OnDisable()
    {
        SceneManager.sceneLoaded -= OnSceneLoaded;
    }

    void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        // 기존 로직을 직접 실행하는 대신 코루틴을 시작시킵니다.
        StartCoroutine(OnSceneLoadedRoutine(scene, mode));
    }

    private IEnumerator OnSceneLoadedRoutine(Scene scene, LoadSceneMode mode)
    {
        // 한 프레임 대기하여 씬의 모든 오브젝트가 Awake() 및 OnEnable()을 마칠 시간을 줍니다.
        yield return null;

        Debug.Log($"[InputManager] 씬 로드됨: {scene.name}, 모드: {mode}");
        if (EventSystem.current == null)
        {
            Debug.LogWarning("[InputManager] 씬 로드 후 EventSystem.current가 null입니다.");
        }
        else
        {
            Debug.Log($"[InputManager] EventSystem.current: {EventSystem.current.gameObject.name}");
            if (EventSystem.current.currentInputModule != null)
            {
                Debug.Log($"[InputManager] 현재 입력 모듈: {EventSystem.current.currentInputModule.GetType().Name}, 활성화됨: {EventSystem.current.currentInputModule.enabled}");
            }
            else
            {
                // 이 코루틴 수정으로 인해 이 경고는 더 이상 나타나지 않을 것입니다.
                Debug.LogWarning("[InputManager] EventSystem.current.currentInputModule이 null입니다.");
            }
        }

        // 기존의 Raycaster 비활성화 로직은 그대로 유지합니다.
        GraphicRaycaster[] allGraphicRaycasters = FindObjectsOfType<GraphicRaycaster>();
        Debug.Log($"[InputManager] 씬 로드 후 {allGraphicRaycasters.Length}개의 GraphicRaycaster 발견.");
        foreach (GraphicRaycaster raycaster in allGraphicRaycasters)
        {
            if (raycaster.enabled)
            {
                Debug.LogWarning($"[InputManager] GraphicRaycaster '{raycaster.gameObject.name}'가 씬 로드 후 활성화되어 있습니다.");
                raycaster.enabled = false;
            }
        }

        Physics2DRaycaster[] allPhysics2DRaycasters = FindObjectsOfType<Physics2DRaycaster>();
        Debug.Log($"[InputManager] 씬 로드 후 {allPhysics2DRaycasters.Length}개의 Physics2DRaycaster 발견.");
        foreach (Physics2DRaycaster raycaster in allPhysics2DRaycasters)
        {
            if (raycaster.enabled)
            {
                Debug.LogWarning($"[InputManager] Physics2DRaycaster '{raycaster.gameObject.name}'가 씬 로드 후 활성화되어 있습니다.");
                raycaster.enabled = false;
            }
        }
    }

    void Update()
    {
        if (EventSystem.current == null) return;

        GameObject currentSelected = EventSystem.current.currentSelectedGameObject;

        // 1. 현재 무언가 선택되어 있고, 그게 Selectable(버튼, 토글 등)이라면 마지막 선택으로 기억합니다.
        if (currentSelected != null && currentSelected.GetComponent<Selectable>() != null)
        {
            lastSelectedObject = currentSelected;
        }
        // 2. 현재 선택된 것이 없거나, Selectable이 아닌 것(예: 배경 패널)이 선택되었다면
        else
        {
            // 3. 마지막으로 기억해 둔 Selectable이 있다면 강제로 포커스를 되돌립니다.
            if (lastSelectedObject != null && lastSelectedObject.activeInHierarchy)
            {
                EventSystem.current.SetSelectedGameObject(lastSelectedObject);
            }
        }

        // 게임플레이 중에는 키보드/게임패드 입력을 처리합니다.
        HandleGameplayInput();
    }

    private void HandleGameplayInput()
    {
        Vector2 move = new Vector2(Input.GetAxisRaw("Horizontal"), Input.GetAxisRaw("Vertical"));
        OnMove.Invoke(move.normalized);
    }
}

==================== CharacterIDs.cs (경로: ./TTttTT/Assets/1.Scripts/Core/CharacterIDs.cs) ====================
// 파일명: CharacterIDs.cs
public static class CharacterIDs
{
    public const string Warrior = "warrior";
    public const string Archer = "archer";
    public const string Mage = "mage";
}

==================== PooledObjectInfo.cs (경로: ./TTttTT/Assets/1.Scripts/Core/PooledObjectInfo.cs) ====================
using UnityEngine;

/// <summary>
/// 풀링된 오브젝트의 원본 프리팹 정보를 저장하는 컴포넌트입니다.
/// PoolManager가 오브젝트를 풀로 반환할 때 어떤 풀에 속하는지 식별하는 데 사용됩니다.
/// </summary>
public class PooledObjectInfo : MonoBehaviour
{
    public GameObject originalPrefab; // 이 오브젝트의 원본 프리팹

    /// <summary>
    /// 오브젝트 정보를 초기화합니다.
    /// </summary>
    /// <param name="prefab">이 오브젝트의 원본 프리팹</param>
    public void Initialize(GameObject prefab)
    {
        originalPrefab = prefab;
    }
}


==================== VFXAutoReturnToPool.cs (경로: ./TTttTT/Assets/1.Scripts/Gameplay/VFXAutoReturnToPool.cs) ====================
//  : Assets/1.Scripts/Gameplay/VFXAutoReturnToPool.cs
using UnityEngine;

/// <summary>
/// ƼŬ ý   ڵ PoolManager Ʈ ݳϴ  մϴ.
///  ũƮ ParticleSystem Ʈ ִ  Ʈ ߰ؾ մϴ.
/// </summary>
[RequireComponent(typeof(ParticleSystem))]
public class VFXAutoReturnToPool : MonoBehaviour
{
    // ĳõ ƼŬ ý Ʈ
    private ParticleSystem ps;

    //  Ʈ Ȱȭ (PoolManager.Get() ȣ ) ˴ϴ.
    void OnEnable()
    {
        ps = GetComponent<ParticleSystem>();

        // ƼŬ ý Main ⿡ մϴ.
        var main = ps.main;

        // ƼŬ   OnParticleSystemStopped() Լ ȣϵ մϴ.
        //  ڵ尡 ֱ  νͿ   ʿ䰡 ϴ.
        main.stopAction = ParticleSystemStopAction.Callback;
    }

    // Unity  , ƼŬ     Լ ڵ ȣ˴ϴ.
    void OnParticleSystemStopped()
    {
        // ServiceLocator  PoolManager ãƿ   Ʈ ݳ(Release)մϴ.
        ServiceLocator.Get<PoolManager>().Release(gameObject);
    }
}

==================== PlayerController.cs (경로: ./TTttTT/Assets/1.Scripts/Gameplay/PlayerController.cs) ====================
// 파일명: PlayerController.cs (리팩토링 완료)
using UnityEngine;

[RequireComponent(typeof(Rigidbody2D))]
public class PlayerController : MonoBehaviour
{
    private Rigidbody2D rb;
    private CharacterStats stats;
    private Vector2 moveInput;

    private CardManager cardManager;
    private EffectExecutor effectExecutor;
    private InputManager inputManager;

    [Header("공격 시작 위치")]
    public Transform firePoint;

    void Awake()
    {
        // 씬이 시작될 때 ServiceLocator에 자신을 등록합니다.
        ServiceLocator.Register<PlayerController>(this);
        Debug.Log($"[{GetType().Name}] ServiceLocator에 PlayerController를 등록했습니다.");

        rb = GetComponent<Rigidbody2D>();
        stats = GetComponent<CharacterStats>();

        cardManager = ServiceLocator.Get<CardManager>();
        effectExecutor = ServiceLocator.Get<EffectExecutor>();
        inputManager = ServiceLocator.Get<InputManager>();

        if (cardManager == null || effectExecutor == null || inputManager == null)
        {
            Debug.LogError($"[{GetType().Name}] Awake에서 필수 매니저 중 하나를 가져오지 못했습니다! ServiceLocator 등록 순서를 확인하세요.");
        }
    }

    void OnEnable()
    {
        if (inputManager != null)
        {
            inputManager.OnMove.AddListener(OnMove);
        }
        RoundManager.OnRoundEnded += HandleRoundEnd;
    }

    void OnDisable()
    {
        if (inputManager != null)
        {
            inputManager.OnMove.RemoveListener(OnMove);
        }
        RoundManager.OnRoundEnded -= HandleRoundEnd;
    }

    // 오브젝트가 파괴될 때 ServiceLocator에서 등록을 해제합니다.
    private void OnDestroy()
    {
        ServiceLocator.Unregister<PlayerController>(this);
        Debug.Log($"[{GetType().Name}] ServiceLocator에서 PlayerController를 등록 해제했습니다.");
    }

    private void HandleRoundEnd(bool success)
    {
        Debug.Log($"[{GetType().Name}] 라운드 종료(성공: {success}). 자동 공격을 중지합니다.");
        CancelInvoke(nameof(PerformAttack));
    }

    public void StartAutoAttackLoop()
    {
        CancelInvoke(nameof(PerformAttack));
        if (stats == null)
        {
            Debug.LogError($"[{GetType().Name}] CharacterStats가 없어 공격 루프를 시작할 수 없습니다!");
            return;
        }

        float interval = 1f / stats.FinalAttackSpeed;
        Debug.Log($"[{GetType().Name}] 공격 루프 시작. (공격 속도: {stats.FinalAttackSpeed}, 반복 주기: {interval}초)");

        if (float.IsInfinity(interval) || interval <= 0)
        {
            Debug.LogError($"[{GetType().Name}] 공격 주기가 비정상적({interval})이므로 공격을 시작할 수 없습니다!");
            return;
        }

        InvokeRepeating(nameof(PerformAttack), 0f, interval);
    }

    /// <summary>
    /// 설정된 공격 속도에 맞춰 자동으로 호출되는 공격 실행 메소드입니다.
    /// </summary>
    private void PerformAttack()
    {
        // 공격 실행 전, 필요한 모든 요소가 준비되었는지 확인
        if (cardManager == null || cardManager.activeCard == null || effectExecutor == null) return;
        
        // [디버그 로그 추가] 어떤 카드가 발사되는지 명확히 기록
        Debug.Log($"<color=cyan>[PlayerController]</color> '{cardManager.activeCard.basicInfo.cardName}' 카드 발사 요청 -> EffectExecutor");

        // '지휘자'에게 활성화된 카드, 시전자 정보, 발사 위치를 전달하여 실행을 명령
        effectExecutor.Execute(cardManager.activeCard, stats, firePoint);
    }

    void FixedUpdate()
    {
        if (stats == null || rb == null) return;
        Vector2 finalVelocity = moveInput * stats.FinalMoveSpeed;
        rb.velocity = finalVelocity;
    }

    private void OnMove(Vector2 input)
    {
        moveInput = input;
    }

    public void Heal(float amount)
    {
        if (stats != null)
        {
            Debug.Log($"[{GetType().Name}] {amount}만큼 체력을 회복합니다.");
            stats.Heal(amount);
        }
    }
}

==================== MonsterController.cs (경로: ./TTttTT/Assets/1.Scripts/Gameplay/MonsterController.cs) ====================
// 파일 경로: Assets/1.Scripts/Gameplay/MonsterController.cs

using UnityEngine;
using System.Collections;
using System.Collections.Generic;

[RequireComponent(typeof(Rigidbody2D), typeof(Collider2D))]
public class MonsterController : MonoBehaviour
{
    public static event System.Action<float, Vector3> OnMonsterDamaged;
    public static event System.Action<MonsterController> OnMonsterDied;

    [HideInInspector] public float moveSpeed;
    [HideInInspector] public float contactDamage;
    [HideInInspector] public float maxHealth;
    public float currentHealth;

    // 단일 타격 판정을 위해 외부에서 접근 가능해야 하므로 public으로 유지합니다.
    public HashSet<string> hitShotIDs = new HashSet<string>();

    private MonsterDataSO monsterData;
    private Transform playerTransform;
    private Rigidbody2D rb;
    private bool isDead = false;
    private bool isInvulnerable = false;
    private float lastDamageTime;
    public float damageCooldown = 0.5f; // Adjust as needed

    // ...

    // [미리 캐싱] Layer 비교를 위해 Player 레이어 인덱스를 저장해 둘 변수
    private int playerLayer;

    void Awake()
    {
        rb = GetComponent<Rigidbody2D>();
        // Layer 이름을 통해 숫자 인덱스를 찾아와 저장해둡니다. 매번 문자열로 찾는 것보다 효율적입니다.
        playerLayer = LayerMask.NameToLayer("Player");
    }

    void OnEnable()
    {
        ServiceLocator.Get<MonsterManager>()?.RegisterMonster(this);
        isDead = false;
        isInvulnerable = false;
        hitShotIDs.Clear(); // 몬스터가 재사용될 때마다 초기화
        lastDamageTime = -damageCooldown; // Ensure damage can be applied immediately on first contact
    }

    void OnDisable()
    {
        if (ServiceLocator.IsRegistered<MonsterManager>())
        {
            ServiceLocator.Get<MonsterManager>()?.UnregisterMonster(this);
        }
    }

    /// <summary>
    /// [핵심 수정] 몬스터를 초기화할 때, 추적할 대상을 명시적으로 주입받습니다.
    /// </summary>
    /// <param name="data">몬스터의 기본 데이터를 담은 ScriptableObject</param>
    /// <param name="target">몬스터가 추적할 대상의 Transform</param>
    public void Initialize(MonsterDataSO data, Transform target)
    {
        
        this.monsterData = data;
        this.playerTransform = target; // 주입받은 타겟을 저장
        
        maxHealth = data.maxHealth;
        moveSpeed = data.moveSpeed;
        contactDamage = data.contactDamage;
        currentHealth = maxHealth;
        isDead = false;
    }

    void FixedUpdate()
    {
        // 더 이상 매 프레임 플레이어를 찾는 비효율적인 작업을 하지 않습니다.
        if (isDead || playerTransform == null)
        {
            rb.velocity = Vector2.zero;
            return;
        }
        Vector2 direction = (playerTransform.position - transform.position).normalized;
        rb.velocity = direction * moveSpeed;
    }

    /// <summary>
    /// [핵심 수정] Tag 비교 대신, 훨씬 더 신뢰도 높은 Layer 비교 방식으로 변경합니다.
    /// </summary>
    void OnCollisionStay2D(Collision2D collision)
    {
        if (isDead) return;

        // 충돌한 게임오브젝트의 '레이어'가 우리가 설정한 'Player' 레이어와 일치하는지 확인합니다.
        if (collision.gameObject.layer == playerLayer)
        {
            if (collision.gameObject.TryGetComponent<CharacterStats>(out var playerStats))
            {
                // Apply damage only if cooldown has passed
                if (Time.time - lastDamageTime >= damageCooldown)
                {
                    playerStats.TakeDamage(contactDamage); // Apply full contactDamage
                    lastDamageTime = Time.time; // Reset cooldown
                }
            }
        }
    }

    // [핵심 변경] OnTrigger 관련 로직은 BulletController가 모두 처리하므로 삭제합니다.
    // 몬스터는 이제 총알과의 충돌을 전혀 신경쓰지 않고, 오직 TakeDamage 호출만 받습니다.

    /// <summary>
    /// 외부(주로 BulletController)에서 데미지를 입히기 위해 호출하는 유일한 통로입니다.
    /// </summary>
    public void TakeDamage(float damage)
    {
        if (isDead || isInvulnerable) return;

        currentHealth -= damage;
        OnMonsterDamaged?.Invoke(damage, transform.position); // 데미지 텍스트 UI 등을 위해 이벤트 발생

        if (currentHealth <= 0)
        {
            Die();
        }
    }

    private void Die()
    {
        if (isDead) return;
        isDead = true;
        OnMonsterDied?.Invoke(this);
        ServiceLocator.Get<PoolManager>().Release(gameObject);
    }

    /// <summary>
    /// 몬스터가 생성된 직후 잠시 무적이 되도록 외부(MonsterSpawner)에서 호출합니다.
    /// </summary>
    public void SetInvulnerable(float duration)
    {
        StartCoroutine(InvulnerableRoutine(duration));
    }

    private IEnumerator InvulnerableRoutine(float duration)
    {
        isInvulnerable = true;
        yield return new WaitForSeconds(duration);
        isInvulnerable = false;
    }
}

==================== MapGenerator.cs (경로: ./TTttTT/Assets/1.Scripts/Gameplay/MapGenerator.cs) ====================
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// 절차적 맵 생성을 담당하는 클래스입니다.
/// MonoBehaviour를 상속하여 Inspector에서 맵 생성 규칙을 쉽게 조정할 수 있습니다.
/// </summary>
public class MapGenerator : MonoBehaviour
{
    [Header("맵 크기 설정")]
    [SerializeField] private int mapHeight = 15; // y: 0 ~ 14
    [SerializeField] private int mapWidth = 5;   // x: 0 ~ 4

    // [추가됨] 다른 스크립트에서 맵 크기를 읽을 수 있도록 public getter를 추가합니다.
    public int MapHeight => mapHeight;
    public int MapWidth => mapWidth;

    [Header("노드 타입 생성 확률 (0~100%)")]
    [Range(0, 100)] [SerializeField] private float monsterChance = 60f;
    [Range(0, 100)] [SerializeField] private float restChance = 15f;
    [Range(0, 100)] [SerializeField] private float eventChance = 15f;
    [Range(0, 100)] [SerializeField] private float merchantChance = 10f; // 상점

    [Header("맵 경로 설정")]
    [SerializeField] private int numberOfPathsToGenerate = 4; // 생성할 경로의 개수

    [Header("디버그 옵션")]
    [SerializeField] private bool forceAllMonsters = true; // 이 옵션이 켜져 있으면 모든 노드를 몬스터로 강제합니다.

    /// <summary>
    /// 설정된 규칙에 따라 새로운 맵 데이터를 생성하고 노드 리스트를 반환합니다.
    /// </summary>
    /// <returns>생성된 모든 MapNode 객체의 리스트</returns>
    public List<MapNode> Generate()
    {

        // 맵 그리드 초기화 (모든 노드를 일단 생성)
        MapNode[,] grid = new MapNode[mapWidth, mapHeight];
        for (int y = 0; y < mapHeight; y++)
        {
            for (int x = 0; x < mapWidth; x++)
            {
                grid[x, y] = new MapNode { Position = new Vector2Int(x, y) };
            }
        }

        // 경로에 포함될 노드를 추적하기 위한 HashSet
        HashSet<MapNode> nodesInPaths = new HashSet<MapNode>();

        // 1. 고정된 시작/끝 노드 처리
        MapNode startNode = grid[mapWidth / 2, 0]; // y=0, x=2
        MapNode endNode = grid[mapWidth / 2, mapHeight - 1]; // y=14, x=2
        nodesInPaths.Add(startNode);
        nodesInPaths.Add(endNode);

        // 2. 지정된 개수만큼 경로 생성
        for (int i = 0; i < numberOfPathsToGenerate; i++)
        {
            GenerateSinglePath(grid, nodesInPaths, startNode, endNode);
        }

        // 3. 경로에 포함되지 않은 노드 삭제 및 최종 노드 리스트 생성
        List<MapNode> finalNodes = nodesInPaths.ToList();

        // 4. 노드 타입 할당 및 연결
        AssignNodeTypesAndConnectNodes(finalNodes, grid);

        return finalNodes;
    }

    /// <summary>
    /// 단일 경로를 생성하고, 경로에 포함된 노드들을 nodesInPaths에 추가합니다.
    /// </summary>
    private void GenerateSinglePath(MapNode[,] grid, HashSet<MapNode> nodesInPaths, MapNode startNode, MapNode endNode)
    {
        MapNode currentNode = startNode;
        nodesInPaths.Add(currentNode);

        for (int y = 0; y < mapHeight - 1; y++)
        {
            List<MapNode> possibleNextNodes = new List<MapNode>();

            if (y == 0) // y=0 -> y=1로 갈 때: y=1의 모든 x 노드로 연결 가능
            {
                for (int x = 0; x < mapWidth; x++)
                {
                    possibleNextNodes.Add(grid[x, y + 1]);
                }
            }
            else if (y == mapHeight - 2) // y=13 -> y=14로 갈 때: y=14의 x=2 노드로만 연결
            {
                possibleNextNodes.Add(endNode);
            }
            else // 일반적인 이동 규칙: x-1, x, x+1
            {
                int currentX = currentNode.Position.x;
                for (int dx = -1; dx <= 1; dx++)
                {
                    int nextX = currentX + dx;
                    if (nextX >= 0 && nextX < mapWidth)
                    {
                        possibleNextNodes.Add(grid[nextX, y + 1]);
                    }
                }
            }

            if (possibleNextNodes.Count > 0)
            {
                MapNode nextNode = possibleNextNodes[Random.Range(0, possibleNextNodes.Count)];
                nodesInPaths.Add(nextNode);
                currentNode = nextNode;
            }
            else
            {
                Debug.LogWarning($"[MapGenerator] 경로 생성 중 다음 노드를 찾을 수 없습니다. Y:{y}, X:{currentNode.Position.x}");
                break; // 경로 생성 실패
            }
        }
    }

    /// <summary>
    /// 최종 노드 리스트에 노드 타입을 할당하고, 노드 간 연결을 설정합니다.
    /// </summary>
    private void AssignNodeTypesAndConnectNodes(List<MapNode> finalNodes, MapNode[,] grid)
    {
        // 노드 타입 할당
        foreach (var node in finalNodes)
        {
            node.NodeType = GetNodeTypeForPosition(node.Position.y);
        }

        // 노드 연결
        foreach (var currentNode in finalNodes)
        {
            // y=14 노드는 다음 노드가 없습니다.
            if (currentNode.Position.y == mapHeight - 1) continue;

            List<MapNode> possibleNextLayerNodes = new List<MapNode>();

            if (currentNode.Position.y == 0) // y=0 노드: y=1에 있는 모든 노드와 연결
            {
                for (int x = 0; x < mapWidth; x++)
                {
                    MapNode nextNodeCandidate = grid[x, 1];
                    if (finalNodes.Contains(nextNodeCandidate))
                    {
                        possibleNextLayerNodes.Add(nextNodeCandidate);
                    }
                }
            }
            else if (currentNode.Position.y == mapHeight - 2) // y=13 노드: y=14의 x=2 노드와 연결
            {
                MapNode nextNodeCandidate = grid[mapWidth / 2, mapHeight - 1];
                if (finalNodes.Contains(nextNodeCandidate))
                {
                    possibleNextLayerNodes.Add(nextNodeCandidate);
                }
            }
            else // 일반적인 이동 규칙: x-1, x, x+1 범위 내의 다음 층 노드와 연결
            {
                int currentX = currentNode.Position.x;
                for (int dx = -1; dx <= 1; dx++)
                {
                    int nextX = currentX + dx;
                    if (nextX >= 0 && nextX < mapWidth)
                    {
                        MapNode nextNodeCandidate = grid[nextX, currentNode.Position.y + 1];
                        if (finalNodes.Contains(nextNodeCandidate))
                        {
                            possibleNextLayerNodes.Add(nextNodeCandidate);
                        }
                    }
                }
            }

            // 실제 연결
            foreach (var nextNode in possibleNextLayerNodes)
            {
                currentNode.NextNodes.Add(nextNode);
            }
        }
    }

    /// <summary>
    /// y 좌표에 따라 노드 타입을 결정합니다.
    /// </summary>
    private NodeType GetNodeTypeForPosition(int y)
    {
        // 시작(y=0)과 끝(y=14)은 항상 몬스터 노드
        if (y == 0 || y == mapHeight - 1)
        {
            return NodeType.Monster;
        }

        // 디버그 옵션이 켜져 있으면 항상 몬스터 반환
        if (forceAllMonsters)
        {
            return NodeType.Monster;
        }

        // ---- 향후 구현을 위한 확률 기반 노드 타입 결정 로직 ----
        // 현재는 주석 처리되어 있으며, forceAllMonsters가 false일 때 동작합니다.

        float totalChance = monsterChance + restChance + eventChance + merchantChance;
        float randomValue = Random.Range(0, totalChance);

        // if (randomValue < monsterChance)
        // {
        //     return NodeType.Monster;
        // }
        // else if (randomValue < monsterChance + restChance)
        // {
        //     // return NodeType.Rest; // 기능 구현 시 주석 해제
        //     return NodeType.Monster; // 현재는 몬스터로 대체
        // }
        // else if (randomValue < monsterChance + restChance + eventChance)
        // {
        //     // return NodeType.Event; // 기능 구현 시 주석 해제
        //     return NodeType.Monster; // 현재는 몬스터로 대체
        // }
        // else
        // {
        //     // return NodeType.Shop; // 기능 구현 시 주석 해제
        //     return NodeType.Monster; // 현재는 몬스터로 대체
        // }

        // 위 로직을 모두 주석처리하고 몬스터로 고정합니다.
        return NodeType.Monster;
    }
}

==================== PrefabProvider.cs (경로: ./TTttTT/Assets/1.Scripts/Gameplay/PrefabProvider.cs) ====================
// PrefabProvider.cs (최종 수정안)

using UnityEngine;
using System.Collections.Generic;

// ▼▼▼ [1] 프리팹과 개수를 묶는 클래스를 여기에 추가합니다. ▼▼▼
[System.Serializable]
public class PreloadItem
{
    public GameObject prefab;
    [Tooltip("미리 생성해 둘 개수입니다.")]
    public int count;
}

public class PrefabProvider : MonoBehaviour
{
    // ▼▼▼ [2] 리스트의 타입을 List<GameObject>에서 List<PreloadItem>으로 변경합니다. ▼▼▼
    [Header("공용 프리팹 목록 (Damage Text 등)")]
    [SerializeField] private List<PreloadItem> commonPreloadItems;

    [Header("특수 효과 프리팹")]
    [Tooltip("크리티컬 히트 시 생성될 이펙트 프리팹입니다.")]
    public GameObject critEffectPrefab;

    private readonly Dictionary<string, GameObject> prefabDictionary = new Dictionary<string, GameObject>();

    void Awake()
    {
        ServiceLocator.Register<PrefabProvider>(this);
        
        // commonPreloadItems 리스트를 기반으로 딕셔너리를 채웁니다.
        if (commonPreloadItems != null)
        {
            foreach (var item in commonPreloadItems)
            {
                if (item.prefab != null && !prefabDictionary.ContainsKey(item.prefab.name))
                {
                    // GetPrefab을 위해 이름-프리팹 쌍을 저장합니다.
                    prefabDictionary.Add(item.prefab.name, item.prefab);
                }
            }
        }
        Debug.Log($"[{GetType().Name}] 공용 프리팹 딕셔너리 초기화 완료. 총 {prefabDictionary.Count}개의 프리팹이 등록되었습니다.");
    }

    // GetPrefab 함수는 기존과 동일하게 유지됩니다.
    public GameObject GetPrefab(string name)
    {
        if (string.IsNullOrEmpty(name)) return null;
        prefabDictionary.TryGetValue(name, out GameObject prefab);
        if (prefab == null)
        {
            Debug.LogError($"[PrefabProvider] 프리팹 딕셔너리에서 '{name}'을(를) 찾을 수 없습니다.");
        }
        return prefab;
    }

    // ▼▼▼ [3] GameManager가 프리팹과 개수 정보를 함께 가져갈 수 있도록 새 함수를 추가합니다. ▼▼▼
    public List<PreloadItem> GetCommonPreloadItems() => commonPreloadItems;
}

==================== PointAllocationManager.cs (경로: ./TTttTT/Assets/1.Scripts/Gameplay/PointAllocationManager.cs) ====================
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class PointAllocationManager : MonoBehaviour
{
    [Header("UI 참조")]
    [SerializeField] private PointAllocationResultUI resultUI;
    [SerializeField] private TMP_InputField pointsToInvestInput_Actual;
    [SerializeField] private Button inputActivationButton;
    [SerializeField] private TextMeshProUGUI inputActivationButtonText;
    [SerializeField] private Button confirmButton;
    [SerializeField] private Button backButton;
    [SerializeField] private TextMeshProUGUI totalPointsText;

    [Header("코어 로직 참조")]
    [SerializeField] private MapGenerator mapGenerator;

    private CharacterDataSO selectedCharacter;
    private int totalCharacterPoints;

    private void Awake()
    {
        inputActivationButton.onClick.AddListener(ActivateInputMode);
        confirmButton.onClick.AddListener(OnConfirmAllocationClicked);
        backButton.onClick.AddListener(OnBackClicked);
        pointsToInvestInput_Actual.onEndEdit.AddListener(DeactivateInputMode);
    }

    void Start()
    {
        InitializeAllocation();
        if (resultUI != null)
        {
            resultUI.gameObject.SetActive(true);
            resultUI.UpdateDisplay(selectedCharacter.baseStats, null);
        }
        pointsToInvestInput_Actual.gameObject.SetActive(false);

        if (mapGenerator == null)
        {
            Debug.LogError("[PointAllocationManager] MapGenerator 참조가 설정되지 않았습니다! Inspector에서 연결해주세요.");
        }
    }

    private void OnConfirmAllocationClicked()
    {
        if (!int.TryParse(pointsToInvestInput_Actual.text, out int allocatedPoints))
        {
            allocatedPoints = 0;
        }

        // --- ServiceLocator를 통해 필요한 매니저들을 미리 가져옵니다. ---
        var gameManager = ServiceLocator.Get<GameManager>();
        var progressionManager = ServiceLocator.Get<ProgressionManager>();
        var mapManager = ServiceLocator.Get<MapManager>();
        var campaignManager = ServiceLocator.Get<CampaignManager>();

        gameManager.AllocatedPoints = allocatedPoints;

        CharacterPermanentStats permanentStats = progressionManager.GetPermanentStatsFor(selectedCharacter.characterId);
        Dictionary<StatType, int> distributedPoints = CalculateDistributedPoints(allocatedPoints, permanentStats);
        resultUI.UpdateDisplay(selectedCharacter.baseStats, distributedPoints);

        confirmButton.interactable = false;
        backButton.interactable = false;
        inputActivationButton.interactable = false;

        Debug.Log("[PointAllocationManager] 확인 버튼 클릭됨. 맵 생성을 시작합니다.");

        // 1. 맵 데이터를 먼저 생성하고 MapManager를 초기화합니다.
        if (mapGenerator != null && mapManager != null)
        {
            List<MapNode> mapData = mapGenerator.Generate();
            mapManager.InitializeMap(mapData, mapGenerator.MapWidth, mapGenerator.MapHeight);
            Debug.Log("[PointAllocationManager] MapManager 초기화 완료.");
        }
        else
        {
            Debug.LogError("[PointAllocationManager] MapGenerator 또는 MapManager 참조가 없어 맵을 생성할 수 없습니다!");
            confirmButton.interactable = true;
            backButton.interactable = true;
            inputActivationButton.interactable = true;
            return;
        }

        // 2. 캠페인 매니저를 통해 이번에 플레이할 캠페인을 미리 선택합니다.
        CampaignDataSO selectedCampaign = campaignManager.SelectRandomCampaign();
        if (selectedCampaign == null)
        {
            confirmButton.interactable = true;
            backButton.interactable = true;
            inputActivationButton.interactable = true;
            return;
        }

        // 3. 선택된 캠페인의 첫 번째 라운드 데이터를 가져옵니다.
        MapNode firstNode = mapManager.GetReachableNodes().FirstOrDefault();
        RoundDataSO firstRoundData = campaignManager.GetRoundDataForNode(firstNode);
        if (firstRoundData == null)
        {
            Debug.LogError("첫 라운드 데이터를 찾을 수 없어 프리로딩을 시작할 수 없습니다!");
            confirmButton.interactable = true;
            backButton.interactable = true;
            inputActivationButton.interactable = true;
            return;
        }

        // 4. GameManager의 준비 코루틴에 첫 라운드 데이터를 전달하여 프리로딩을 시작합니다.
        StartCoroutine(gameManager.PreloadAssetsForRound(firstRoundData, OnPreloadComplete));
    }

    private void OnPreloadComplete()
    {
        Debug.Log("[PointAllocationManager] 프리로딩 완료 신호를 받았습니다. Gameplay 씬으로 전환합니다.");
        ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.Gameplay);
    }

    public void ActivateInputMode()
    {
        inputActivationButton.gameObject.SetActive(false);
        pointsToInvestInput_Actual.gameObject.SetActive(true);
        EventSystem.current.SetSelectedGameObject(pointsToInvestInput_Actual.gameObject);
        pointsToInvestInput_Actual.ActivateInputField();
    }

    private void DeactivateInputMode(string text)
    {
        ValidateInputValue();
        string correctedText = pointsToInvestInput_Actual.text;
        if (string.IsNullOrEmpty(correctedText))
        {
            inputActivationButtonText.text = "포인트 입력...";
        }
        else
        {
            inputActivationButtonText.text = correctedText;
        }
        pointsToInvestInput_Actual.gameObject.SetActive(false);
        inputActivationButton.gameObject.SetActive(true);
        EventSystem.current.SetSelectedGameObject(inputActivationButton.gameObject);
    }

    private void InitializeAllocation()
    {
                        selectedCharacter = ServiceLocator.Get<GameManager>().SelectedCharacter ?? ServiceLocator.Get<DataManager>().GetCharacter(CharacterIDs.Warrior);
        totalCharacterPoints = selectedCharacter.initialAllocationPoints;
        if (totalPointsText != null) totalPointsText.text = $"Total Points: {totalCharacterPoints}";
    }

    private void ValidateInputValue()
    {
        if (!string.IsNullOrEmpty(pointsToInvestInput_Actual.text) && int.TryParse(pointsToInvestInput_Actual.text, out int points))
        {
            if (points > totalCharacterPoints)
            {
                pointsToInvestInput_Actual.text = totalCharacterPoints.ToString();
            }
            else if (points < 0)
            {
                pointsToInvestInput_Actual.text = "0";
            }
        }
    }

    public void OnBackClicked()
    {
        ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.CharacterSelect);
    }

    private Dictionary<StatType, int> CalculateDistributedPoints(int pointsToDistribute, CharacterPermanentStats permStats)
    {
        var pointCounts = new Dictionary<StatType, int>();
        foreach (StatType type in System.Enum.GetValues(typeof(StatType))) pointCounts[type] = 0;
        List<StatType> availableStats = permStats.GetUnlockedStats();
        if (availableStats.Count == 0) return pointCounts;
        for (int i = 0; i < pointsToDistribute; i++)
        {
            StatType targetStat = availableStats[Random.Range(0, availableStats.Count)];
            pointCounts[targetStat]++;
        }
        return pointCounts;
    }
}

==================== StatusEffectManager.cs (경로: ./TTttTT/Assets/1.Scripts/Gameplay/StatusEffectManager.cs) ====================
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// 게임 내 모든 캐릭터(플레이어, 몬스터)의 상태 효과(버프, 디버프)를 관리하는 클래스입니다.
/// </summary>
public class StatusEffectManager : MonoBehaviour
{
    private readonly Dictionary<GameObject, List<StatusEffect>> activeEffects = new Dictionary<GameObject, List<StatusEffect>>();
    private readonly List<StatusEffect> effectsToRemove = new List<StatusEffect>();
    private readonly List<GameObject> targetsToRemove = new List<GameObject>();

    void Awake()
    {
        ServiceLocator.Register<StatusEffectManager>(this);
    }

    void Update()
    {
        if (activeEffects.Count == 0) return;

        effectsToRemove.Clear();
        foreach (var entry in activeEffects.ToList()) // 순회 중 수정을 위해 ToList() 사용
        {
            GameObject target = entry.Key;
            if (target == null) // 대상이 파괴된 경우
            {
                targetsToRemove.Add(target);
                continue;
            }

            List<StatusEffect> effectsOnTarget = entry.Value;

            for (int i = effectsOnTarget.Count - 1; i >= 0; i--)
            {
                StatusEffect effect = effectsOnTarget[i];

                if (effect.effectData.damageOverTime > 0)
                {
                    if (target.CompareTag(Tags.Monster))
                    {
                        var monster = target.GetComponentInChildren<MonsterController>();
                        if (monster != null)
                        {
                            float damageThisFrame = effect.effectData.damageOverTime * monster.maxHealth * Time.deltaTime;
                            monster.TakeDamage(damageThisFrame);
                        }
                    }
                }

                effect.duration -= Time.deltaTime;
                if (effect.duration <= 0)
                {
                    effectsToRemove.Add(effect);
                }
            }
        }

        if (effectsToRemove.Count > 0)
        {
            foreach (StatusEffect effect in effectsToRemove) { RemoveStatusEffect(effect); }
        }

        if (targetsToRemove.Count > 0)
        {
            foreach (GameObject t in targetsToRemove) { activeEffects.Remove(t); }
            targetsToRemove.Clear();
        }
    }

    public void ApplyStatusEffect(GameObject target, StatusEffectDataSO effectData)
    { 
        if (target == null || effectData == null) return;

        StatusEffect newEffect = new StatusEffect(target, effectData);

        if (!activeEffects.ContainsKey(target))
        {
            activeEffects[target] = new List<StatusEffect>();
        }

        activeEffects[target].Add(newEffect);
        newEffect.ApplyEffect();
    }

    private void RemoveStatusEffect(StatusEffect effect)
    {
        if (effect == null || effect.target == null) return;

        if (activeEffects.TryGetValue(effect.target, out var effectList))
        {
            effect.RemoveEffect();
            effectList.Remove(effect);
        }
    }
}

/// <summary>
/// 활성화된 개별 상태 효과의 인스턴스 정보를 담는 클래스입니다.
/// </summary>
public class StatusEffect
{
    public GameObject target;
    public StatusEffectDataSO effectData;
    public float duration;

    public StatusEffect(GameObject target, StatusEffectDataSO effectData)
    {
        this.target = target;
        this.effectData = effectData;
        this.duration = effectData.duration;
    }

    // 이 효과가 적용될 때 즉시 실행되는 로직 (주로 스탯 버프/디버프)
    public void ApplyEffect()
    {
        if (target.TryGetComponent<CharacterStats>(out var stats))
        {
            effectData.ApplyEffect(stats);
        }
    }

    // 이 효과가 제거될 때 실행되는 로직 (스탯 원상복구)
    public void RemoveEffect()
    {
        if (target.TryGetComponent<CharacterStats>(out var stats))
        {
            effectData.RemoveEffect(stats);
        }
    }
}

==================== MonsterSpawner.cs (경로: ./TTttTT/Assets/1.Scripts/Gameplay/MonsterSpawner.cs) ====================
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class MonsterSpawner : MonoBehaviour
{
    [Header("스폰 위치 설정")]
    private Transform playerTransform;
    [SerializeField] private float minSpawnRadius = 10f;
    [SerializeField] private float maxSpawnRadius = 15f;

    private Coroutine spawnCoroutine;

    // ★★★ 핵심 수정: StartSpawning의 인자를 List<Wave>로 수정 (Assets.txt 기반) ★★★
    public void StartSpawning(List<Wave> waves)
    {
        Debug.Log("[MonsterSpawner] StartSpawning called.");
        if (spawnCoroutine != null) StopCoroutine(spawnCoroutine);
        spawnCoroutine = StartCoroutine(SpawnRoutine(waves));
    }

    // ★★★ 핵심 수정: StopSpawning() 함수 복원 (CS1061 오류 해결) ★★★
    public void StopSpawning()
    {
        Debug.Log("[MonsterSpawner] StopSpawning called.");
        if (spawnCoroutine != null)
        {
            StopCoroutine(spawnCoroutine);
            spawnCoroutine = null;
        }
    }

    private IEnumerator SpawnRoutine(List<Wave> waves)
    {
        // --- 기존 디버그 로그 보존 ---
        Debug.Log($"[MonsterSpawner] 스폰 루틴 시작. 전달받은 웨이브 개수: {waves.Count}");

        // playerTransform을 찾을 때까지 대기
        while (playerTransform == null)
        {
            var playerController = ServiceLocator.Get<PlayerController>();
            if (playerController != null)
            {
                playerTransform = playerController.transform;
                Debug.Log($"[MonsterSpawner] 성공: ServiceLocator를 통해 PlayerController를 찾아 playerTransform에 할당했습니다.");
            }
            else
            {
                // 아직 Player가 생성/등록되지 않았으면 한 프레임 대기 후 다시 시도
                yield return null;
            }
        }

        yield return new WaitForSeconds(1f);

        foreach (var wave in waves)
        {
            if (wave.monsterData == null)
            {
                // --- 기존 디버그 로그 보존 ---
                Debug.LogWarning("Wave에 몬스터 데이터가 설정되지 않아 해당 웨이브를 건너뜁니다.");
                continue;
            }

            // ▼▼▼ 방어 코드 추가 ▼▼▼
            if (playerTransform == null)
            {
                Debug.LogWarning("[MonsterSpawner] Player가 파괴되어 스폰을 중단합니다.");
                yield break; // 코루틴 즉시 종료
            }
            // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲

            switch (wave.spawnType)
            {
                case SpawnType.Spread:
                    float spawnInterval = (wave.count > 1 && wave.duration > 0) ? wave.duration / wave.count : 0.5f;
                    for (int i = 0; i < wave.count; i++)
                    {
                        SpawnMonster(wave.monsterData, playerTransform.position);
                        yield return new WaitForSeconds(spawnInterval);
                    }
                    yield return new WaitForSeconds(wave.delayAfterWave);
                    break;

                case SpawnType.Burst:
                    yield return new WaitForSeconds(wave.delayAfterWave);
                    for (int i = 0; i < wave.count; i++)
                    {
                        SpawnMonster(wave.monsterData, playerTransform.position);
                    }
                    break;
            }
        }
    }

    // ★★★ 핵심 수정: MonsterData를 MonsterDataSO로 변경 (CS0246 오류 해결) ★★★
    private void SpawnMonster(MonsterDataSO monsterData, Vector3 center)
    {
        if (monsterData == null)
        {
            // --- 기존 디버그 로그 보존 ---
            Debug.LogWarning("[MonsterSpawner] 스폰 실패! 전달된 MonsterDataSO가 null입니다.");
            return;
        }

        GameObject monsterPrefab = monsterData.prefab;

        if (monsterPrefab == null)
        {
            // --- 기존 디버그 로그 보존 ---
            Debug.LogError($"[MonsterSpawner] 스폰 실패! '{monsterData.monsterName}' 데이터에 프리팹이 연결되지 않았습니다.");
            return;
        }

        Vector2 randomDirection = Random.insideUnitCircle.normalized;
        float randomDistance = Random.Range(minSpawnRadius, maxSpawnRadius);
        Vector3 spawnPosition = center + (Vector3)(randomDirection * randomDistance);

        GameObject monsterInstance = ServiceLocator.Get<PoolManager>().Get(monsterPrefab);

        monsterInstance.transform.position = spawnPosition;

        MonsterController mc = monsterInstance.GetComponent<MonsterController>();
        if (mc != null)
        {
            // [핵심 수정] CS1501 오류 해결: Initialize 메소드에 두 번째 인자로 playerTransform을 전달합니다.
            mc.Initialize(monsterData, playerTransform);
            mc.SetInvulnerable(0.3f);

        }
    }
}

==================== ArtifactManager.cs (경로: ./TTttTT/Assets/1.Scripts/Gameplay/ArtifactManager.cs) ====================
using System.Collections.Generic;
using UnityEngine;

public class ArtifactManager : MonoBehaviour
{
    [Header("소유 유물")]
    public List<ArtifactDataSO> ownedArtifacts = new List<ArtifactDataSO>();

    private CharacterStats playerStats;

    private void Awake()
    {
        if (!ServiceLocator.IsRegistered<ArtifactManager>())
        {
            ServiceLocator.Register<ArtifactManager>(this);
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void LinkToNewPlayer(CharacterStats newPlayerStats)
    {
        playerStats = newPlayerStats;
        RecalculateArtifactStats();
    }

    public void EquipArtifact(ArtifactDataSO artifact)
    {
        // 1. playerStats가 null이라는 이유로 함수가 조기 종료되지 않도록 조건을 수정합니다.
        if (ownedArtifacts.Contains(artifact)) return;
        
        ownedArtifacts.Add(artifact);
        
        // 2. 스탯 적용 로직은 playerStats 참조가 유효할 때만 실행되도록 if문으로 감싸줍니다.
        if (playerStats != null)
        {
            playerStats.AddModifier(StatType.Attack, new StatModifier(artifact.attackBoostRatio, artifact));
            playerStats.AddModifier(StatType.Health, new StatModifier(artifact.healthBoostRatio, artifact));
            playerStats.AddModifier(StatType.MoveSpeed, new StatModifier(artifact.moveSpeedBoostRatio, artifact));
            playerStats.AddModifier(StatType.CritRate, new StatModifier(artifact.critChanceBoostRatio, artifact));
            playerStats.AddModifier(StatType.CritMultiplier, new StatModifier(artifact.critDamageBoostRatio, artifact));
        }
    }

    private void RecalculateArtifactStats()
    {
        if (playerStats == null) return;

        var allOwnedArtifacts = new List<ArtifactDataSO>(ownedArtifacts);
        foreach (var artifact in allOwnedArtifacts)
        {
            playerStats.RemoveModifiersFromSource(artifact);
        }

        foreach (var artifact in allOwnedArtifacts)
        {
            EquipArtifact(artifact);
        }
    }
}

==================== BulletController.cs (경로: ./TTttTT/Assets/1.Scripts/Gameplay/BulletController.cs) ====================
// 파일 경로: Assets/1.Scripts/Gameplay/BulletController.cs

using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[RequireComponent(typeof(Rigidbody2D), typeof(Collider2D))]
public class BulletController : MonoBehaviour
{
    // --- 투사체 고유 명세 ---
    private float speed;
    private int pierceCount;
    private int ricochetCount;
    private List<string> onHitPayloadIDs; // 피격 시 발동될 '옵션' ID 목록

    // --- 상태 추적 변수 ---
    private Vector2 direction;
    private int currentPierce;
    private int currentRicochet;
    private MonsterController lastHitTarget;
    private readonly HashSet<MonsterController> hitMonsters = new HashSet<MonsterController>();

    public void Initialize(Vector2 dir, float spd, int pierce, int ricochet, List<string> payloads)
    {
        // 명세 설정
        this.direction = dir;
        this.speed = spd;
        this.pierceCount = pierce;
        this.ricochetCount = ricochet;
        this.onHitPayloadIDs = payloads;

        // 상태 초기화
        this.currentPierce = this.pierceCount;
        this.currentRicochet = this.ricochetCount;
        this.lastHitTarget = null;
        this.hitMonsters.Clear();

        // 물리 설정
        transform.rotation = Quaternion.LookRotation(Vector3.forward, dir);
        GetComponent<Rigidbody2D>().velocity = dir * speed;

        // 자동 소멸
        Invoke(nameof(Deactivate), 5f);
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (!other.TryGetComponent<MonsterController>(out var monster)) return;
        if (hitMonsters.Contains(monster)) return; // 이미 맞춘 대상은 무시

        hitMonsters.Add(monster);

        // [핵심] 충돌 발생 시, EffectExecutor에게 모든 정보를 담아 '보고'하고 책임을 위임한다.
        var context = new EffectContext
        {
            Caster = ServiceLocator.Get<PlayerController>()?.GetComponent<CharacterStats>(),
            SpawnPoint = transform,      // 피격이 일어난 바로 그 위치
            HitPosition = transform.position,
            HitTarget = monster,
        };

        var effectExecutor = ServiceLocator.Get<EffectExecutor>();
        // 다음 행동 결정
        HandleNextAction(monster);
    }

    private void HandleNextAction(MonsterController currentTarget)
    {
        // 1. 리코셰 처리
        if (currentRicochet > 0)
        {
            currentRicochet--;
            lastHitTarget = currentTarget;

            Transform nextTarget = FindNextRicochetTarget();
            if (nextTarget != null)
            {
                direction = (nextTarget.position - transform.position).normalized;
                GetComponent<Rigidbody2D>().velocity = direction * speed;
                transform.rotation = Quaternion.LookRotation(Vector3.forward, direction);
                return; // 계속 비행
            }
        }

        // 2. 관통 처리
        if (currentPierce > 0)
        {
            currentPierce--;
            return; // 계속 비행
        }

        // 3. 소멸
        Deactivate();
    }

    private Transform FindNextRicochetTarget()
    {
        var monsterManager = ServiceLocator.Get<MonsterManager>();
        if (monsterManager == null) return null;

        // 마지막에 맞춘 몬스터를 제외하고 가장 가까운 몬스터를 찾음
        return monsterManager.ActiveMonsters
            .Where(m => m != lastHitTarget && m.gameObject.activeInHierarchy)
            .OrderBy(m => Vector3.Distance(transform.position, m.transform.position))
            .FirstOrDefault()?.transform;
    }

    private void Deactivate()
    {
        CancelInvoke();
        ServiceLocator.Get<PoolManager>().Release(gameObject);
    }
}

==================== RewardManager.cs (경로: ./TTttTT/Assets/1.Scripts/Gameplay/RewardManager.cs) ====================
// 파일 경로: Assets/1.Scripts/Gameplay/RewardManager.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// 게임 플레이 중 발생하는 모든 '보상' 관련 로직을 총괄하는 중앙 관리자입니다.
/// 라운드 승리/패배 여부를 기록하고, 카드 보상 큐를 관리하며, 보상 UI에 필요한 데이터를 제공합니다.
/// </summary>
public class RewardManager : MonoBehaviour
{
    // --- Public Properties --- //

    /// <summary>
    /// 마지막으로 플레이한 라운드에서 승리했는지 여부를 나타냅니다. (현재는 카드 보상에 직접적인 영향을 주지 않지만, 추후 다른 보상 시스템을 위해 유지됩니다.)
    /// </summary>
    public bool LastRoundWon { get; set; } = true;

    /// <summary>
    /// 현재 플레이어가 카드 보상 선택을 완료했는지 여부를 나타내는 중요한 상태 플래그입니다.
    /// true: 보상 선택이 끝났거나, 받을 보상이 없는 상태. (맵 노드 선택 가능)
    /// false: 보상 선택이 진행 중인 상태. (맵 노드 선택 불가, '보상 페이지로' 버튼 활성화)
    /// </summary>
    public bool IsRewardSelectionComplete { get; private set; } = true;


    // --- Private Fields --- //

    /// <summary>
    /// 제시할 카드 보상 목록을 순서대로 저장하는 큐(Queue)입니다.
    /// </summary>
    private Queue<List<CardDataSO>> cardRewardQueue = new Queue<List<CardDataSO>>();


    // --- Events --- //

    /// <summary>
    /// 처리할 새로운 카드 보상이 준비되었을 때 CardRewardUIManager에 알리는 static 이벤트입니다.
    /// </summary>
    public static event System.Action<List<CardDataSO>> OnCardRewardReady;

    /// <summary>
    /// 처리할 보상이 없어 즉시 맵 선택으로 건너뛰어야 할 때 UI에 알리는 static 이벤트입니다.
    /// </summary>
    public static event System.Action OnRewardSkipped;

    // --- Unity Lifecycle Methods --- //

    void Awake()
    {
        // ServiceLocator에 자기 자신을 등록하여 다른 시스템에서 접근할 수 있도록 합니다.
        if (!ServiceLocator.IsRegistered<RewardManager>())
        {
            ServiceLocator.Register<RewardManager>(this);
            // 씬이 전환되어도 파괴되지 않도록 설정합니다.
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    // --- Public Methods --- //

    /// <summary>
    /// 새로운 카드 보상 목록을 큐의 맨 뒤에 추가합니다.
    /// </summary>
    /// <param name="cardChoices">플레이어에게 보여줄 카드 선택지 목록</param>
    public void EnqueueReward(List<CardDataSO> cardChoices)
    {
        cardRewardQueue.Enqueue(cardChoices);
        Debug.Log($"[RewardManager] 새로운 카드 보상이 큐에 추가되었습니다. 현재 대기 중인 보상 수: {cardRewardQueue.Count}");
    }

    /// <summary>
    /// 처리 대기 중인 보상이 있는지 확인합니다.
    /// </summary>
    /// <returns>큐에 보상이 하나 이상 있으면 true, 아니면 false를 반환합니다.</returns>
    public bool HasPendingRewards()
    {
        return cardRewardQueue.Count > 0;
    }

    /// <summary>
    /// 큐에서 다음 보상을 꺼내어 처리하도록 이벤트를 발생시킵니다.
    /// </summary>
    public void ProcessNextReward()
    {
        Debug.Log("[RewardManager] ProcessNextReward() 호출됨.");
        if (cardRewardQueue.Count > 0)
        {
            // [핵심 로직] 보상 처리를 시작하므로, '선택 완료' 상태를 '진행 중' (false)으로 변경합니다.
            // 이 상태는 RouteSelectionController가 '보상 페이지로' 버튼을 활성화하는 데 사용됩니다.
            IsRewardSelectionComplete = false;

            List<CardDataSO> nextReward = cardRewardQueue.Dequeue();
            Debug.Log($"[RewardManager] 다음 보상을 처리합니다. 남은 보상 수: {cardRewardQueue.Count}. 'IsRewardSelectionComplete' 상태를 [false]로 설정.");

            // UI가 이벤트를 구독하고 있다면, 카드 선택지를 전달하여 화면에 표시하도록 합니다.
            Debug.Log("[RewardManager] OnCardRewardReady 이벤트 발생 시도.");
            OnCardRewardReady?.Invoke(nextReward);
        }
        else
        {
            // 처리할 보상이 없는 경우, 바로 완료 상태로 설정하고 '스킵' 이벤트를 발생시킵니다.
            IsRewardSelectionComplete = true;
            Debug.LogWarning("[RewardManager] 처리할 보상이 없어 즉시 맵 선택으로 건너뜁니다. 'IsRewardSelectionComplete' 상태를 [true]로 설정.");
            OnRewardSkipped?.Invoke();
        }
    }

    /// <summary>
    /// 플레이어가 카드 선택(획득, 합성, 스킵)을 완료했을 때 호출됩니다.
    /// </summary>
    public void CompleteRewardSelection()
    {
        // [핵심 로직] 보상 선택이 모두 끝났으므로, 상태를 '완료' (true)로 변경합니다.
        // 이 상태는 RouteSelectionController가 '보상 페이지로' 버튼을 비활성화하는 데 사용됩니다.
        IsRewardSelectionComplete = true;
        Debug.Log("[RewardManager] 카드 보상 선택이 완료되었습니다. 'IsRewardSelectionComplete' 상태를 [true]로 설정.");
    }
}

==================== CharacterStats.cs (경로: ./TTttTT/Assets/1.Scripts/Gameplay/CharacterStats.cs) ====================
using UnityEngine;
using UnityEngine.Events;
using System.Collections.Generic;
using System.Linq;

[RequireComponent(typeof(PlayerHealthBar))]
public class CharacterStats : MonoBehaviour
{
    [Header("기본 능력치")]
    public BaseStats stats;

    [Header("현재 상태 (런타임)")]
    public float currentHealth;
    public bool isInvulnerable = false;

    [Header("이벤트")]
    public UnityEvent OnFinalStatsCalculated = new UnityEvent();

    private PlayerHealthBar playerHealthBar;
    public float cardSelectionInterval = 10f;

    private readonly Dictionary<StatType, List<StatModifier>> statModifiers = new Dictionary<StatType, List<StatModifier>>();

    // [리팩토링] 최종 스탯을 실시간으로 계산하는 프로퍼티 (올바른 StatType 사용)
    public float FinalDamage
    {
        get
        {
            float totalBonusRatio = statModifiers[StatType.Attack].Sum(mod => mod.Value);
            return stats.baseDamage + totalBonusRatio;
        }
    }
    public float FinalAttackSpeed => Mathf.Max(0.1f, CalculateFinalValue(StatType.AttackSpeed, stats.baseAttackSpeed));
    public float FinalMoveSpeed => Mathf.Max(0f, CalculateFinalValue(StatType.MoveSpeed, stats.baseMoveSpeed));
    public float FinalHealth => Mathf.Max(1f, CalculateFinalValue(StatType.Health, stats.baseHealth));
    public float FinalCritRate => Mathf.Clamp(CalculateFinalValue(StatType.CritRate, stats.baseCritRate), 0f, 100f);
    public float FinalCritDamage => Mathf.Max(0f, CalculateFinalValue(StatType.CritMultiplier, stats.baseCritDamage));

    void Awake()
    {
        playerHealthBar = GetComponent<PlayerHealthBar>();
        foreach (StatType type in System.Enum.GetValues(typeof(StatType)))
        {
            statModifiers[type] = new List<StatModifier>();
        }
    }

    void OnDestroy()
    {
        var debugManager = ServiceLocator.Get<DebugManager>();
        if (debugManager != null)
        {
            debugManager.UnregisterPlayer();
        }
    }

    public void AddModifier(StatType type, StatModifier modifier)
    {
        statModifiers[type].Add(modifier);
        CalculateFinalStats();
    }

    public void RemoveModifiersFromSource(object source)
    {
        foreach (var key in statModifiers.Keys)
        {
            statModifiers[key].RemoveAll(mod => mod.Source == source);
        }
        CalculateFinalStats();
    }

    

    private float CalculateFinalValue(StatType type, float baseValue)
    {
        float totalBonusRatio = statModifiers[type].Sum(mod => mod.Value);
        return baseValue * (1 + totalBonusRatio / 100f);
    }

    public void CalculateFinalStats()
    {
        OnFinalStatsCalculated?.Invoke();
    }

    public void TakeDamage(float damage)
    {

        if (isInvulnerable) return;
        currentHealth -= damage;
        playerHealthBar.UpdateHealth(currentHealth, FinalHealth);
        if (currentHealth <= 0)
        {
            currentHealth = 0;
            Die();
        }
    }

    private void Die()
    {
        Debug.Log("[CharacterStats] 플레이어가 사망했습니다. 게임오버 상태로 전환합니다.");
        gameObject.SetActive(false);
        ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.GameOver);
    }

    public void Heal(float amount)
    {
        currentHealth += amount;
        if (currentHealth > FinalHealth) currentHealth = FinalHealth;
        playerHealthBar.UpdateHealth(currentHealth, FinalHealth);
    }

    public void ApplyPermanentStats(CharacterPermanentStats permanentStats)
    {
        if (permanentStats == null) return;
        RemoveModifiersFromSource(StatSources.Permanent);
        foreach (var stat in permanentStats.investedRatios)
        {
            AddModifier(stat.Key, new StatModifier(stat.Value, StatSources.Permanent));
        }
    }

    public void ApplyAllocatedPoints(int points, CharacterPermanentStats permStats)
    {
        if (points <= 0 || permStats == null) return;
        RemoveModifiersFromSource(StatSources.Allocated);

        List<StatType> availableStats = permStats.GetUnlockedStats();
        if (availableStats.Count == 0) return;

        for (int i = 0; i < points; i++)
        {
            StatType targetStat = availableStats[Random.Range(0, availableStats.Count)];
            float weight = GetWeightForStat(targetStat);
            AddModifier(targetStat, new StatModifier(weight, StatSources.Allocated));
        }
    }

    private float GetWeightForStat(StatType stat)
    {
        return stat == StatType.Health ? 2f : 1f;
    }

    public float GetCurrentHealth()
    {
        return currentHealth;
    }

    public static BaseStats CalculatePreviewStats(BaseStats baseStats, int allocatedPoints)
    {
        BaseStats previewStats = new BaseStats();
        float healthGeneBoosterRatio = allocatedPoints * 2f;
        float otherStatsGeneBoosterRatio = allocatedPoints * 1f;

        previewStats.baseHealth = baseStats.baseHealth * (1 + healthGeneBoosterRatio / 100f);
        previewStats.baseDamage = baseStats.baseDamage * (1 + otherStatsGeneBoosterRatio / 100f);
        previewStats.baseAttackSpeed = baseStats.baseAttackSpeed * (1 + otherStatsGeneBoosterRatio / 100f);
        previewStats.baseMoveSpeed = baseStats.baseMoveSpeed * (1 + otherStatsGeneBoosterRatio / 100f);
        previewStats.baseCritDamage = baseStats.baseCritDamage * (1 + otherStatsGeneBoosterRatio / 100f);
        previewStats.baseCritRate = baseStats.baseCritRate;
        return previewStats;
    }
}

==================== DamagingZone.cs (경로: ./TTttTT/Assets/1.Scripts/Gameplay/DamagingZone.cs) ====================
using UnityEngine;
using System.Collections.Generic;

public class DamagingZone : MonoBehaviour
{
    [Header(" ")]
    public float singleHitDamage = 0f;
    public float damagePerTick = 10f;
    [Tooltip("     ִ  (). ĵ   100 ̻ Էϼ.")]
    public float tickInterval = 1.0f;
    public float duration = 5.0f;

    [Header("ĵ/ Ȯ ")]
    public float expansionSpeed = 1.0f;
    public float expansionDuration = 2.0f;

    public string shotInstanceID;
    public bool isSingleHitWaveMode = true;

    private List<MonsterController> targets = new List<MonsterController>();
    private float tickTimer;
    private float durationTimer;
    private float expansionTimer;
    private CircleCollider2D circleCollider;
    private Vector3 initialScale;
    private float initialColliderRadius;

    void Awake()
    {
        initialScale = transform.localScale;
        circleCollider = GetComponent<CircleCollider2D>();
        if (circleCollider != null)
        {
            initialColliderRadius = circleCollider.radius;
        }
    }

    void OnEnable()
    {
        tickTimer = 0f;
        durationTimer = duration;
        expansionTimer = 0f;
        transform.localScale = initialScale;
        targets.Clear();
    }

    public void Initialize(float singleHitDmg, float continuousDmgPerTick, float tickInt, float totalDur, float expSpeed, float expDur, bool isWave, string shotID)
    {
        this.singleHitDamage = singleHitDmg;
        this.damagePerTick = continuousDmgPerTick;
        this.tickInterval = tickInt;
        this.duration = totalDur;
        this.expansionSpeed = expSpeed;
        this.expansionDuration = expDur;
        this.isSingleHitWaveMode = isWave;
        this.shotInstanceID = shotID;
        OnEnable();
    }

    void Update()
    {
        durationTimer -= Time.deltaTime;
        if (durationTimer <= 0)
        {
            // --- [] PoolManager ȣ ڵ带 ϳ մϴ. ---
            var poolManager = ServiceLocator.Get<PoolManager>();
            if (poolManager != null)
                poolManager.Release(gameObject);
            else
                Destroy(gameObject);
            return;
        }

        if (expansionTimer < expansionDuration)
        {
            expansionTimer += Time.deltaTime;
            transform.localScale += Vector3.one * expansionSpeed * Time.deltaTime;
        }

        if (!isSingleHitWaveMode)
        {
            tickTimer += Time.deltaTime;
            if (tickTimer >= tickInterval)
            {
                tickTimer = 0f;
                ApplyDamageToTargets();
            }
        }
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Monster"))
        {
            MonsterController monster = other.GetComponent<MonsterController>();
            if (monster == null) return;

            if (isSingleHitWaveMode)
            {
                if (!monster.hitShotIDs.Contains(this.shotInstanceID))
                {
                    monster.hitShotIDs.Add(this.shotInstanceID);
                    monster.TakeDamage(this.singleHitDamage);
                }
            }
            else
            {
                if (!targets.Contains(monster))
                {
                    targets.Add(monster);
                }
            }
        }
    }

    private void OnTriggerExit2D(Collider2D other)
    {
        if (other.CompareTag("Monster"))
        {
            MonsterController monster = other.GetComponent<MonsterController>();
            if (monster == null) return;

            if (!isSingleHitWaveMode)
            {
                if (targets.Contains(monster))
                {
                    targets.Remove(monster);
                }
            }
        }
    }

    private void ApplyDamageToTargets()
    {
        List<MonsterController> currentTargets = new List<MonsterController>(targets);
        foreach (var monster in currentTargets)
        {
            if (monster != null && monster.gameObject.activeInHierarchy)
            {
                monster.TakeDamage(damagePerTick);
            }
        }
    }
}

==================== RoundManager.cs (경로: ./TTttTT/Assets/1.Scripts/Gameplay/RoundManager.cs) ====================
using System.Collections;
using UnityEngine;
using System.Collections.Generic; // [1] using 문 추가
using System.Linq;                 // [2] using 문 추가

/// <summary>
/// 개별 전투 라운드의 시작, 진행, 종료를 관리하는 클래스입니다.
/// 몬스터 스폰, 킬 카운트, 제한 시간 등 라운드와 관련된 모든 핵심 로직을 담당합니다.
/// </summary>
public class RoundManager : MonoBehaviour
{
    // --- Events --- //
    public static event System.Action<RoundDataSO> OnRoundStarted;
    public static event System.Action<int, int> OnKillCountChanged;
    public static event System.Action<float> OnTimerChanged;
    public static event System.Action<bool> OnRoundEnded; // bool: 승리 여부

    // ▼▼▼ [3] Inspector에서 보상 카드 수를 설정할 변수 추가 ▼▼▼
    [Header("보상 설정")]
    [SerializeField] private int numberOfRewardChoices = 3;

    // --- Private State Fields --- //
    private MonsterSpawner monsterSpawner;
    private RoundDataSO currentRoundData;
    private int killCount;
    private float roundTimer;
    private bool isRoundActive;
    private Coroutine roundTimerCoroutine; // [1] 코루틴을 저장할 변수 추가

    // --- Unity Lifecycle Methods --- //
    void Awake()
    {
        monsterSpawner = GetComponent<MonsterSpawner>();
        if (monsterSpawner == null)
        {
            Debug.LogError($"[{GetType().Name}] CRITICAL: MonsterSpawner 컴포넌트를 찾을 수 없습니다! 몬스터가 스폰되지 않습니다.", this.gameObject);
        }
    }

    // ▼▼▼ [2] OnEnable, OnDisable 함수를 추가/수정하여 GameManager의 이벤트를 구독 ▼▼▼
    void OnEnable()
    {
        MonsterController.OnMonsterDied += HandleMonsterDied;
        
        // GameManager가 존재할 때만 이벤트를 구독하도록 예외 처리
        var gameManager = ServiceLocator.Get<GameManager>();
        if (gameManager != null)
        {
            gameManager.OnGameStateChanged += HandleGameStateChanged;
        }
    }

    void OnDisable()
    {
        MonsterController.OnMonsterDied -= HandleMonsterDied;

        var gameManager = ServiceLocator.Get<GameManager>();
        if (gameManager != null)
        {
            gameManager.OnGameStateChanged -= HandleGameStateChanged;
        }
    }
    
    // --- Public Methods --- //

    /// <summary>
    /// 새로운 라운드를 시작합니다.
    /// </summary>
    /// <param name="roundData">시작할 라운드의 데이터</param>
    public IEnumerator StartRound(RoundDataSO roundData)
    {
        if (isRoundActive)
        {
            Debug.LogWarning($"[{GetType().Name}] 경고: 이미 라운드가 진행 중일 때 StartRound가 호출되었습니다. 이전 라운드를 강제 종료하고 새 라운드를 시작합니다.");
            yield return StartCoroutine(EndRoundCoroutine(false));
        }

        currentRoundData = roundData;
        Debug.Log($"[{GetType().Name}] 새로운 라운드 시작: '{currentRoundData.name}' (목표 킬: {currentRoundData.killGoal}, 제한 시간: {currentRoundData.roundDuration}초)");

        // --- 플레이어 스탯 로그 (라운드 시작) ---
        var playerController = ServiceLocator.Get<PlayerController>();
        if (playerController != null)
        {
            var playerStats = playerController.GetComponent<CharacterStats>();
            if (playerStats != null)
            {
                System.Text.StringBuilder sb = new System.Text.StringBuilder();
                sb.AppendLine("--- 라운드 시작 플레이어 스탯 ---");
                sb.AppendLine($"체력: {playerStats.currentHealth:F1} / {playerStats.FinalHealth:F1}");
                sb.AppendLine($"공격력 보너스: {playerStats.FinalDamage:F2}%");
                sb.AppendLine($"공격 속도: {playerStats.FinalAttackSpeed:F2}");
                sb.AppendLine($"이동 속도: {playerStats.FinalMoveSpeed:F2}");
                sb.AppendLine($"치명타 확률: {playerStats.FinalCritRate:F2}%");
                sb.AppendLine($"치명타 피해: {playerStats.FinalCritDamage:F2}%");
                Debug.Log(sb.ToString());
            }
        }
        // --- 플레이어 스탯 로그 끝 ---

        // 라운드 상태 초기화
        killCount = 0;
        roundTimer = currentRoundData.roundDuration;
        isRoundActive = true;

        // 이벤트 구독
        // MonsterController.OnMonsterDied += HandleMonsterDied; // <-- 이 줄을 제거하세요!

        // UI 및 다른 시스템에 라운드 시작 알림
        OnRoundStarted?.Invoke(currentRoundData);

        // 몬스터 스폰 시작
        if (monsterSpawner != null)
        {
            // [수정] 사용자님이 공유해주신 RoundDataSO의 정확한 변수명인 'waves'를 사용합니다.
            monsterSpawner.StartSpawning(currentRoundData.waves);
        }

        // 라운드 타이머 코루틴 시작
        roundTimerCoroutine = StartCoroutine(RoundTimerCoroutine()); // 코루틴 참조를 저장
        yield return roundTimerCoroutine;
    }

    // --- Coroutines --- //

    private IEnumerator RoundTimerCoroutine()
    {
        Debug.Log($"[{GetType().Name}] 라운드 타이머 코루틴이 시작되었습니다.");
        while (roundTimer > 0 && isRoundActive)
        {
            roundTimer -= Time.deltaTime;
            OnTimerChanged?.Invoke(roundTimer);
            yield return null;
        }

        if (isRoundActive)
        {
            Debug.Log($"[{GetType().Name}] 시간 초과. 라운드를 종료합니다.");
            StartCoroutine(EndRoundCoroutine(false));
        }
    }

    private IEnumerator EndRoundCoroutine(bool wasKillGoalReached)
    {
        if (!isRoundActive) yield break;

        isRoundActive = false;
        roundTimerCoroutine = null; // 코루틴이 끝났으므로 참조를 비워줍니다.
        Debug.Log($"[{GetType().Name}] 라운드 종료 코루틴 시작. (승리: {wasKillGoalReached})");

        // --- 플레이어 스탯 로그 (라운드 종료) ---
        var playerController = ServiceLocator.Get<PlayerController>();
        if (playerController != null)
        {
            var playerStats = playerController.GetComponent<CharacterStats>();
            if (playerStats != null)
            {
                System.Text.StringBuilder sb = new System.Text.StringBuilder();
                sb.AppendLine("--- 라운드 종료 플레이어 스탯 ---");
                sb.AppendLine($"체력: {playerStats.currentHealth:F1} / {playerStats.FinalHealth:F1}");
                sb.AppendLine($"공격력 보너스: {playerStats.FinalDamage:F2}%");
                sb.AppendLine($"공격 속도: {playerStats.FinalAttackSpeed:F2}");
                sb.AppendLine($"이동 속도: {playerStats.FinalMoveSpeed:F2}");
                sb.AppendLine($"치명타 확률: {playerStats.FinalCritRate:F2}%");
                sb.AppendLine($"치명타 피해: {playerStats.FinalCritDamage:F2}%");
                Debug.Log(sb.ToString());
            }
        }
        // --- 플레이어 스탯 로그 끝 ---

        MonsterController.OnMonsterDied -= HandleMonsterDied;
        OnRoundEnded?.Invoke(wasKillGoalReached);

        if (monsterSpawner != null)
        {
            monsterSpawner.StopSpawning();
        }

        var rewardManager = ServiceLocator.Get<RewardManager>();
        if (rewardManager != null)
        {
            rewardManager.LastRoundWon = wasKillGoalReached;
            Debug.Log($"[{GetType().Name}] RewardManager에 라운드 결과({(wasKillGoalReached ? "승리" : "패배")})를 기록했습니다.");

        // ============ [핵심 추가 기능: 승리 시 보상 생성] ============
        if (wasKillGoalReached)
        {
            Debug.Log($"[{GetType().Name}] 라운드 승리! 카드 보상을 생성합니다.");
            var dataManager = ServiceLocator.Get<DataManager>();
            if (dataManager != null)
            {
                List<CardDataSO> allCards = dataManager.GetAllCards();
                List<CardDataSO> rewardChoices = new List<CardDataSO>();
                
                // 카드 데이터가 충분한지 확인
                if (allCards.Count >= numberOfRewardChoices)
                {
                    // 가중치에 따라 랜덤 카드 선택 (중복 없음)
                    List<CardDataSO> selectableCards = new List<CardDataSO>(allCards);
                    for (int i = 0; i < numberOfRewardChoices; i++)
                    {
                        if (selectableCards.Count == 0) break;

                        float totalWeight = selectableCards.Sum(card => card.rewardAppearanceWeight);

                        // ▼▼▼▼▼ [핵심 수정] 이 부분을 추가하세요 ▼▼▼▼▼
                        // 만약 모든 카드의 가중치가 0이라면, 가중치 없이 완전 랜덤으로 하나를 고릅니다.
                        if (totalWeight <= 0)
                        {
                            int randomIndex = Random.Range(0, selectableCards.Count);
                            rewardChoices.Add(selectableCards[randomIndex]);
                            selectableCards.RemoveAt(randomIndex);
                            continue; // 다음 카드를 뽑기 위해 for문의 다음 루프로 넘어갑니다.
                        }
                        // ▲▲▲▲▲ [여기까지 추가] ▲▲▲▲▲

                        float randomPoint = Random.Range(0, totalWeight);
                        float currentWeight = 0f;
                        CardDataSO selectedCard = null;

                        foreach (var card in selectableCards)
                        {
                            currentWeight += card.rewardAppearanceWeight;
                            if (randomPoint <= currentWeight)
                            {
                                selectedCard = card;
                                break;
                            }
                        }

                        // 만약 부동소수점 오류 등으로 선택이 안된 경우 마지막 카드를 선택
                        if (selectedCard == null && selectableCards.Count > 0)
                        {
                            selectedCard = selectableCards.Last();
                        }

                        if (selectedCard != null)
                        {
                            rewardChoices.Add(selectedCard);
                            selectableCards.Remove(selectedCard);
                        }
                    }
                }

                // 생성된 보상이 있으면 RewardManager의 대기열에 추가
                if (rewardChoices.Count > 0)
                {
                    rewardManager.EnqueueReward(rewardChoices);
                }
                else
                {
                    Debug.LogWarning($"[{GetType().Name}] 보상으로 제시할 카드를 생성하지 못했습니다. (카드 데이터 부족 가능성)");
                }
            }
        }
        else
        {
            Debug.Log($"[{GetType().Name}] 라운드 패배. 카드 보상을 생성하지 않습니다.");
        }
        // =============================================================
        }
        else
        {
            Debug.LogError($"[{GetType().Name}] CRITICAL: RewardManager를 찾을 수 없어 라운드 결과를 기록할 수 없습니다!");
        }

        // PoolManager를 통해 활성화된 모든 오브젝트(몬스터, 총알 등)를 정리합니다.
        var poolManager = ServiceLocator.Get<PoolManager>();
        if (poolManager != null)
        {
            poolManager.ClearAllActiveObjects();
        }

        Debug.Log($"[{GetType().Name}] GameManager 상태 변경 요청: {GameManager.GameState.Reward}");
        ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.Reward);
    }

    // --- Event Handlers --- //

    // ▼▼▼ [4] GameManager의 상태 변경을 감지할 핸들러 함수 추가 ▼▼▼
    private void HandleGameStateChanged(GameManager.GameState newState)
    {
        // 게임 상태가 '게임오버'로 바뀌면, 라운드 매니저의 모든 활동을 즉시 중단시킵니다.
        if (newState == GameManager.GameState.GameOver)
        {
            Debug.Log($"[{GetType().Name}] 게임오버 상태를 감지했습니다. 라운드 타이머를 강제 종료합니다.");
            isRoundActive = false;
            
            // 실행 중인 타이머 코루틴이 있다면 중지시킵니다.
            if (roundTimerCoroutine != null)
            {
                StopCoroutine(roundTimerCoroutine);
                roundTimerCoroutine = null;
            }
        }
    }

    // --- Event Handlers --- //

    private void HandleMonsterDied(MonsterController monster)
    {
        if (!isRoundActive) return;

        killCount++;
        Debug.Log($"[{GetType().Name}] 몬스터 처치. 현재 킬 수: {killCount}/{currentRoundData.killGoal}");
        OnKillCountChanged?.Invoke(killCount, currentRoundData.killGoal);

        if (killCount >= currentRoundData.killGoal)
        {
            Debug.Log($"[{GetType().Name}] 목표 킬 수를 달성했습니다! 라운드를 승리로 종료합니다.");
            StartCoroutine(EndRoundCoroutine(true));
        }
    }
}

==================== PlayerInitializer.cs (경로: ./TTttTT/Assets/1.Scripts/Gameplay/PlayerInitializer.cs) ====================
// --- 파일 위치: Assets/1/Scripts/Gameplay/PlayerInitializer.cs ---

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;

/// <summary>
/// 게임 시작 시 플레이어 오브젝트를 초기화하는 역할을 담당합니다. (최종 수정 버전)
/// </summary>
public class PlayerInitializer : MonoBehaviour
{
    [Header("테스트용 시작 카드 목록")]
    [Tooltip("캐릭터 데이터(SO)에 시작 카드가 설정되어 있으면, 이 목록은 무시됩니다.")]
    [SerializeField] private List<CardDataSO> testStartingCards;

    void Start()
    {
        EventSystem.current.SetSelectedGameObject(null);

        var playerStats = GetComponent<CharacterStats>();
        var playerController = GetComponent<PlayerController>();
        var gameManager = ServiceLocator.Get<GameManager>();
        var playerSpriteRenderer = GetComponent<SpriteRenderer>();
        var debugManager = ServiceLocator.Get<DebugManager>();

        if (debugManager != null)
        {
            debugManager.RegisterPlayer(playerStats);
        }

        CharacterDataSO characterToLoad = gameManager.SelectedCharacter ?? ServiceLocator.Get<DataManager>().GetCharacter(CharacterIDs.Warrior);
        if (characterToLoad == null)
        {
            Debug.LogError("CRITICAL: 적용할 캐릭터 데이터를 찾을 수 없습니다!");
            return;
        }

        playerStats.stats = characterToLoad.baseStats;
        playerSpriteRenderer.sprite = characterToLoad.illustration;

        var cardManager = ServiceLocator.Get<CardManager>();
        var artifactManager = ServiceLocator.Get<ArtifactManager>();

        if (gameManager.isFirstRound)
        {
            Debug.Log("<color=lime>[PlayerInitializer] 첫 라운드입니다. 시작 아이템과 영구 스탯을 적용합니다.</color>");

            // 매니저들에게 새로운 플레이어 정보를 연결합니다.
            if (cardManager != null) cardManager.LinkToNewPlayer(playerStats);
            if (artifactManager != null) artifactManager.LinkToNewPlayer(playerStats);

            // 첫 라운드에만 영구 스탯 적용 및 시작 아이템을 지급합니다.
            var progressionManager = ServiceLocator.Get<ProgressionManager>();
            CharacterPermanentStats permanentStats = progressionManager.GetPermanentStatsFor(characterToLoad.characterId);
            playerStats.ApplyPermanentStats(permanentStats);
            playerStats.ApplyAllocatedPoints(gameManager.AllocatedPoints, permanentStats);
            EquipStartingItems(characterToLoad, cardManager, artifactManager);

            gameManager.isFirstRound = false;
        }
        else
        {
            // ▼▼▼ [핵심 수정] 로그를 먼저 출력하고, 이후에 LinkToNewPlayer를 호출합니다. ▼▼▼
            Debug.Log("<color=yellow>[PlayerInitializer] 이후 라운드입니다. 기존 카드/유물 정보를 유지(재계산)합니다.</color>");

            // 이후 라운드에서는 새 플레이어 정보만 연결해주면, LinkToNewPlayer가 알아서 기존 상태를 복원합니다.
            if (cardManager != null) cardManager.LinkToNewPlayer(playerStats);
            if (artifactManager != null) artifactManager.LinkToNewPlayer(playerStats);
        }

        // 공통 마무리 (매 라운드 실행)
        playerStats.CalculateFinalStats();
        playerStats.currentHealth = playerStats.FinalHealth;
        if (cardManager != null) cardManager.StartCardSelectionLoop();
        if (playerController != null) playerController.StartAutoAttackLoop();
    }

    private void EquipStartingItems(CharacterDataSO characterData, CardManager cardManager, ArtifactManager artifactManager)
    {
        List<CardDataSO> cardsToEquip = new List<CardDataSO>();
        if (testStartingCards != null && testStartingCards.Count > 0)
        {
            cardsToEquip.AddRange(testStartingCards);
        }
        else if (characterData.startingCard != null)
        {
            cardsToEquip.Add(characterData.startingCard);
        }

        if (cardsToEquip.Count > 0 && cardManager != null)
        {
            foreach (var card in cardsToEquip)
            {
                if (card != null)
                {
                    cardManager.AddCard(card);
                    cardManager.Equip(card);
                }
            }
        }

        if (characterData.startingArtifacts != null && characterData.startingArtifacts.Count > 0)
        {
            if (artifactManager != null)
            {
                foreach (var artifact in characterData.startingArtifacts)
                {
                    if (artifact != null) artifactManager.EquipArtifact(artifact);
                }
            }
        }
    }
}

==================== CardManager.cs (경로: ./TTttTT/Assets/1.Scripts/Gameplay/CardManager.cs) ====================
// 파일 경로: Assets/1.Scripts/Gameplay/CardManager.cs
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class CardManager : MonoBehaviour
{
    [Header("카드 목록")]
    public List<CardDataSO> ownedCards = new List<CardDataSO>();
    public List<CardDataSO> equippedCards = new List<CardDataSO>();

    [Header("슬롯 설정")]
    public int maxOwnedSlots = 7;
    public int maxEquipSlots = 5;

    [Header("실시간 카드 상태")]
    public CardDataSO activeCard;

    private CharacterStats playerStats;
    private void Awake()
    {
        if (!ServiceLocator.IsRegistered<CardManager>())
        {
            ServiceLocator.Register<CardManager>(this);
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    void OnEnable()
    {
        RoundManager.OnRoundEnded += HandleRoundEnd;
    }

    void OnDisable()
    {
        RoundManager.OnRoundEnded -= HandleRoundEnd;
    }

    private void HandleRoundEnd(bool success)
    {
        CancelInvoke(nameof(SelectActiveCard));
    }

    /// <summary>
    /// 새로운 플레이어(새 라운드 시작 등)와 CardManager를 연결합니다.
    /// </summary>
    public void LinkToNewPlayer(CharacterStats newPlayerStats)
    {
        Debug.Log($"[CardManager] 새로운 플레이어와 연결. 기존 장착 카드 스탯 재계산을 시작합니다.");
        playerStats = newPlayerStats;
        RecalculateCardStats();
    }

    /// <summary>
    /// 새로운 카드를 획득하고, 빈 슬롯이 있다면 자동으로 장착합니다.
    /// </summary>
    public void AcquireNewCard(CardDataSO newCard)
    {
        // ... (소유 슬롯 초과 시 오래된 카드 제거 로직은 동일) ...
        ownedCards.Add(newCard);
        Debug.Log($"<color=lime>[CardManager]</color> 카드 획득: '{newCard.basicInfo.cardName}'. 현재 보유 카드: {ownedCards.Count}개");

        if (equippedCards.Count < maxEquipSlots)
        {
            Equip(newCard);
        }
        else
        {
            // ... (장착 슬롯 초과 시 랜덤 교체 로직은 동일) ...
        }
    }

    public void AddCard(CardDataSO cardToAdd)
    {
        if (ownedCards.Count >= maxOwnedSlots) return;
        ownedCards.Add(cardToAdd);
    }

    /// <summary>
    /// 카드를 장착하고, 카드의 패시브 스탯을 플레이어에게 적용합니다.
    /// </summary>
    public bool Equip(CardDataSO card)
    {
        if (equippedCards.Count >= maxEquipSlots || !ownedCards.Contains(card) || equippedCards.Contains(card))
        {
            return false;
        }

        equippedCards.Add(card);
        Debug.Log($"<color=lime>[CardManager]</color> 카드 장착: '{card.basicInfo.cardName}'");

        // [핵심 수정] 새로운 CardDataSO 구조에 맞춰 패시브 스탯 적용 로직 복구
        if (playerStats != null)
        {
            var mods = card.statModifiers;
            playerStats.AddModifier(StatType.Attack, new StatModifier(mods.damageMultiplier, card));
            playerStats.AddModifier(StatType.AttackSpeed, new StatModifier(mods.attackSpeedMultiplier, card));
            playerStats.AddModifier(StatType.MoveSpeed, new StatModifier(mods.moveSpeedMultiplier, card));
            playerStats.AddModifier(StatType.Health, new StatModifier(mods.healthMultiplier, card));
            playerStats.AddModifier(StatType.CritRate, new StatModifier(mods.critRateMultiplier, card));
            playerStats.AddModifier(StatType.CritMultiplier, new StatModifier(mods.critDamageMultiplier, card));
            Debug.Log($"<color=lime>[CardManager]</color> -> '{card.basicInfo.cardName}'의 패시브 스탯 적용 완료.");
        }
        return true;
    }
    public bool Unequip(CardDataSO card)
    {
        bool removed = equippedCards.Remove(card);

        if (removed && playerStats != null)
        {
            playerStats.RemoveModifiersFromSource(card);
        }
        return removed;
    }
    private void RecalculateCardStats()
    {
        if (playerStats == null) return;
        
        PrintEquippedCards("RecalculateCardStats 진입");
        var allOwnedCards = new List<CardDataSO>(ownedCards);
        foreach (var card in allOwnedCards)
        {
            playerStats.RemoveModifiersFromSource(card);
        }

        var currentEquippedCards = new List<CardDataSO>(equippedCards);
        var tempCardNames = currentEquippedCards.Select(c => c.basicInfo.cardName).ToArray();
        Debug.Log($"[디버그 추적] 임시 리스트 복사 완료 | 개수: {currentEquippedCards.Count} | 목록: [{string.Join(", ", tempCardNames)}]");

        equippedCards.Clear();
        
        PrintEquippedCards("equippedCards.Clear() 직후");
        
        foreach (var card in currentEquippedCards)
        {
            Debug.Log($"[디버그 추적] '{card.basicInfo.cardName}' 재장착 시도...");
            Equip(card);
        }
        
        PrintEquippedCards("RecalculateCardStats 종료");
    }

    public List<CardDataSO> GetEquippedCards()
    {
        return new List<CardDataSO>(equippedCards);
    }

    public void StartCardSelectionLoop()
    {
        CancelInvoke(nameof(SelectActiveCard));
        float interval = (playerStats != null) ? playerStats.cardSelectionInterval : 10f;
        InvokeRepeating(nameof(SelectActiveCard), 0f, interval);
        SelectActiveCard();
    }

    private void SelectActiveCard()
    {
        if (equippedCards.Count == 0)
        {
            activeCard = null;
            return;
        }
        
        var selectableCards = equippedCards.Where(c => c.selectionWeight > 0).ToList();
        if (selectableCards.Count == 0)
        {
            activeCard = equippedCards[0];
        }
        else
        {
            float totalWeight = selectableCards.Sum(card => card.selectionWeight);
            float randomPoint = Random.Range(0, totalWeight);
            float currentWeightSum = 0f;

            foreach (var card in selectableCards)
            {
                currentWeightSum += card.selectionWeight;
                if (randomPoint <= currentWeightSum)
                {
                    activeCard = card;
                    break;
                }
            }
        }

        if (activeCard != null)
        {
            Debug.Log($"[CardManager] <color=cyan>활성 카드 선택됨: {activeCard.basicInfo.cardName}</color>");
        }
    }

    public bool HasSynthesizablePair(CardDataSO card)
    {
        if (card == null) return false;
        return ownedCards.Any(ownedCard => ownedCard.basicInfo.type == card.basicInfo.type && ownedCard.basicInfo.rarity == card.basicInfo.rarity);
    }

    public List<CardDataSO> GetSynthesizablePairs(CardDataSO card)
    {
        return ownedCards.Where(ownedCard => ownedCard.basicInfo.type == card.basicInfo.type && ownedCard.basicInfo.rarity == card.basicInfo.rarity).ToList();
    }

    public void SynthesizeCards(CardDataSO rewardCard, CardDataSO materialCard)
    {
        // [수정] CS0103 오류 해결: 'wasEquipped' 변수 선언을 복구합니다.
        // 이 로직은 재료 카드가 파괴되기 전에 장착 상태였는지 미리 확인합니다.
        bool wasEquipped = equippedCards.Contains(materialCard);
        
        if (wasEquipped) Unequip(materialCard);
        ownedCards.Remove(materialCard);

        CardDataSO baseCard = Random.Range(0, 2) == 0 ? rewardCard : materialCard;
        CardDataSO enhancedCard = Instantiate(baseCard);
        
        enhancedCard.name = baseCard.name + "_Synth";
        enhancedCard.basicInfo.cardName = baseCard.basicInfo.cardName + "+";
        enhancedCard.statModifiers.damageMultiplier *= 1.1f;

        Debug.Log($"<color=lime>[CardManager]</color> 카드 합성: '{materialCard.basicInfo.cardName}'을(를) 재료로 '{enhancedCard.basicInfo.cardName}' 생성.");

        ownedCards.Add(enhancedCard);
        
        // 재료가 원래 장착되어 있었다면, 합성된 새 카드를 그 자리에 장착합니다.
        if (wasEquipped) Equip(enhancedCard);
    }

    public void ClearAndResetDeck()
    {
        ownedCards.Clear();
        equippedCards.Clear();
        Debug.LogWarning("[CardManager] 새 게임 시작. 모든 보유/장착 카드 목록을 초기화합니다.");
    }

    private void PrintEquippedCards(string context)
    {
        var cardNames = equippedCards.Select(c => c.basicInfo.cardName).ToArray();
        string cardList = string.Join(", ", cardNames);
        Debug.Log($"[디버그 추적] {context} | 장착 카드 수: {equippedCards.Count} | 목록: [{cardList}]");
    }
}

