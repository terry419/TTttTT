

--- 파일명: CardRewardTester.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/CardRewardTester.cs) ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// 카드 보상 시스템을 테스트하기 위한 클래스입니다.
/// 게임 실행 중 F5 키를 누르면 Inspector에 설정된 개수만큼 랜덤 카드를 생성하여 RewardManager에 전달합니다.
/// 이 스크립트는 정식 게임 로직이 아니므로, 테스트 시에만 활성화하는 것을 권장합니다.
/// </summary>
public class CardRewardTester : MonoBehaviour
{
    [Tooltip("테스트 시 보상으로 주어질 카드의 개수를 정합니다.")]
    [SerializeField] private int numberOfCardsToTest = 3;

    /// <summary>
    /// 매 프레임 키 입력을 감지합니다.
    /// </summary>
    void Update()
    {
        // F5 키를 누르면 테스트 보상 생성 함수를 호출합니다.
        if (Input.GetKeyDown(KeyCode.F5))
        {
            Debug.Log("[TESTER] F5 키 입력 감지. 테스트 보상을 생성합니다.");
            StartCoroutine(GenerateTestRewardCoroutine());
        }
    }

    /// <summary>
    /// RoundManager의 로직과 유사한 방식으로 테스트용 카드 보상을 생성하고 RewardManager에 전달합니다.
    /// </summary>
    private IEnumerator GenerateTestRewardCoroutine()
    {
        // 다른 Manager들이 준비될 시간을 줍니다.
        yield return null;

        var rewardManager = ServiceLocator.Get<RewardManager>();

        // 필수 매니저가 있는지 확인
        if (ServiceLocator.Get<DataManager>() == null || rewardManager == null)
        {
            Debug.LogError("[TESTER] DataManager 또는 RewardManager를 찾을 수 없어 테스트를 진행할 수 없습니다!");
            yield break;
        }

        // 1. DataManager에서 모든 카드 목록을 가져옵니다.
        List<CardDataSO> allCards = ServiceLocator.Get<DataManager>().GetAllCards();
        if (allCards.Count < numberOfCardsToTest)
        {
            Debug.LogError("[TESTER] 카드 데이터가 부족하여 테스트를 진행할 수 없습니다.");
            yield break;
        }

        // 2. 가중치에 따라 랜덤 카드를 선택합니다. (중복 없이 N개의 '선택지'를 만드는 로직)
        List<CardDataSO> randomChoices = new List<CardDataSO>();
        List<CardDataSO> selectableCards = new List<CardDataSO>(allCards);

        for (int i = 0; i < numberOfCardsToTest; i++)
        {
            if (selectableCards.Count == 0) break;

            float totalWeight = selectableCards.Sum(card => card.rewardAppearanceWeight);

            // 가중치가 모두 0일 경우, 일반 랜덤으로 선택
            if (totalWeight <= 0)
            {
                int randomIndex = Random.Range(0, selectableCards.Count);
                randomChoices.Add(selectableCards[randomIndex]);
                selectableCards.RemoveAt(randomIndex);
                continue;
            }

            float randomPoint = Random.Range(0, totalWeight);
            float currentWeight = 0f;
            CardDataSO selectedCard = null;

            foreach (var card in selectableCards)
            {
                currentWeight += card.rewardAppearanceWeight;
                if (randomPoint <= currentWeight)
                {
                    selectedCard = card;
                    break;
                }
            }

            // 부동소수점 오류 등으로 카드가 선택되지 않았을 경우, 마지막 카드를 안전하게 선택
            if (selectedCard == null && selectableCards.Count > 0)
            {
                selectedCard = selectableCards[selectableCards.Count - 1];
            }

            if (selectedCard != null)
            {
                randomChoices.Add(selectedCard);
                selectableCards.Remove(selectedCard);
            }
        }

        // 3. 생성된 카드 목록을 RewardManager의 큐에 추가하고, 보상 처리를 즉시 시작합니다.
        if (randomChoices.Count > 0)
        {
            Debug.Log($"[TESTER] {randomChoices.Count}개의 테스트 카드 보상을 큐에 추가합니다.");
            rewardManager.EnqueueReward(randomChoices);
            rewardManager.ProcessNextReward();
        }
    }
}

--- 파일명: AudioManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/AudioManager.cs) ---
// 파일명: AudioManager.cs (리팩토링 완료)
using UnityEngine;

public class AudioManager : MonoBehaviour
{
    [Header("오디오 소스 (Audio Sources)")]
    [SerializeField] private AudioSource bgmSource;
    [SerializeField] private AudioSource sfxSource;

    private AudioCollection currentCollection;

    void Awake()
    {
        // ServiceLocator에 자기 자신을 등록합니다.
        ServiceLocator.Register<AudioManager>(this);
    }

    public void LoadCollection(AudioCollection newCollection)
    {
        currentCollection = newCollection;
    }

    public void PlayBgm(string clipName, bool loop = true)
    {
        if (currentCollection == null)
        {
            Debug.LogWarning("AudioManager: 재생할 AudioCollection이 로드되지 않았습니다!");
            return;
        }

        AudioClip clipToPlay = currentCollection.GetBgmClip(clipName);
        if (clipToPlay != null)
        {
            bgmSource.clip = clipToPlay;
            bgmSource.loop = loop;
            bgmSource.Play();
        }
    }

    public void PlaySfx(string clipName)
    {
        if (currentCollection == null)
        {
            Debug.LogWarning("AudioManager: 재생할 AudioCollection이 로드되지 않았습니다!");
            return;
        }

        AudioClip clipToPlay = currentCollection.GetSfxClip(clipName);
        if (clipToPlay != null)
        {
            sfxSource.PlayOneShot(clipToPlay);
        }
    }

    public void StopBgm()
    {
        bgmSource.Stop();
    }

    public void SetVolume(float bgmVol, float sfxVol)
    {
        bgmSource.volume = bgmVol;
        sfxSource.volume = sfxVol;
    }

    public float GetBgmVolume() => bgmSource.volume;
    public float GetSfxVolume() => sfxSource.volume;
}

--- 파일명: CameraFollow.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/CameraFollow.cs) ---
using UnityEngine;

public class CameraFollow : MonoBehaviour
{
    public Transform target; // ī޶   (÷̾)
    public float smoothSpeed = 0.125f; // ī޶ 󰡴 ε巯 
    public Vector3 offset; // ī޶   Ÿ

    // ÷̾    Ŀ ī޶ ̵ LateUpdate մϴ.
    void LateUpdate()
    {
        if (target != null)
        {
            Vector3 desiredPosition = target.position + offset;
            Vector3 smoothedPosition = Vector3.Lerp(transform.position, desiredPosition, smoothSpeed);
            transform.position = smoothedPosition;
        }
    }
}

--- 파일명: CampaignManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/CampaignManager.cs) ---
// 파일명: CampaignManager.cs (리팩토링 완료)
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class CampaignManager : MonoBehaviour
{
    [Header("캠페인 목록")]
    [Tooltip("여기에 캠페인으로 사용될 모든 캠페인 SO 목록을 추가하세요.")]
    public List<CampaignDataSO> availableCampaigns;

    private CampaignDataSO currentCampaign;

    void Awake()
    {
        Debug.Log($"[생명주기] {GetType().Name} (ID: {gameObject.GetInstanceID()}) - Awake() 시작. (프레임: {Time.frameCount})");
        ServiceLocator.Register<CampaignManager>(this);
        DontDestroyOnLoad(gameObject);
    }

    /// <summary>
    /// [주 함수] 사용 가능한 캠페인 중 하나를 무작위로 선택합니다.
    /// </summary>
    public CampaignDataSO SelectRandomCampaign()
    {
        if (availableCampaigns == null || availableCampaigns.Count == 0)
        {
            Debug.LogError("[CampaignManager] 사용 가능한 캠페인이 없습니다!");
            currentCampaign = null;
            return null;
        }

        currentCampaign = availableCampaigns[Random.Range(0, availableCampaigns.Count)];
        Debug.Log($"[CampaignManager] 새로운 캠페인 '{currentCampaign.name}'이(가) 선택되었습니다. (아직 시작은 안 함)");
        return currentCampaign;
    }

    public CampaignDataSO GetCurrentCampaign()
    {
        return currentCampaign;
    }

    /// <summary>
    /// 노드의 Y좌표(인덱스)에 해당하는 라운드 데이터를 반환합니다.
    /// </summary>
    public RoundDataSO GetRoundDataForNode(MapNode node)
    {
        if (currentCampaign == null)
        {
            Debug.LogError("### 오류 ### GetRoundDataForNode 호출: currentCampaign이 null입니다! 인스펙터에 캠페인이 등록되었는지 확인하세요.");
            return null;
        }

        if (node == null) return null;

        int roundIndex = node.Position.y;

        if (roundIndex >= 0 && roundIndex < currentCampaign.rounds.Count)
        {
            Debug.Log($"요청한 노드(Y:{roundIndex})에 맞는 라운드 데이터 '{currentCampaign.rounds[roundIndex].name}'을 반환합니다.");
            return currentCampaign.rounds[roundIndex];
        }
        else
        {
            Debug.LogError($"잘못된 라운드 인덱스({roundIndex})가 요청되었습니다!");
            return null;
        }
    }

    public void ResetCampaign()
    {
    }

    private void OnDestroy()
    {
        Debug.Log($"[생명주기] {GetType().Name} (ID: {gameObject.GetInstanceID()}) - OnDestroy() 시작. (프레임: {Time.frameCount})");
    }
}

--- 파일명: CharacterIDs.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/CharacterIDs.cs) ---
// 파일명: CharacterIDs.cs
public static class CharacterIDs
{
    public const string Warrior = "warrior";
    public const string Archer = "archer";
    public const string Mage = "mage";
}

--- 파일명: DataManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/DataManager.cs) ---
// --- 파일명: DataManager.cs (역할 축소) ---
// 경로: Assets/1.Scripts/Core/DataManager.cs
using UnityEngine;
using System.Collections.Generic;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;
using System.Collections;

public class DataManager : MonoBehaviour
{
    void Awake()
    {
        ServiceLocator.Register<DataManager>(this);
        DontDestroyOnLoad(gameObject);
        // ▼▼▼ [2] Awake에서는 로딩 함수를 호출만 합니다. ▼▼▼
        StartCoroutine(LoadAllDataAsync());
    }

    // [삭제] 프리팹 관련 필드 모두 삭제

    private readonly Dictionary<string, CardDataSO> cardDataDict = new Dictionary<string, CardDataSO>();
    private readonly Dictionary<string, ArtifactDataSO> artifactDataDict = new Dictionary<string, ArtifactDataSO>();
    private readonly Dictionary<string, CharacterDataSO> characterDict = new Dictionary<string, CharacterDataSO>();
    private readonly Dictionary<string, MonsterDataSO> monsterDataDict = new Dictionary<string, MonsterDataSO>();

    // ▼▼▼ [3] 기존 InitializeDataSOs 함수를 아래 내용으로 완전히 교체합니다. ▼▼▼
    public IEnumerator LoadAllDataAsync()
    {
        Debug.Log("[DataManager] 모든 ScriptableObject 데이터 비동기 로드 시작...");

        var cardHandle = Addressables.LoadAssetsAsync<CardDataSO>("data_card", null);
        var artifactHandle = Addressables.LoadAssetsAsync<ArtifactDataSO>("data_artifact", null);
        var characterHandle = Addressables.LoadAssetsAsync<CharacterDataSO>("data_character", null);
        var monsterHandle = Addressables.LoadAssetsAsync<MonsterDataSO>("data_monster", null);

        var groupHandle = Addressables.ResourceManager.CreateGenericGroupOperation(
            new List<AsyncOperationHandle> { cardHandle, artifactHandle, characterHandle, monsterHandle }, true);

        yield return groupHandle;

        if (groupHandle.Status == AsyncOperationStatus.Succeeded)
        {
            foreach (var card in cardHandle.Result) { if (!cardDataDict.ContainsKey(card.cardID)) cardDataDict.Add(card.cardID, card); }
            foreach (var artifact in artifactHandle.Result) { if (!artifactDataDict.ContainsKey(artifact.artifactID)) artifactDataDict.Add(artifact.artifactID, artifact); }
            foreach (var character in characterHandle.Result) { if (!characterDict.ContainsKey(character.characterId)) characterDict.Add(character.characterId, character); }
            foreach (var monster in monsterHandle.Result) { if (!monsterDataDict.ContainsKey(monster.monsterID)) monsterDataDict.Add(monster.monsterID, monster); }
            
            Debug.Log("[DataManager] 모든 ScriptableObject 데이터 로드 완료.");
        }
        else
        {
            Debug.LogError("[DataManager] ScriptableObject 데이터 로딩 실패!");
        }
        
        Addressables.Release(cardHandle);
        Addressables.Release(artifactHandle);
        Addressables.Release(characterHandle);
        Addressables.Release(monsterHandle);
    }

    // [삭제] Get...Prefab 메서드들 삭제

    public CardDataSO GetCard(string id) => GetData(id, cardDataDict);
    public ArtifactDataSO GetArtifact(string id) => GetData(id, artifactDataDict);
    public CharacterDataSO GetCharacter(string id) => GetData(id, characterDict);
    public MonsterDataSO GetMonsterData(string id) => GetData(id, monsterDataDict);

    private T GetData<T>(string id, Dictionary<string, T> sourceDict) where T : class
    {
        sourceDict.TryGetValue(id, out T data);
        return data;
    }

    public List<CardDataSO> GetAllCards() => new List<CardDataSO>(cardDataDict.Values);
    public List<ArtifactDataSO> GetAllArtifacts() => new List<ArtifactDataSO>(artifactDataDict.Values);

    }


--- 파일명: DebugManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/DebugManager.cs) ---
// 파일명: DebugManager.cs (리팩토링 완료)
using UnityEngine;
using TMPro;
using System.Text;

/// <summary>
/// 개발 및 테스트 편의를 위한 디버그 기능을 관리하는 클래스입니다.
/// F1키로 디버그 UI를 토글하고, 게임 내 주요 변수를 실시간으로 확인하고 조작하는 기능을 제공합니다.
/// </summary>
public class DebugManager : MonoBehaviour
{
    [Header("디버그 UI 참조")]
    [SerializeField] private GameObject debugPanel;
    [SerializeField] private TextMeshProUGUI infoText;

    [Header("디버그 기능 설정")]
    [SerializeField] private float healthToAdd = 50f;

    private bool isDebugModeEnabled = false;
    private CharacterStats playerStats; // 외부에서 등록받을 플레이어 스탯 참조
    private StringBuilder infoBuilder = new StringBuilder();

    void Awake()
    {
        ServiceLocator.Register<DebugManager>(this);
        DontDestroyOnLoad(gameObject);
    }

    void Start()
    {
        if (debugPanel != null) debugPanel.SetActive(false);
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.F1))
        {
            ToggleDebugMode();
        }
        if (isDebugModeEnabled && debugPanel != null)
        {
            UpdateDebugInfo();
        }
    }

    public void ToggleDebugMode()
    {
        isDebugModeEnabled = !isDebugModeEnabled;
        if (debugPanel != null) debugPanel.SetActive(isDebugModeEnabled);
        Debug.Log($"디버그 모드: {(isDebugModeEnabled ? "활성화" : "비활성화")}");
    }

    // --- 외부 컴포넌트 등록/해제 메서드 ---

    /// <summary>
    /// PlayerStats 컴포넌트를 디버그 매니저에 등록합니다.
    /// </summary>
    public void RegisterPlayer(CharacterStats player)
    {
        playerStats = player;
        Debug.Log("[DebugManager] PlayerStats 등록됨.");
    }

    /// <summary>
    /// 등록된 PlayerStats 컴포넌트를 해제합니다.
    /// </summary>
    public void UnregisterPlayer()
    {
        playerStats = null;
        Debug.Log("[DebugManager] PlayerStats 등록 해제됨.");
    }

    private void UpdateDebugInfo()
    {
        if (infoText == null) return;
        infoBuilder.Clear();

        if (playerStats != null)
        {
            infoBuilder.AppendLine("--- Player Stats ---");
            infoBuilder.AppendLine($"Health: {playerStats.currentHealth:F1} / {playerStats.FinalHealth:F1}");
            infoBuilder.AppendLine($"Is Invulnerable: {playerStats.isInvulnerable}");
            infoBuilder.AppendLine($"Damage: {playerStats.FinalDamage:F2}");
            infoBuilder.AppendLine($"Attack Speed: {playerStats.FinalAttackSpeed:F2}");
            infoBuilder.AppendLine($"Move Speed: {playerStats.FinalMoveSpeed:F2}");
            infoBuilder.AppendLine($"Crit Rate: {playerStats.FinalCritRate:P2}");
            infoBuilder.AppendLine($"Crit Damage: {playerStats.FinalCritDamage:P2}");
        }
        else
        {
            infoBuilder.AppendLine("PlayerStats not registered.");
        }

        infoBuilder.AppendLine("\n--- Game Info ---");
        infoBuilder.AppendLine($"Active Monsters: {FindObjectsOfType<MonsterController>().Length}");
        infoText.text = infoBuilder.ToString();
    }

    // --- 디버그 UI의 버튼/슬라이더와 연결될 메서드들 ---

    public void GodMode(bool isOn)
    {
        if (playerStats != null)
        {
            playerStats.isInvulnerable = isOn;
            Debug.Log($"갓 모드: {isOn}");
        }
    }

    public void AddPlayerHealth()
    {
        if (playerStats != null)
        {
            playerStats.Heal(healthToAdd);
            Debug.Log($"플레이어 체력 {healthToAdd} 증가");
        }
    }

    public void KillAllMonsters()
    {
        MonsterController[] monsters = FindObjectsOfType<MonsterController>();
        foreach (var monster in monsters)
        {
            monster.TakeDamage(monster.currentHealth);
        }
        Debug.Log($"{monsters.Length}마리의 몬스터를 처치했습니다.");
    }
}

--- 파일명: EffectExecutor.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/EffectExecutor.cs) ---
// [리팩토링 완료]
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;

public class EffectExecutor : MonoBehaviour
{
    private Dictionary<CardEffectType, ICardEffectHandler> effectHandlers;

    void Awake()
    {
        Debug.Log($"[생명주기] {GetType().Name} (ID: {gameObject.GetInstanceID()}) - Awake() 시작. (프레임: {Time.frameCount})");
        ServiceLocator.Register<EffectExecutor>(this);
        DontDestroyOnLoad(gameObject);
        InitializeHandlers();
    }

    private void InitializeHandlers()
    {
        effectHandlers = new Dictionary<CardEffectType, ICardEffectHandler>
        {
            { CardEffectType.SingleShot, new SingleShotHandler() },
            { CardEffectType.SplitShot, new SplitShotHandler() },
            { CardEffectType.Wave, new WaveHandler() }
        };
    }

    // [리팩토링] 시전자(Caster)의 정보를 직접 매개변수로 받습니다.
    public void Execute(CardDataSO cardData, CharacterStats casterStats, Transform spawnPoint, float actualDamageDealt = 0f)
    {
        if (cardData == null || casterStats == null || spawnPoint == null)
        {
            Debug.LogError("[EffectExecutor] 필수 인자(CardData, CasterStats, SpawnPoint) 중 하나가 null입니다!");
            return;
        }

        // OnHit 효과 처리 (예: 생명력 흡수)
        if (cardData.triggerType == TriggerType.OnHit && cardData.lifestealPercentage > 0 && actualDamageDealt > 0)
        {
            casterStats.Heal(actualDamageDealt * cardData.lifestealPercentage);
        }

        // 카드 효과 타입에 따른 핸들러 실행
        if (effectHandlers.TryGetValue(cardData.effectType, out ICardEffectHandler handler))
        { 
            // 핸들러에게도 시전자 정보를 넘겨주어야 할 수 있습니다. (지금은 EffectExecutor만 넘김)
            handler.Execute(cardData, this, casterStats, spawnPoint);
        }
        else
        {
            Debug.LogError($"[EffectExecutor] '{cardData.effectType}' 타입에 대한 핸들러가 등록되어 있지 않습니다!");
        }
    }

    // [리팩토링] 데미지 계산 시에도 시전자의 스탯을 직접 받습니다.
    public float CalculateTotalDamage(CardDataSO cardData, CharacterStats casterStats)
    {
        if (casterStats == null || cardData == null || casterStats.stats.baseDamage <= 0)
        {
            return cardData != null ? cardData.baseDamage : 0f;
        }

        if (cardData.baseDamage <= 0)
        {
            return 0f;
        }

        // 캐릭터의 최종 데미지 배율을 계산합니다.
        float damageMultiplier = casterStats.FinalDamage / casterStats.stats.baseDamage;
        
        // 카드의 기본 데미지에 캐릭터의 최종 데미지 배율을 곱합니다.
        float finalDamage = cardData.baseDamage * damageMultiplier;

        return finalDamage;
    }

    // [리팩토링] 타겟팅 각도 계산 시에도 시전자의 위치 정보가 필요합니다.
    public float GetTargetingAngle(TargetingType targetingType, Transform casterTransform, Transform spawnPoint)
    {
        if (casterTransform == null || spawnPoint == null)
        {
             Debug.LogError("[EffectExecutor] GetTargetingAngle: casterTransform 또는 spawnPoint가 null입니다!");
            return 0f;
        }

        Transform target = TargetingSystem.FindTarget(targetingType, casterTransform);

        if (target != null)
        {
            Vector2 directionToTarget = (target.position - spawnPoint.position).normalized;
            return Mathf.Atan2(directionToTarget.y, directionToTarget.x) * Mathf.Rad2Deg;
        }
        else
        {
            return spawnPoint.eulerAngles.z;
        }
    }

    private void OnDestroy()
    {
        Debug.Log($"[생명주기] {GetType().Name} (ID: {gameObject.GetInstanceID()}) - OnDestroy() 시작. (프레임: {Time.frameCount})");
    }
}

--- 파일명: Enums.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/Enums.cs) ---
public enum CardType
{
    Physical, 
    Magical
}

public enum CardRarity
{
    Common,
    Rare,
    Epic,
    Legendary
}

public enum TriggerType
{
    Interval,
    OnHit,
    OnCrit,
    OnSkillUse,
    OnLowHealth
}

public enum CardEffectType
{
    SingleShot, // 기본 단일 발사
    SplitShot,  // 분열샷
    Wave,       // 파동
    Lightning,  // 번개
    Spiral      // 나선형 발사
}

public enum StatType
{
    Attack,
    AttackSpeed,
    MoveSpeed,
    Health,
    CritMultiplier,
    CritRate
}

public enum TargetingType
{
    Forward,
    Nearest,
    HighestHealth,
    LowestHealth,
    Random
}


--- 파일명: GameManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/GameManager.cs) ---
// 파일명: GameManager.cs (리팩토링 완료)
using System;
using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;
using UnityEngine.SceneManagement;

public class GameManager : MonoBehaviour
{

    public enum GameState { MainMenu, CharacterSelect, PointAllocation, Gameplay, Reward, Pause, Codex, GameOver, Shop, Rest, Event }
    public GameState CurrentState { get; private set; }
    public CharacterDataSO SelectedCharacter { get; set; }
    public int AllocatedPoints { get; set; }
    public bool isFirstRound = true;

    public event System.Action<GameState> OnGameStateChanged;

    private SceneTransitionManager sceneTransitionManager;
    

    private void Awake()
    {
        Debug.Log($"[GameManager] Awake() 호출됨. (ID: {GetInstanceID()})");
        ServiceLocator.Register<GameManager>(this);
        DontDestroyOnLoad(transform.root.gameObject);
        SceneManager.sceneLoaded += OnSceneLoaded;
    }
    private void OnDestroy()
    {
        Debug.Log($"[생명주기] GameManager (ID: {GetInstanceID()}) - OnDestroy() 호출됨.");
        SceneManager.sceneLoaded -= OnSceneLoaded;
    }

    private void OnEnable()
    {
        Debug.Log($"[GameManager] OnEnable() 호출됨. (ID: {GetInstanceID()})");
        Debug.Log($"[생명주기] GameManager (ID: {GetInstanceID()}) - OnEnable() 호출됨.");
    }

    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        Debug.Log($"[GameManager] '{scene.name}' 씬 로드 완료. Mode: {mode}");
        if (CurrentState == GameState.Gameplay && mode == LoadSceneMode.Single)
        {
            StartCoroutine(StartRoundAfterSceneLoad());
        }
    }

    private void Start()
    {
        sceneTransitionManager = ServiceLocator.Get<SceneTransitionManager>();
        if (sceneTransitionManager == null) Debug.LogError("!!! GameManager: SceneTransitionManager를 찾을 수 없음!!!");
    }

    public void ChangeState(GameState newState)
    {
        if (CurrentState == newState && CurrentState != GameState.Gameplay) return;

        Debug.Log($"[GameManager] 상태 변경: {CurrentState} -> {newState}");
        CurrentState = newState;
        OnGameStateChanged?.Invoke(newState);

        if (newState == GameState.Pause)
        {
            Time.timeScale = 0;
            return;
        }
        else if (newState == GameState.GameOver)
        {
            StartCoroutine(GameOverRoutine());
            return;
        }

        Time.timeScale = 1;

        string sceneName = GetSceneNameForState(newState);
        if (newState == GameState.Gameplay)
        {
            sceneName = SceneNames.GamePlay;
        }

        if (!string.IsNullOrEmpty(sceneName))
        {
            Debug.Log($"[GameManager] 씬 로드 요청: {sceneName}");
            sceneTransitionManager.LoadScene(sceneName);
        }
    }

    private string GetSceneNameForState(GameState state)
    {
        switch (state)
        {
            case GameState.MainMenu: return SceneNames.MainMenu;
            case GameState.CharacterSelect: return SceneNames.CharacterSelect;
            case GameState.PointAllocation: return SceneNames.PointAllocation;
            case GameState.Reward: return SceneNames.CardReward;
            case GameState.Codex: return SceneNames.Codex;
            case GameState.Shop: return SceneNames.Shop;
            case GameState.Rest: return SceneNames.Rest;
            case GameState.Event: return SceneNames.Event;
            default: return "";
        }
    }

    /// <summary>
    /// 지정된 라운드 데이터와 현재 장착 카드를 기반으로 필요한 에셋만 동적으로 프리로드합니다.
    /// </summary>
    public IEnumerator PreloadAssetsForRound(RoundDataSO roundData, System.Action onComplete)
    {
        Debug.Log("--- [GameManager] 동적 리소스 프리로딩 시작 ---");
        var poolManager = ServiceLocator.Get<PoolManager>();
        if (poolManager == null) { /* ... null 체크 ... */ yield break; }

        // 프리로드할 프리팹과, 요청된 최대 개수를 저장할 딕셔너리
        var preloadRequests = new Dictionary<GameObject, int>();

        // 헬퍼 함수: 딕셔너리에 프리로드 요청을 추가/갱신 (더 큰 값으로)
        void AddOrUpdatePreloadRequest(GameObject prefab, int count)
        {
            if (prefab == null) return;
            if (preloadRequests.ContainsKey(prefab))
            {
                // 이미 요청이 있다면, 더 큰 값으로 갱신
                preloadRequests[prefab] = Mathf.Max(preloadRequests[prefab], count);
            }
            else
            {
                preloadRequests.Add(prefab, count);
            }
        }

        // --- 데이터 수집 단계 ---

        // 1. 공용 프리팹 수집 (PrefabProvider)
        var prefabProvider = ServiceLocator.Get<PrefabProvider>();
        if (prefabProvider != null)
        {
            foreach (var item in prefabProvider.GetCommonPreloadItems())
            {
                AddOrUpdatePreloadRequest(item.prefab, item.count);
            }
        }

        // 2. 다음 라운드 몬스터 수집 (RoundData)
        if (roundData != null && roundData.waves != null)
        {
            foreach (var wave in roundData.waves)
            {
                if (wave.monsterData != null && wave.monsterData.prefab != null)
                {
                    // preloadCount가 0이면 웨이브의 전체 몬스터 수(count)를 사용
                    int count = wave.preloadCount > 0 ? wave.preloadCount : wave.count;
                    AddOrUpdatePreloadRequest(wave.monsterData.prefab, count);
                }
            }
        }

        // 3. 현재 장착 카드 프리팹 수집 (CardManager)
        var cardManager = ServiceLocator.Get<CardManager>();
        if (cardManager != null)
        {
            Debug.Log($"--- [100% 검증] 2. 프리로드 시점의 장착 카드 수: {cardManager.equippedCards.Count} ---");
            foreach (var card in cardManager.equippedCards)
            {
                AddOrUpdatePreloadRequest(card.bulletPrefab, card.bulletPreloadCount);
                AddOrUpdatePreloadRequest(card.effectPrefab, card.effectPreloadCount);
            }
        }

        // --- 프리로드 실행 단계 ---
        Debug.Log($"[GameManager] 총 {preloadRequests.Count} 종류의 프리팹에 대한 프리로드를 실행합니다.");
        foreach (var request in preloadRequests)
        {
            poolManager.Preload(request.Key, request.Value);
        }
        
        yield return null;
        Debug.Log("--- [GameManager] 동적 프리로딩 완료 ---");
        onComplete?.Invoke();
    }

    private IEnumerator GameOverRoutine()
    {
        // ▼▼▼ [추가] 씬을 전환하기 전에 모든 풀링된 오브젝트를 파괴합니다. ▼▼▼
        var poolManager = ServiceLocator.Get<PoolManager>();
        if (poolManager != null)
        {
            poolManager.DestroyAllPooledObjects();
        }
        // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

        var popupController = ServiceLocator.Get<PopupController>();
        if (popupController != null)
        {
            popupController.ShowError("GAME OVER", 3f);
        }
        yield return new WaitForSecondsRealtime(3f); // Use real-time seconds
        Time.timeScale = 1; // Resume game time before changing scene
        ChangeState(GameState.MainMenu);
    }

    private IEnumerator StartRoundAfterSceneLoad()
    {
        Debug.Log("--- [GameManager] StartRoundAfterSceneLoad 코루틴 시작 ---");

        var mapManager = ServiceLocator.Get<MapManager>();
        var campaignManager = ServiceLocator.Get<CampaignManager>();

#if UNITY_EDITOR
        if (mapManager == null || !mapManager.IsMapInitialized)
        {
            Debug.LogWarning("[GameManager] 테스트 모드 감지: 필수 데이터 자동 설정 시작...");
            MapGenerator mapGenerator = FindObjectOfType<MapGenerator>();
            if (mapGenerator != null)
            {
                List<MapNode> mapData = mapGenerator.Generate();
                mapManager.InitializeMap(mapData, mapGenerator.MapWidth, mapGenerator.MapHeight);
                Debug.Log("[GameManager] 테스트용 맵 데이터 생성 및 초기화 완료.");
            }
            else
            {
                Debug.LogError("[GameManager] 테스트 모드 설정 실패: 씬에서 MapGenerator를 찾을 수 없습니다!");
                yield break;
            }

            if (SelectedCharacter == null)
            {
                SelectedCharacter = ServiceLocator.Get<DataManager>().GetCharacter(CharacterIDs.Warrior);
                Debug.Log("[GameManager] 테스트용 기본 캐릭터 'warrior' 설정 완료.");
            }
            AllocatedPoints = 0;
            isFirstRound = true;
        }
#endif
        yield return null;

        float timeout = 5f;
        float timer = 0f;
        RoundManager roundManager = null;
        while (roundManager == null || mapManager == null || campaignManager == null)
        {
            roundManager = FindObjectOfType<RoundManager>();
            timer += Time.deltaTime;
            if (timer > timeout)
            {
                Debug.LogError("[GameManager] 시간 초과! 씬 내 매니저(Round, Map, Campaign) 중 하나를 찾을 수 없습니다.");
                yield break;
            }
            yield return null;
        }
        Debug.Log("1. [GameManager] 모든 매니저 인스턴스를 성공적으로 찾았습니다.");

        timer = 0f;
        while (!mapManager.IsMapInitialized)
        {
            timer += Time.deltaTime;
            if (timer > timeout)
            {
                Debug.LogError("[GameManager] 시간 초과! MapManager가 초기화되지 않았습니다.");
                yield break;
            }
            yield return null;
        }
        Debug.Log("2. [GameManager] MapManager 초기화 완료됨을 확인했습니다.");

        MapNode currentNode = mapManager.CurrentNode;
        if (currentNode == null)
        {
            Debug.LogError("3. [GameManager] 에러! MapManager로부터 현재 노드 정보를 가져올 수 없습니다!");
            yield break;
        }

        Debug.Log($"3. [GameManager] 현재 노드(Y:{currentNode.Position.y})에 맞는 라운드 데이터를 찾습니다.");
        RoundDataSO roundToStart = campaignManager.GetRoundDataForNode(currentNode);

        if (roundToStart != null)
        {
            Debug.Log($"4. [GameManager] RoundManager에게 '{roundToStart.name}' 라운드 시작을 요청합니다.");
            yield return StartCoroutine(roundManager.StartRound(roundToStart));
            Time.timeScale = 1f;
        }
        else
        {
            Debug.LogError($"4. [GameManager] 에러! '{currentNode.Position}' 노드에 해당하는 라운드 데이터를 찾지 못했습니다!");
        }
        Debug.Log("--- [GameManager] StartRoundAfterSceneLoad 코루틴 정상 종료 ---");
    }
}


--- 파일명: InputManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/InputManager.cs) ---
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using UnityEngine.SceneManagement; // Added for scene management events
using System.Collections;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations; // 코루틴 사용을 위해 추가

public class InputManager : MonoBehaviour
{
    // [삭제] 이 const 변수들은 더 이상 사용하지 않습니다.
    // private const string MANAGERS_PREFAB_PATH = PrefabKeys.Managers;
    // private const string SESSION_PREFAB_PATH = PrefabKeys.GameplaySession;

    

    public UnityEvent<Vector2> OnMove = new UnityEvent<Vector2>();
    private GameObject lastSelectedObject;

    void Awake()
    {
        ServiceLocator.Register<InputManager>(this);
        // DontDestroyOnLoad는 InitializeManagers에서 처리되므로 여기선 생략

        // 장면의 모든 GraphicRaycaster를 찾아 비활성화합니다.
        GraphicRaycaster[] allGraphicRaycasters = FindObjectsOfType<GraphicRaycaster>();
        foreach (GraphicRaycaster raycaster in allGraphicRaycasters)
        {
            raycaster.enabled = false;
        }

        // 장면의 모든 Physics2DRaycaster를 찾아 비활성화합니다.
        Physics2DRaycaster[] allPhysics2DRaycasters = FindObjectsOfType<Physics2DRaycaster>();
        foreach (Physics2DRaycaster raycaster in allPhysics2DRaycasters)
        {
            raycaster.enabled = false;
        }
    }

    void OnEnable()
    {
        SceneManager.sceneLoaded += OnSceneLoaded;
    }

    void OnDisable()
    {
        SceneManager.sceneLoaded -= OnSceneLoaded;
    }

    void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        // 기존 로직을 직접 실행하는 대신 코루틴을 시작시킵니다.
        StartCoroutine(OnSceneLoadedRoutine(scene, mode));
    }

    private IEnumerator OnSceneLoadedRoutine(Scene scene, LoadSceneMode mode)
    {
        // 한 프레임 대기하여 씬의 모든 오브젝트가 Awake() 및 OnEnable()을 마칠 시간을 줍니다.
        yield return null;

        Debug.Log($"[InputManager] 씬 로드됨: {scene.name}, 모드: {mode}");
        if (EventSystem.current == null)
        {
            Debug.LogWarning("[InputManager] 씬 로드 후 EventSystem.current가 null입니다.");
        }
        else
        {
            Debug.Log($"[InputManager] EventSystem.current: {EventSystem.current.gameObject.name}");
            if (EventSystem.current.currentInputModule != null)
            {
                Debug.Log($"[InputManager] 현재 입력 모듈: {EventSystem.current.currentInputModule.GetType().Name}, 활성화됨: {EventSystem.current.currentInputModule.enabled}");
            }
            else
            {
                // 이 코루틴 수정으로 인해 이 경고는 더 이상 나타나지 않을 것입니다.
                Debug.LogWarning("[InputManager] EventSystem.current.currentInputModule이 null입니다.");
            }
        }

        // 기존의 Raycaster 비활성화 로직은 그대로 유지합니다.
        GraphicRaycaster[] allGraphicRaycasters = FindObjectsOfType<GraphicRaycaster>();
        Debug.Log($"[InputManager] 씬 로드 후 {allGraphicRaycasters.Length}개의 GraphicRaycaster 발견.");
        foreach (GraphicRaycaster raycaster in allGraphicRaycasters)
        {
            if (raycaster.enabled)
            {
                Debug.LogWarning($"[InputManager] GraphicRaycaster '{raycaster.gameObject.name}'가 씬 로드 후 활성화되어 있습니다.");
                raycaster.enabled = false;
            }
        }

        Physics2DRaycaster[] allPhysics2DRaycasters = FindObjectsOfType<Physics2DRaycaster>();
        Debug.Log($"[InputManager] 씬 로드 후 {allPhysics2DRaycasters.Length}개의 Physics2DRaycaster 발견.");
        foreach (Physics2DRaycaster raycaster in allPhysics2DRaycasters)
        {
            if (raycaster.enabled)
            {
                Debug.LogWarning($"[InputManager] Physics2DRaycaster '{raycaster.gameObject.name}'가 씬 로드 후 활성화되어 있습니다.");
                raycaster.enabled = false;
            }
        }
    }

    void Update()
    {
        if (EventSystem.current == null) return;

        GameObject currentSelected = EventSystem.current.currentSelectedGameObject;

        // 1. 현재 무언가 선택되어 있고, 그게 Selectable(버튼, 토글 등)이라면 마지막 선택으로 기억합니다.
        if (currentSelected != null && currentSelected.GetComponent<Selectable>() != null)
        {
            lastSelectedObject = currentSelected;
        }
        // 2. 현재 선택된 것이 없거나, Selectable이 아닌 것(예: 배경 패널)이 선택되었다면
        else
        {
            // 3. 마지막으로 기억해 둔 Selectable이 있다면 강제로 포커스를 되돌립니다.
            if (lastSelectedObject != null && lastSelectedObject.activeInHierarchy)
            {
                EventSystem.current.SetSelectedGameObject(lastSelectedObject);
            }
        }

        // 게임플레이 중에는 키보드/게임패드 입력을 처리합니다.
        HandleGameplayInput();
    }

    private void HandleGameplayInput()
    {
        Vector2 move = new Vector2(Input.GetAxisRaw("Horizontal"), Input.GetAxisRaw("Vertical"));
        OnMove.Invoke(move.normalized);
    }
}

--- 파일명: MapManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/MapManager.cs) ---
// 파일명: MapManager.cs (리팩토링 완료)
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class MapManager : MonoBehaviour
{
    public bool IsMapInitialized { get; private set; }
    public List<MapNode> AllNodes { get; private set; }
    public int MapWidth { get; private set; }
    public int MapHeight { get; private set; }
    public MapNode CurrentNode { get; private set; }

    void Awake()
    {
        // 중복이 아님이 확인되었으므로, 이제 ServiceLocator에 자기 자신을 등록합니다.
        ServiceLocator.Register<MapManager>(this);
        DontDestroyOnLoad(this.gameObject);
    }
    
    /// <summary>
    /// 맵 데이터와 함께 맵의 크기 정보도 받아 초기화합니다.
    /// </summary>
    public void InitializeMap(List<MapNode> mapData, int width, int height)
    {
        AllNodes = mapData;
        MapWidth = width;
        MapHeight = height;
        CurrentNode = AllNodes.FirstOrDefault(n => n.Position.y == 0); // 시작 노드 설정
        IsMapInitialized = true;
        Debug.Log($"[MapManager] 맵 데이터 초기화 완료. (노드 수: {AllNodes.Count}, 너비: {width}, 높이: {height})");
    }

    /// <summary>
    /// 플레이어를 새 노드로 이동시키고, Gameplay 씬으로 전환을 요청합니다.
    /// </summary>
    public void MoveToNode(MapNode node)
    {
        if (AllNodes.Contains(node))
        {
            CurrentNode = node;
            Debug.Log($"[MapManager] 현재 위치를 노드 {node.Position}로 이동했습니다.");
        }
    }

    /// <summary>
    /// [추가된 함수] 씬을 전환하지 않고, 현재 노드 데이터만 업데이트합니다.
    /// </summary>
    public void MoveToNode_OnlyUpdateData(MapNode newNode)
    {
        if (CurrentNode != null && !CurrentNode.NextNodes.Contains(newNode))
        {
            Debug.LogError($"{newNode.Position}은(는) 현재 위치({CurrentNode.Position})에서 이동할 수 없는 노드입니다!");
            return;
        }
        CurrentNode = newNode;
        Debug.Log($"[MapManager] 현재 노드가 {newNode.Position}(으)로 업데이트되었습니다.");
    }

    /// <summary>
    /// 현재 플레이어가 이동할 수 있는 다음 노드들의 리스트를 반환합니다.
    /// </summary>
    public List<MapNode> GetReachableNodes()
    {
        if (CurrentNode == null)
        {
            return AllNodes.Where(node => node.Position.y == 0).ToList();
        }
        return CurrentNode.NextNodes;
    }
}

--- 파일명: MonsterManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/MonsterManager.cs) ---
using System.Collections.Generic;
using UnityEngine;

public class MonsterManager : MonoBehaviour
{
    private readonly List<MonsterController> activeMonsters = new List<MonsterController>();
    public IReadOnlyList<MonsterController> ActiveMonsters => activeMonsters;

    void Awake()
    {
        ServiceLocator.Register<MonsterManager>(this);
        // 이 매니저는 _GameplaySession 프리팹에 넣어두면 DontDestroyOnLoad가 필요 없습니다.
    }

    public void RegisterMonster(MonsterController monster)
    {
        if (!activeMonsters.Contains(monster))
        {
            activeMonsters.Add(monster);
        }
    }

    public void UnregisterMonster(MonsterController monster)
    {
        if (activeMonsters.Contains(monster))
        {
            activeMonsters.Remove(monster);
        }
    }
}

--- 파일명: PoolManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/PoolManager.cs) ---
// 파일명: PoolManager.cs (리팩토링 완료)
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class PoolManager : MonoBehaviour
{
    private Dictionary<GameObject, Queue<GameObject>> poolDictionary = new Dictionary<GameObject, Queue<GameObject>>();
    
    // [추가] 현재 씬에 활성화된 모든 풀링 오브젝트를 추적하기 위한 HashSet
    private readonly HashSet<GameObject> activePooledObjects = new HashSet<GameObject>();

    void Awake()
    {
        Debug.Log($"[ 진단 ] PoolManager.Awake() 호출됨. (Frame: {Time.frameCount})");
        ServiceLocator.Register<PoolManager>(this);
        DontDestroyOnLoad(gameObject);
    }

    public void Preload(GameObject prefab, int count)
    {
        if (prefab == null || count <= 0)
        {
            Debug.LogWarning("[PoolManager] Preload 실패: 프리팹이 null이거나 수량이 0 이하입니다.");
            return;
        }

        Debug.Log($"[ 진단-Preload ] 프리팹 '{prefab.name}' (ID: {prefab.GetInstanceID()}) {count}개 미리 생성 요청됨.");

        if (!poolDictionary.ContainsKey(prefab))
        {
            poolDictionary[prefab] = new Queue<GameObject>();
        }

        for (int i = 0; i < count; i++)
        {
            GameObject obj = Instantiate(prefab, transform);
            obj.SetActive(false);
            if (!obj.TryGetComponent<PooledObjectInfo>(out var pooledInfo))
            {
                pooledInfo = obj.AddComponent<PooledObjectInfo>();
            }
            pooledInfo.Initialize(prefab);
            poolDictionary[prefab].Enqueue(obj);
        }
    }

    

    public GameObject Get(GameObject prefab)
    {
        if (prefab == null)
        {
            Debug.LogError("[PoolManager] Get 실패: 요청한 프리팹이 null입니다.");
            return null;
        }

        if (!poolDictionary.ContainsKey(prefab) || poolDictionary[prefab].Count == 0)
        {
            Debug.LogWarning($"[PoolManager] {prefab.name} 풀이 비어있어 새로 생성합니다. Preload가 정상적으로 작동했는지 확인해보세요.");
            GameObject newObj = Instantiate(prefab);
            if (!newObj.TryGetComponent<PooledObjectInfo>(out var pooledInfo))
            {
                pooledInfo = newObj.AddComponent<PooledObjectInfo>();
            }
            pooledInfo.Initialize(prefab);
            return newObj;
        }

        GameObject obj = poolDictionary[prefab].Dequeue();
        obj.SetActive(true);

        // [추가] 오브젝트를 꺼내갈 때, 활성 목록에 등록합니다.
        activePooledObjects.Add(obj);

        return obj;
    }

    public void Release(GameObject instance)
    {
        if (instance == null) return;
        
        // [추가] 오브젝트를 반납할 때, 활성 목록에서 제거합니다.
        activePooledObjects.Remove(instance);

        PooledObjectInfo pooledInfo = instance.GetComponent<PooledObjectInfo>();
        if (pooledInfo == null || pooledInfo.originalPrefab == null)
        {
            Destroy(instance);
            return;
        }

        GameObject originalPrefab = pooledInfo.originalPrefab;

        if (!poolDictionary.ContainsKey(originalPrefab))
        {
            poolDictionary[originalPrefab] = new Queue<GameObject>();
        }

        instance.SetActive(false);
        instance.transform.SetParent(transform);
        poolDictionary[originalPrefab].Enqueue(instance);
    }

    // [추가] 활성화된 모든 풀링 오브젝트를 정리하는 새로운 함수
    public void ClearAllActiveObjects()
    {
        Debug.Log($"[PoolManager] 활성화된 모든 풀 오브젝트 ({activePooledObjects.Count}개)를 정리합니다.");
        
        // HashSet을 직접 순회하면서 요소를 제거하면 오류가 발생하므로, 리스트로 복사한 뒤 순회합니다.
        foreach (var obj in activePooledObjects.ToList())
        {
            Release(obj);
        }
        
        // 모든 객체가 Release를 통해 개별적으로 제거되지만, 만약을 위해 마지막에 Clear를 호출합니다.
        activePooledObjects.Clear();
    }

    /// <summary>
    /// 모든 풀링된 오브젝트(활성 및 비활성)를 즉시 파괴하고 풀을 초기화합니다.
    /// 씬 전환 등 풀의 모든 오브젝트를 강제로 정리해야 할 때 사용합니다.
    /// </summary>
    public void DestroyAllPooledObjects()
    {
        Debug.Log($"[PoolManager] 모든 풀링된 오브젝트를 파괴합니다. (활성: {activePooledObjects.Count}개, 비활성 풀: {poolDictionary.Sum(kv => kv.Value.Count)}개)");

        // 활성 오브젝트 먼저 파괴
        foreach (var obj in activePooledObjects.ToList()) // ToList()로 복사하여 순회 중 수정 가능하게 함
        {
            Destroy(obj);
        }
        activePooledObjects.Clear();

        // 비활성 풀 오브젝트 파괴
        foreach (var kvp in poolDictionary)
        {
            foreach (var obj in kvp.Value)
            {
                Destroy(obj);
            }
        }
        poolDictionary.Clear();
        Debug.Log("[PoolManager] 모든 풀링된 오브젝트 파괴 완료.");
    }
}

--- 파일명: PooledObjectInfo.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/PooledObjectInfo.cs) ---
using UnityEngine;

/// <summary>
/// 풀링된 오브젝트의 원본 프리팹 정보를 저장하는 컴포넌트입니다.
/// PoolManager가 오브젝트를 풀로 반환할 때 어떤 풀에 속하는지 식별하는 데 사용됩니다.
/// </summary>
public class PooledObjectInfo : MonoBehaviour
{
    public GameObject originalPrefab; // 이 오브젝트의 원본 프리팹

    /// <summary>
    /// 오브젝트 정보를 초기화합니다.
    /// </summary>
    /// <param name="prefab">이 오브젝트의 원본 프리팹</param>
    public void Initialize(GameObject prefab)
    {
        originalPrefab = prefab;
    }
}


--- 파일명: PrefabKeys.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/PrefabKeys.cs) ---
// 파일명: PrefabKeys.cs
public static class PrefabKeys
{
    public const string Managers = "_Managers";
    public const string GameplaySession = "_GameplaySession";
    public const string DamageTextCanvas = "DamageTextCanvas";
}

--- 파일명: ProgressionManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/ProgressionManager.cs) ---
// 파일명: ProgressionManager.cs (리팩토링 완료)
using UnityEngine;
using System.Collections.Generic;
using System.IO;
using System.Linq;

/// <summary>
/// 메타 프로그레션(도전 과제, 영구 재화 등) 데이터를 관리하고,
/// 관련 시스템에 데이터를 제공하는 중앙 관리자입니다.
/// </summary>
public class ProgressionManager : MonoBehaviour
{
    public int KnowledgeShards { get; private set; }
    public int GenePoints { get; private set; }
    private Dictionary<string, bool> achievementsUnlocked = new Dictionary<string, bool>();
    private Dictionary<string, bool> bossFirstKills = new Dictionary<string, bool>();
    private Dictionary<string, CharacterPermanentStats> permanentStatsDict = new Dictionary<string, CharacterPermanentStats>();

    private string savePath;

    void Awake()
    {
        ServiceLocator.Register<ProgressionManager>(this);
        DontDestroyOnLoad(gameObject);

        savePath = Path.Combine(Application.persistentDataPath, "progression.json");
        LoadData();
    }

    public void AddCurrency(MetaCurrencyType type, int amount)
    {
        if (amount < 0)
        {
            Debug.LogError("재화는 음수 값을 추가할 수 없습니다.");
            return;
        }

        switch (type)
        {
            case MetaCurrencyType.KnowledgeShards:
                KnowledgeShards += amount;
                Debug.Log($"지식의 파편 {amount} 획득. 현재: {KnowledgeShards}");
                break;
            case MetaCurrencyType.GenePoints:
                GenePoints += amount;
                Debug.Log($"유전자 증폭제 포인트 {amount} 획득. 현재: {GenePoints}");
                break;
        }
        SaveData();
    }

    public bool SpendCurrency(MetaCurrencyType type, int amount)
    {
        if (amount < 0)
        {
            Debug.LogError("재화는 음수 값을 사용할 수 없습니다.");
            return false;
        }

        bool success = false;
        switch (type)
        {
            case MetaCurrencyType.KnowledgeShards:
                if (KnowledgeShards >= amount)
                {
                    KnowledgeShards -= amount;
                    Debug.Log($"지식의 파편 {amount} 사용. 현재: {KnowledgeShards}");
                    success = true;
                }
                break;
            case MetaCurrencyType.GenePoints:
                if (GenePoints >= amount)
                {
                    GenePoints -= amount;
                    Debug.Log($"유전자 증폭제 포인트 {amount} 사용. 현재: {GenePoints}");
                    success = true;
                }
                break;
        }

        if (success)
        {
            SaveData();
            return true;
        }
        else
        {
            Debug.LogWarning($"{type} 재화가 부족하여 {amount}를 사용할 수 없습니다.");
            return false;
        }
    }

    public void TrackAchievement(string achievementID)
    {
        if (!achievementsUnlocked.ContainsKey(achievementID) || achievementsUnlocked[achievementID] == false)
        {
            achievementsUnlocked[achievementID] = true;
            Debug.Log($"도전 과제 달성: {achievementID}");
            SaveData();
        }
    }

    public void RegisterBossFirstKill(string bossID)
    {
        if (!bossFirstKills.ContainsKey(bossID) || bossFirstKills[bossID] == false)
        {
            bossFirstKills[bossID] = true;
            Debug.Log($"보스 최초 처치: {bossID}");
            SaveData();
        }
    }

    public CharacterPermanentStats GetPermanentStatsFor(string characterId)
    {
        if (!permanentStatsDict.TryGetValue(characterId, out var stats))
        {
            stats = new CharacterPermanentStats(characterId);
            permanentStatsDict[characterId] = stats;
            Debug.Log($"{characterId}에 대한 새로운 영구 스탯 데이터를 생성했습니다.");
        }
        return stats;
    }

    public void SaveData()
    {
        ProgressionData data = new ProgressionData
        {
            knowledgeShards = this.KnowledgeShards,
            genePoints = this.GenePoints,
            achievementIDs = achievementsUnlocked.Keys.ToList(),
            achievementStates = achievementsUnlocked.Values.ToList(),
            bossKillIDs = bossFirstKills.Keys.ToList(),
            bossKillStates = bossFirstKills.Values.ToList(),
            characterPermanentStats = permanentStatsDict.Values.ToList()
        };

        string json = JsonUtility.ToJson(data, true);
        File.WriteAllText(savePath, json);
        Debug.Log($"데이터 저장 완료: {savePath}");
    }

    public void LoadData()
    {
        if (File.Exists(savePath))
        {
            string json = File.ReadAllText(savePath);
            ProgressionData data = JsonUtility.FromJson<ProgressionData>(json);

            permanentStatsDict = new Dictionary<string, CharacterPermanentStats>();
            foreach (var stats in data.characterPermanentStats)
            {
                stats.statData = new StatDictionaryData
                {
                    statTypes = stats.statData.statTypes,
                    unlockedStatuses = stats.statData.unlockedStatuses,
                    investedRatios = stats.statData.investedRatios
                };
                permanentStatsDict[stats.characterId] = stats;
            }

            Debug.Log($"데이터 로드 완료: {savePath}");
        }
        else
        {
            Debug.Log("세이브 파일이 없어 새 게임을 시작합니다.");
            KnowledgeShards = 0;
            GenePoints = 0;
            achievementsUnlocked = new Dictionary<string, bool>();
            bossFirstKills = new Dictionary<string, bool>();
            permanentStatsDict = new Dictionary<string, CharacterPermanentStats>();
        }
    }

    private void OnApplicationQuit()
    {
        SaveData();
    }

    public bool IsCodexItemUnlocked(string itemID)
    {
        if (achievementsUnlocked.ContainsKey(itemID) && achievementsUnlocked[itemID])
        {
            return true;
        }
        if (bossFirstKills.ContainsKey(itemID) && bossFirstKills[itemID])
        {
            return true;
        }
        return false;
    }
}

public enum MetaCurrencyType
{
    KnowledgeShards,
    GenePoints
}

--- 파일명: ResourcePaths.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/ResourcePaths.cs) ---
// 파일명: ResourcePaths.cs
public static class ResourcePaths
{
    public const string CardData = "CardData";
    public const string ArtifactData = "ArtifactData";
    public const string CharacterData = "CharacterData";
    public const string MonsterData = "MonsterData";
}

--- 파일명: SceneAudioLoader.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/SceneAudioLoader.cs) ---
//  : Assets/1.Scripts/Core/SceneAudioLoader.cs

using UnityEngine;

public class SceneAudioLoader : MonoBehaviour
{
    [Header("  ÷")]
    [SerializeField]
    private AudioCollection sceneAudioCollection;

    [Header(" BGM ̸ ( )")]
    [SerializeField]
    private string startingBgmName;

    void Start()
    {
        // [] ServiceLocator  AudioManager ɴϴ.
        var audioManager = ServiceLocator.Get<AudioManager>();
        if (audioManager == null)
        {
            Debug.LogError("SceneAudioLoader: AudioManager ã  ϴ!");
            return;
        }

        if (sceneAudioCollection != null)
        {
            // []  audioManager  մϴ.
            audioManager.LoadCollection(sceneAudioCollection);
            if (!string.IsNullOrEmpty(startingBgmName))
            {
                audioManager.PlayBgm(startingBgmName);
            }
        }
        else
        {
            Debug.LogWarning("SceneAudioLoader: AudioCollection Ҵ ʾҽϴ!", this.gameObject);
        }
    }
}

--- 파일명: SceneNames.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/SceneNames.cs) ---
/// <summary>
/// 씬 이름들을 상수로 관리하는 클래스입니다.
/// </summary>
public static class SceneNames
{
    public const string MainMenu = "MainMenu";
    public const string CharacterSelect = "CharacterSelect";
    public const string PointAllocation = "PointAllocation";
    public const string GamePlay = "GamePlay";
    public const string CardReward = "CardReward";
    public const string Codex = "Codex";
    public const string Shop = "Shop";
    public const string Rest = "Rest";
    public const string Event = "Event";
    public const string Pause = "Pause"; // Pause는 씬이 아닐 수 있지만, UI 관리 등에서 사용할 수 있어 포함
}

--- 파일명: SceneTransitionManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/SceneTransitionManager.cs) ---
﻿// 파일명: SceneTransitionManager.cs (리팩토링 완료)
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;
using System.Collections;

public class SceneTransitionManager : MonoBehaviour
{
    private Image fadeOverlay;

    private void Awake()
    {
        ServiceLocator.Register<SceneTransitionManager>(this);
        DontDestroyOnLoad(gameObject);
        InitializeFadeOverlay();
    }

    private void InitializeFadeOverlay()
    {
        GameObject canvasGo = new GameObject("SceneTransitionCanvas");
        canvasGo.transform.SetParent(this.transform);
        Canvas canvas = canvasGo.AddComponent<Canvas>();
        canvas.renderMode = RenderMode.ScreenSpaceOverlay;
        canvas.sortingOrder = 999;

        canvasGo.AddComponent<CanvasScaler>().uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;

        GameObject imageGo = new GameObject("FadeOverlayImage");
        imageGo.transform.SetParent(canvasGo.transform);
        fadeOverlay = imageGo.AddComponent<Image>();

        RectTransform rt = fadeOverlay.rectTransform;
        rt.anchorMin = Vector2.zero;
        rt.anchorMax = Vector2.one;
        rt.offsetMin = Vector2.zero;
        rt.offsetMax = Vector2.zero;

        fadeOverlay.color = new Color(0, 0, 0, 0);
        fadeOverlay.raycastTarget = false;
        fadeOverlay.gameObject.SetActive(false);
    }

    public void LoadScene(string sceneName)
    {
        StopAllCoroutines();
        StartCoroutine(FadeOutAndLoad(sceneName));
    }

    private IEnumerator FadeIn()
    {
        fadeOverlay.gameObject.SetActive(true);
        float t = 1f;
        while (t > 0f)
        {
            t -= Time.unscaledDeltaTime;
            fadeOverlay.color = new Color(0, 0, 0, t);
            yield return null;
        }
        fadeOverlay.gameObject.SetActive(false);
    }

    private IEnumerator FadeOutAndLoad(string sceneName)
    {
        SceneManager.sceneLoaded += OnSceneLoaded;

        fadeOverlay.gameObject.SetActive(true);
        float t = 0f;
        while (t < 1f)
        {
            t += Time.unscaledDeltaTime;
            fadeOverlay.color = new Color(0, 0, 0, t);
            yield return null;
        }

        SceneManager.LoadScene(sceneName);
    }

    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        SceneManager.sceneLoaded -= OnSceneLoaded;
        StartCoroutine(FadeIn());
    }
}

--- 파일명: ServiceLocator.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/ServiceLocator.cs) ---
// 파일명: ServiceLocator.cs (Unregister 메소드 추가)
using System;
using System.Collections.Generic;
using UnityEngine;

public static class ServiceLocator
{
    private static readonly Dictionary<Type, object> services = new Dictionary<Type, object>();

    public static void Register<T>(T service)
    {
        Type type = typeof(T);
        if (services.ContainsKey(type))
        {
            Debug.LogWarning($"[ServiceLocator] '{type.Name}' 서비스가 이미 등록되어 있습니다. 덮어씁니다.");
            services[type] = service;
        }
        else
        {
            services.Add(type, service);
            Debug.Log($"[ServiceLocator] '{type.Name}' 서비스가 새로 등록되었습니다.");
        }
    }

    public static T Get<T>()
    {
        Type type = typeof(T);
        if (!services.TryGetValue(type, out object service))
        {
            Debug.LogError($"[ServiceLocator] '{type.Name}' 타입의 서비스를 찾을 수 없습니다!");
            return default;
        }
        return (T)service;
    }

    /// <summary>
    /// [추가된 메소드] 특정 타입의 서비스를 등록 해제합니다.
    /// PlayerController처럼 씬이 변경될 때 파괴되는 객체를 위해 필요합니다.
    /// </summary>
    public static void Unregister<T>(T service)
    {
        Type type = typeof(T);
        if (services.ContainsKey(type) && services[type].Equals(service))
        {
            services.Remove(type);
            Debug.Log($"[ServiceLocator] '{type.Name}' 서비스가 등록 해제되었습니다.");
        }
    }

    public static void Clear()
    {
        services.Clear();
    }
}

--- 파일명: StatSources.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/StatSources.cs) ---
// 파일명: StatSources.cs
public static class StatSources
{
    public const string Permanent = "Permanent";
    public const string Allocated = "Allocated";
}

--- 파일명: Tags.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/Tags.cs) ---
// 파일명: Tags.cs
public static class Tags
{
    public const string Player = "Player";
    public const string Monster = "Monster";
}

--- 파일명: TargetingSystem.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/TargetingSystem.cs) ---
// --- ϸ: TargetingSystem.cs ---

using UnityEngine;
using System.Linq;
using System.Collections.Generic; // Added for IReadOnlyList

public static class TargetingSystem
{
    public static Transform FindTarget(TargetingType type, Transform origin)
    {
        var monsterManager = ServiceLocator.Get<MonsterManager>();
        if (monsterManager == null) return null;

        var activeMonsters = monsterManager.ActiveMonsters;
        if (activeMonsters.Count == 0) return null;

        switch (type)
        {
            case TargetingType.Nearest:
                return activeMonsters.OrderBy(m => Vector3.Distance(origin.position, m.transform.position)).FirstOrDefault()?.transform;

            case TargetingType.HighestHealth:
                // [] Yǥ    currentHealth  ü    ã 
                return activeMonsters.OrderByDescending(m => m.currentHealth).FirstOrDefault()?.transform;

            case TargetingType.LowestHealth:
                // [] Yǥ    currentHealth  ü    ã 
                return activeMonsters.OrderBy(m => m.currentHealth).FirstOrDefault()?.transform;

            case TargetingType.Random:
                return activeMonsters[Random.Range(0, activeMonsters.Count)].transform; // Changed .Length to .Count

            case TargetingType.Forward:
            default:
                return null;
        }
    }
}

--- 파일명: UICursorManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Core/UICursorManager.cs) ---
// ϸ: UICursorManager.cs (丵 Ϸ)
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class UICursorManager : MonoBehaviour
{
    [SerializeField]
    private Image globalCursorImage;

    private Sprite defaultCursorSprite;

    void Awake()
    {
        ServiceLocator.Register<UICursorManager>(this);
        if (globalCursorImage != null)
        {
            defaultCursorSprite = globalCursorImage.sprite;
        }
    }

    void Update()
    {
        if (globalCursorImage == null || EventSystem.current == null) return;

        GameObject selectedObject = EventSystem.current.currentSelectedGameObject;

        if (selectedObject != null)
        {
            globalCursorImage.gameObject.SetActive(true);
            globalCursorImage.rectTransform.position = selectedObject.transform.position;
        }
        else
        {
            globalCursorImage.gameObject.SetActive(false);
        }
    }

    public void ChangeCursorSprite(Sprite newSprite)
    {
        if (globalCursorImage == null) return;
        globalCursorImage.sprite = newSprite;
    }

    public void ResetCursorToDefault()
    {
        if (globalCursorImage == null || defaultCursorSprite == null) return;
        globalCursorImage.sprite = defaultCursorSprite;
    }
}

--- 파일명: ArtifactDataSO.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Data/ArtifactDataSO.cs) ---
using UnityEngine;

[CreateAssetMenu(fileName = "ArtifactData_", menuName = "GameData/ArtifactData")]
public class ArtifactDataSO : ScriptableObject
{
    [Header("기본 정보")]
    public string artifactID;
    public string artifactName;
    [TextArea(3, 5)]
    public string description;

    [Header("유물 속성")]
    public CardRarity rarity;

    [Header("효과 파라미터")]
    public float attackBoostRatio;
    public float healthBoostRatio;
    public float moveSpeedBoostRatio;
    public float critChanceBoostRatio;
    public float critDamageBoostRatio;
    public float lifestealBoostRatio;

    [Header("슬롯 및 확률 보너스")]
    public int ownedCardSlotBonus;
    public float specificCardTriggerChanceBonus;

    [Header("시각 정보")]
    public Sprite icon;
}

--- 파일명: AudioCollection.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Data/AudioCollection.cs) ---
using UnityEngine;

/// <summary>
/// BGM, SFX 등 오디오 클립들을 그룹으로 묶어 관리하는 ScriptableObject.
/// 각 씬이나 상황에 맞는 오디오 세트를 구성하는 데 사용됩니다.
/// </summary>
[CreateAssetMenu(fileName = "NewAudioCollection", menuName = "9th/Audio/Audio Collection")]
public class AudioCollection : ScriptableObject
{
    [Header("배경음악 (BGM)")]
    public AudioClip[] bgmClips;

    [Header("효과음 (SFX)")]
    public AudioClip[] sfxClips;

    /// <summary>
    /// 이름으로 BGM 오디오 클립을 찾습니다.
    /// </summary>
    public AudioClip GetBgmClip(string clipName)
    {
        foreach (var clip in bgmClips)
        {
            if (clip.name == clipName)
            {
                return clip;
            }
        }
        Debug.LogWarning($"'{name}' 컬렉션에 '{clipName}' BGM이 없습니다.");
        return null;
    }

    /// <summary>
    /// 이름으로 SFX 오디오 클립을 찾습니다.
    /// </summary>
    public AudioClip GetSfxClip(string clipName)
    {
        foreach (var clip in sfxClips)
        {
            if (clip.name == clipName)
            {
                return clip;
            }
        }
        Debug.LogWarning($"'{name}' 컬렉션에 '{clipName}' SFX가 없습니다.");
        return null;
    }
}


--- 파일명: BaseStats.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Data/BaseStats.cs) ---
using UnityEngine;

[System.Serializable]
public class BaseStats
{
    public float baseDamage;
    public float baseAttackSpeed;
    public float baseMoveSpeed;
    public float baseHealth;
    public float baseCritRate;
    public float baseCritDamage;
}

--- 파일명: CampaignDataSO.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Data/CampaignDataSO.cs) ---
// --- ϸ: CampaignDataSO.cs ---
// : Assets/1.Scripts/Data/CampaignDataSO.cs
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "CampaignData_", menuName = "GameData/CampaignData")]
public class CampaignDataSO : ScriptableObject
{
    [Tooltip(" ķ ϴ  Դϴ.  ˴ϴ.")]
    public List<RoundDataSO> rounds;
}

--- 파일명: CardDataSO.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Data/CardDataSO.cs) ---
using UnityEngine;

[CreateAssetMenu(fileName = "CardData_", menuName = "GameData/CardData")]
public class CardDataSO : ScriptableObject
{
    [Header("기본 정보")]
    public string cardID;      // 카드의 고유 ID (예: "warrior_basic_001")
    public string cardName;    // UI에 표시될 카드 이름
    public Sprite cardIcon;

    [Header("카드 속성")]
    public CardType type;      // 카드의 타입 (물리 또는 마법)

    public CardRarity rarity;  // 카드의 희귀도 (일반, 희귀, 영웅, 전설)


    [Header("능력치 배율")]
    [Tooltip("이 카드의 고유 기본 대미지입니다.")] // <-- 추가 설명
    public float baseDamage; // 고유 기본 대미지
    public float damageMultiplier;            // 공격력에 적용될 배율
    public float attackSpeedMultiplier;       // 공격 속도에 적용될 배율
    public float moveSpeedMultiplier;         // 이동 속도에 적용될 배율
    public float healthMultiplier;            // 체력에 적용될 배율
    public float critRateMultiplier;          // 치명타 확률에 적용될 배율 (선택 사항)
    public float critDamageMultiplier;        // 치명타 피해에 적용될 배율
    public float lifestealPercentage;         // 흡혈 효과의 회복량 비율 (0.0 ~ 1.0)
    public string effectDescription;          // 카드의 효과에 대한 설명 텍스트

    [Header("발동 조건")]
    public CardEffectType effectType; // 이 카드가 발동하는 특수 효과의 종류
    public TriggerType triggerType;  // 카드가 발동되는 조건 (IV. 카드 시스템의 TriggerType 열거형 참조)
    public TargetingType targetingType;
    [Tooltip("분열탄 개수, 주기, 확률 등 다용도로 사용될 값")]
    public float triggerValue; // 분열탄 개수, 주기, 확률 등 다용도로 사용될 값

    [Header("연계 효과")]
    [Tooltip("이 카드의 효과(총알 등)가 적에게 명중했을 때 발동할 2차 효과 카드입니다.")]
    public CardDataSO secondaryEffect; // [추가]


    [Header("발사체 설정")]
    public GameObject bulletPrefab;
    public float bulletSpeed = 10f;
    // ▼▼▼ [1] 이 줄을 추가하세요. ▼▼▼
    [Tooltip("이 카드의 총알을 몇 개 미리 생성할지 정합니다.")]
    public int bulletPreloadCount = 100;

    [Header("특수 효과 설정")]
    public GameObject effectPrefab;
    // ▼▼▼ [2] 이 줄을 추가하세요. ▼▼▼
    [Tooltip("이 카드의 특수 효과를 몇 개 미리 생성할지 정합니다.")]
    public int effectPreloadCount = 20;
    [Tooltip("독, 화상 등 적에게 적용할 상태 효과")]
    public StatusEffectDataSO statusEffectToApply;



    // 변경사항 1: [추가] 파동/장판 효과 설정 변수들
    [Header("파동/장판 효과 설정")]
    [Tooltip("파동/장판의 총 지속 시간 (초).")]
    public float effectDuration = 3f; // DamagingZone의 duration에 해당
    
    [Tooltip("파동/장판의 확장 속도 (초당).")]
     public float effectExpansionSpeed = 1f; // DamagingZone의 expansionSpeed에 해당
    
    [Tooltip("파동/장판이 확장하는 시간 (초). 파동으로 쓸 경우 Duration보다 조금 더 크게 입력.")]
    public float effectExpansionDuration = 3.1f; // DamagingZone의 expansionDuration에 해당
   
    [Tooltip("장판 모드일 때 틱 데미지 간격 (초). 파동 모드일 때는 100 이상으로 설정.")]
    public float effectTickInterval = 100.0f; // DamagingZone의 tickInterval에 해당
   
    [Tooltip("장판 모드일 때 틱 데미지. 파동 모드일 때는 0으로 설정.")]
    public float effectDamagePerTick = 0f; // DamagingZone의 damagePerTick에 해당
   
    [Tooltip("이 효과가 단일 피해 파동 모드인지 (true), 지속 피해 장판 모드인지 (false).")]
    public bool isEffectSingleHitWaveMode = true; // DamagingZone의 isSingleHitWaveMode에 해당


    [Header("기획 및 가중치")]
    [Tooltip("룰렛에서 선택될 확률 가중치입니다. 높을수록 잘 뽑힙니다.")]
    public float selectionWeight = 1f;

    [Tooltip("카드 보상으로 등장할 확률 가중치입니다.")]
    public float rewardAppearanceWeight;

    // 카드를 해금하기 위한 조건입니다.
    // 구체적인 해금 시스템이 결정되면 해당 로직이 구현될 예정입니다.
    public string unlockCondition;
}

--- 파일명: CharacterDataSO.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Data/CharacterDataSO.cs) ---
// --- 파일명: CharacterDataSO.cs ---
using UnityEngine;
using System.Collections.Generic; // List를 사용하기 위해 추가

[CreateAssetMenu(fileName = "CharacterData_", menuName = "GameData/CharacterData")]
public class CharacterDataSO : ScriptableObject
{
    [Header("기본 정보")]
    public string characterId;
    public string characterName;
    public Sprite illustration;
    [TextArea(3, 5)]
    public string description;

    [Header("기본 능력치")]
    public BaseStats baseStats;

    [Header("시작 아이템")]
    public CardDataSO startingCard;
    public List<ArtifactDataSO> startingArtifacts; // [추가] 시작 유물 목록

    [Header("초기 포인트")]
    public int initialAllocationPoints;
}

--- 파일명: CharacterPermanentStats.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Data/CharacterPermanentStats.cs) ---
// --- 파일명: CharacterPermanentStats.cs ---

using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[System.Serializable]
public class CharacterPermanentStats
{
    public string characterId;

    [Tooltip("테스트 시 해금할 스탯을 여기에 추가하세요. 실제 게임에서는 룰렛을 통해 해금됩니다.")]
    public List<StatType> defaultUnlockedStats = new List<StatType> { StatType.Health, StatType.Attack, StatType.AttackSpeed, StatType.MoveSpeed, StatType.CritMultiplier, StatType.CritRate };

    // [수정] 변수를 선언할 때 바로 new로 초기화해서 Null 참조 예외를 원천적으로 방지
    public Dictionary<StatType, bool> unlockedStatus = new Dictionary<StatType, bool>();
    public Dictionary<StatType, float> investedRatios = new Dictionary<StatType, float>();

    // JSON 저장을 위한 헬퍼 프로퍼티
    public StatDictionaryData statData
    {
        get
        {
            StatDictionaryData data = new StatDictionaryData();
            // unlockedStatus가 null이 아니므로 이제 여기서 에러가 발생하지 않아.
            foreach (var kvp in unlockedStatus)
            {
                data.statTypes.Add(kvp.Key);
                data.unlockedStatuses.Add(kvp.Value);
            }
            foreach (var kvp in investedRatios)
            {
                data.investedRatios.Add(kvp.Value);
            }
            return data;
        }
        set
        {
            unlockedStatus.Clear();
            investedRatios.Clear();
            if (value != null)
            {
                for (int i = 0; i < value.statTypes.Count; i++)
                {
                    unlockedStatus[value.statTypes[i]] = value.unlockedStatuses[i];
                    investedRatios[value.statTypes[i]] = value.investedRatios[i];
                }
            }
        }
    }

    // [수정] JsonUtility가 이 생성자를 사용하지 않으므로, 딕셔너리 초기화 코드는 선언부로 옮기고 여기서는 비워둠.
    public CharacterPermanentStats()
    {
        // 비어 있어도 괜찮아.
    }

    public CharacterPermanentStats(string charId)
    {
        characterId = charId;

        // 모든 스탯을 일단 '잠금' 상태로 초기화
        foreach (StatType type in System.Enum.GetValues(typeof(StatType)))
        {
            unlockedStatus[type] = false;
            investedRatios[type] = 0f;
        }

        // defaultUnlockedStats 리스트에 있는 스탯들만 '해금' 상태로 변경
        foreach (StatType type in defaultUnlockedStats)
        {
            unlockedStatus[type] = true;
        }
    }

    // ... 이하 나머지 코드는 동일 ...

    public List<StatType> GetLockedStats()
    {
        return unlockedStatus.Where(kvp => !kvp.Value).Select(kvp => kvp.Key).ToList();
    }

    public List<StatType> GetUnlockedStats()
    {
        return unlockedStatus.Where(kvp => kvp.Value).Select(kvp => kvp.Key).ToList();
    }

    public bool AllStatsUnlocked()
    {
        return unlockedStatus.Values.All(unlocked => unlocked);
    }

    public void UnlockStat(StatType stat)
    {
        if (unlockedStatus.ContainsKey(stat))
        {
            unlockedStatus[stat] = true;
        }
    }

    public void DistributePoints(int points)
    {
        List<StatType> unlocked = GetUnlockedStats();
        if (unlocked.Count == 0) return;

        for (int i = 0; i < points; i++)
        {
            StatType targetStat = unlocked[Random.Range(0, unlocked.Count)];
            float weight = GetWeightForStat(targetStat);
            investedRatios[targetStat] += weight;
        }
    }

    private float GetWeightForStat(StatType stat)
    {
        switch (stat)
        {
            case StatType.Health: return 0.02f;
            default: return 0.01f;
        }
    }
}

--- 파일명: JsonDataClasses.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Data/JsonDataClasses.cs) ---
using System;
using System.Collections.Generic;
using UnityEngine; // For Sprite, though not directly used in JSON deserialization, useful for context

// 전체 게임 데이터를 담을 JSON 구조의 루트 클래스
[Serializable]
public class GameDataJson
{
    public List<CardDataJson> cards;
    public List<ArtifactDataJson> artifacts;
}

// CardDataSO와 필드를 일치시키는 JSON용 클래스
[Serializable]
public class CardDataJson
{
    public string cardID;
    public string cardName;
    public string iconPath; // Sprite를 대체할 리소스 경로
    public string type; // CardType enum을 string으로 매핑
    public string rarity; // CardRarity enum을 string으로 매핑

    public float damageMultiplier;
    public float attackSpeedMultiplier;
    public float moveSpeedMultiplier;
    public float healthMultiplier;
    public float critRateMultiplier;
    public float critDamageMultiplier;
    public float lifestealPercentage;
    public string effectDescription;

    public string effectType; // CardEffectType enum을 string으로 매핑
    public string triggerType; // TriggerType enum을 string으로 매핑

    public float rewardAppearanceWeight;
    public string unlockCondition;
}

// ArtifactDataSO와 필드를 일치시키는 JSON용 클래스
[Serializable]
public class ArtifactDataJson
{
    public string artifactID;
    public string artifactName;
    public string iconPath; // Sprite를 대체할 리소스 경로
    public string rarity; // CardRarity enum을 string으로 매핑

    public float attackBoostRatio;
    public float healthBoostRatio;
    public float moveSpeedBoostRatio;
    public float critChanceBoostRatio;
    public float critDamageBoostRatio;
    public float lifestealBoostRatio;
    
    // ArtifactDataSO에 추가된 필드들
    public int ownedCardSlotBonus;
    public float specificCardTriggerChanceBonus;
}

// ProgressionManager의 영구 데이터를 저장하기 위한 클래스
[Serializable]
public class ProgressionData
{
    public int knowledgeShards;
    public int genePoints;

    // JsonUtility는 Dictionary를 직접 직렬화할 수 없으므로 List 두 개로 변환하여 저장합니다.
    public List<string> achievementIDs = new List<string>();
    public List<bool> achievementStates = new List<bool>();

    public List<string> bossKillIDs = new List<string>();
    public List<bool> bossKillStates = new List<bool>();

    // 캐릭터별 영구 스탯 데이터
    public List<CharacterPermanentStats> characterPermanentStats = new List<CharacterPermanentStats>();
}

// CharacterPermanentStats 클래스의 Dictionary를 직렬화하기 위한 헬퍼 클래스
[Serializable]
public class StatDictionaryData
{
    public List<StatType> statTypes = new List<StatType>();
    public List<bool> unlockedStatuses = new List<bool>();
    public List<float> investedRatios = new List<float>();
}




--- 파일명: MapNode.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Data/MapNode.cs) ---
using System.Collections.Generic;
using UnityEngine;

public enum NodeType { Monster, Elite, Shop, Rest, Boss, Event }

public class MapNode
{
    public NodeType NodeType;
    public Vector2Int Position; //  ڿ ġ (x, y)
    public List<MapNode> NextNodes = new List<MapNode>(); //  忡   ִ  
}

--- 파일명: MonsterDataSo.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Data/MonsterDataSo.cs) ---
// ϸ: MonsterDataSO.cs
// : Assets/1.Scripts/Data/MonsterDataSO.cs
using UnityEngine;

/// <summary>
///     ͸ ϴ ScriptableObjectԴϴ.
/// ü, ӵ, ݷ,     Ӽ   ϳ   ֽϴ.
/// </summary>
[CreateAssetMenu(fileName = "MonsterData_", menuName = "GameData/MonsterData")]
public class MonsterDataSO : ScriptableObject
{
    [Header("⺻ ")]
    [Tooltip("͸ ã   IDԴϴ. (: slime_normal, goblin_archer)")]
    public string monsterID;

    [Tooltip("  ǥõ ̸Դϴ.")]
    public string monsterName;

    [Header("ɷġ")]
    public float maxHealth = 100f;
    public float moveSpeed = 3f;
    public float contactDamage = 10f;

    [Header("")]
    [Tooltip(" Ͱ    ϼ.")]
    public GameObject prefab; // [] string ٽ GameObject 

    // [Ȯ ] ȹ ޵ پ  ൿ   
    // public enum MonsterBehaviorType { Chase, Flee, Patrol, ExplodeOnDeath }
    // public MonsterBehaviorType behaviorType;
}

--- 파일명: PrefabDB.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Data/PrefabDB.cs) ---
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "PrefabDB", menuName = "GameData/PrefabDB")]
public class PrefabDB : ScriptableObject
{
    [Header("몬스터 프리팹")]
    public List<GameObject> monsterPrefabs;

    [Header("총알 프리팹")]
    public List<GameObject> bulletPrefabs;

    [Header("시각 효과 (VFX) 프리팹")]
    public List<GameObject> vfxPrefabs;
}


--- 파일명: RoundDataSO.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Data/RoundDataSO.cs) ---
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "RoundData_", menuName = "GameData/RoundData")]
public class RoundDataSO : ScriptableObject
{
    public float roundDuration = 180f;
    public int killGoal = 100;
    public List<Wave> waves;

}

--- 파일명: StatModifier.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Data/StatModifier.cs) ---
/// <summary>
/// 개별 스탯 보너스에 대한 정보를 담는 클래스입니다.
/// </summary>
public class StatModifier
{
    public readonly float Value; // 보너스 수치 (예: 0.1f는 10%)
    public readonly object Source; // 이 보너스를 제공한 객체 (CardDataSO, ArtifactDataSO 등)

    public StatModifier(float value, object source)
    {
        Value = value;
        Source = source;
    }
}

--- 파일명: StatusEffectDataSO.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Data/StatusEffectDataSO.cs) ---
using UnityEngine;

[CreateAssetMenu(fileName = "StatusEffectData_", menuName = "GameData/StatusEffectData")]
public class StatusEffectDataSO : ScriptableObject
{
    [Header("기본 정보")]
    public string effectId;
    public string effectName;
    public Sprite icon;

    [Header("효과 속성")]
    public float duration;
    public bool isBuff;

    [Header("능력치 변경 효과 (백분율, %)")]
    public float damageRatioBonus;
    public float attackSpeedRatioBonus;
    public float moveSpeedRatioBonus;
    public float healthRatioBonus;
    public float critRateRatioBonus;
    public float critDamageRatioBonus;

    [Header("지속 피해/회복 효과")]
    public float damageOverTime;
    public float healOverTime;

    /// <summary>
    /// [리팩토링] 대상 캐릭터에게 이 상태 효과의 능력치 보너스를 적용합니다.
    /// </summary>
    public void ApplyEffect(CharacterStats targetStats)
    {
        if (targetStats == null) return;

        // 각 보너스 값이 0이 아닐 때만 Modifier를 추가합니다.
        if (damageRatioBonus != 0) targetStats.AddModifier(StatType.Attack, new StatModifier(damageRatioBonus, this));
        if (attackSpeedRatioBonus != 0) targetStats.AddModifier(StatType.AttackSpeed, new StatModifier(attackSpeedRatioBonus, this));
        if (moveSpeedRatioBonus != 0) targetStats.AddModifier(StatType.MoveSpeed, new StatModifier(moveSpeedRatioBonus, this));
        if (healthRatioBonus != 0) targetStats.AddModifier(StatType.Health, new StatModifier(healthRatioBonus, this));
        if (critRateRatioBonus != 0) targetStats.AddModifier(StatType.CritRate, new StatModifier(critRateRatioBonus, this));
        if (critDamageRatioBonus != 0) targetStats.AddModifier(StatType.CritMultiplier, new StatModifier(critDamageRatioBonus, this));
    }

    /// <summary>
    /// [리팩토링] 대상 캐릭터에게서 이 상태 효과의 능력치 보너스를 제거합니다.
    /// </summary>
    public void RemoveEffect(CharacterStats targetStats)
    {
        if (targetStats == null) return;

        targetStats.RemoveModifiersFromSource(this);
    }
}

--- 파일명: UIGraphicsDB.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Data/UIGraphicsDB.cs) ---
// UIGraphicsDB.cs
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "UIGraphicsDB", menuName = "GameData/UIGraphics Database")]
public class UIGraphicsDB : ScriptableObject
{
    // --- ̱(Singleton)  ---
    private static UIGraphicsDB _instance;
    public static UIGraphicsDB Instance
    {
        get
        {
            if (_instance == null)
            {
                _instance = Resources.Load<UIGraphicsDB>("UIGraphicsDB");
                if (_instance == null)
                    Debug.LogError("UIGraphicsDB could not be loaded from Resources!");
            }
            return _instance;
        }
    }

    // ---   ---
    [System.Serializable]
    public struct RaritySpriteEntry
    {
        public CardRarity rarity;
        public Sprite sprite;
    }

    public List<RaritySpriteEntry> raritySprites;

    // ---    Լ ---
    private Dictionary<CardRarity, Sprite> raritySpriteDict;

    private void OnEnable()
    {
        // Ʈ ųʸ ȯϿ ˻ ӵ Դϴ.
        raritySpriteDict = raritySprites.ToDictionary(x => x.rarity, x => x.sprite);
    }

    public Sprite GetRaritySprite(CardRarity rarity)
    {
        if (raritySpriteDict != null && raritySpriteDict.TryGetValue(rarity, out Sprite sprite))
        {
            return sprite;
        }
        return null; // شϴ Ʈ  
    }
}

--- 파일명: Wave.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Data/Wave.cs) ---
// --- ���ϸ�: Wave.cs ---
using UnityEngine;

// [�߰�] ���� ����� �����ϴ� enum. �� �κ��� ��� ù ��° ������ �߻��߾�.
public enum SpawnType
{
    Spread, // ������ �ð� ���� ������ ����
    Burst   // �� ���� �͸��� ����
}

[System.Serializable]
public class Wave
{
    [Tooltip("�� ���̺꿡�� ������ ������ ������(SO)�� ���� ���⿡ �����ϼ���.")]
    // [����] string ��� MonsterDataSO�� ���� �����մϴ�.
    public MonsterDataSO monsterData;

    [Tooltip("������ ������ ��")]
    public int count;

    [Tooltip("SpawnType�� Spread�� ��, ù ���ͺ��� ������ ���ͱ��� �����Ǵ� �� �ɸ��� �� �ð��Դϴ�.")]
    public float duration = 10f;

    [Tooltip("�� ���̺갡 ���� �� ���� ���̺갡 ���۵Ǳ������ ��� �ð��Դϴ�.")]
    public float delayAfterWave;

    [Tooltip("���� ��� (Spread: �ð���, Burst: ����)")]
    public SpawnType spawnType;

    // ▼▼▼ [3] 이 줄을 추가하세요. ▼▼▼
    [Tooltip("이 웨이브의 몬스터를 몇 마리 미리 생성할지 정합니다. 0으로 두면 'Count' 값을 따릅니다.")]
    public int preloadCount = 50;
}

--- 파일명: ArtifactManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Gameplay/ArtifactManager.cs) ---
using System.Collections.Generic;
using UnityEngine;

public class ArtifactManager : MonoBehaviour
{
    [Header("소유 유물")]
    public List<ArtifactDataSO> ownedArtifacts = new List<ArtifactDataSO>();

    private CharacterStats playerStats;

    private void Awake()
    {
        ServiceLocator.Register<ArtifactManager>(this);
        DontDestroyOnLoad(gameObject);
    }

    public void LinkToNewPlayer(CharacterStats newPlayerStats)
    {
        playerStats = newPlayerStats;
        RecalculateArtifactStats();
    }

    public void EquipArtifact(ArtifactDataSO artifact)
    {
        if (playerStats == null || ownedArtifacts.Contains(artifact)) return;

        ownedArtifacts.Add(artifact);
        
        // [리팩토링] AddModifier 호출 (올바른 StatType 사용)
        playerStats.AddModifier(StatType.Attack, new StatModifier(artifact.attackBoostRatio, artifact));
        playerStats.AddModifier(StatType.Health, new StatModifier(artifact.healthBoostRatio, artifact));
        playerStats.AddModifier(StatType.MoveSpeed, new StatModifier(artifact.moveSpeedBoostRatio, artifact));
        playerStats.AddModifier(StatType.CritRate, new StatModifier(artifact.critChanceBoostRatio, artifact));
        playerStats.AddModifier(StatType.CritMultiplier, new StatModifier(artifact.critDamageBoostRatio, artifact));
    }

    private void RecalculateArtifactStats()
    {
        if (playerStats == null) return;

        var allOwnedArtifacts = new List<ArtifactDataSO>(ownedArtifacts);
        foreach (var artifact in allOwnedArtifacts)
        {
            playerStats.RemoveModifiersFromSource(artifact);
        }

        ownedArtifacts.Clear();
        foreach (var artifact in allOwnedArtifacts)
        {
            EquipArtifact(artifact);
        }
    }
}

--- 파일명: BulletController.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Gameplay/BulletController.cs) ---
using UnityEngine;

/// <summary>
/// 총알의 행동(이동, 소멸)과 데이터(데미지)를 관리합니다.
/// </summary>
public class BulletController : MonoBehaviour
{
    private Vector2 _direction; // 총알의 이동 방향
    public float speed;       // 총알의 속도 (외부에서 접근 가능하도록 public으로 변경)
    public float damage;        // 총알의 데미지 (PlayerController가 설정해 줌)
    public string shotInstanceID; // [추가] 발사 인스턴스 고유 ID
    public float lifetime = 3f; // 총알의 최대 생존 시간
    public CardDataSO SourceCard { get; private set; } // [추가] 이 총알을 발사한 카드 데이터


    /// <summary>
    /// 총알을 초기화하고 발사합니다.
    /// </summary>
    /// <param name="direction">총알의 이동 방향 (정규화된 벡터)</param>
    /// <param name="initialSpeed">총알의 초기 속도</param>
    /// <param name="damage">총알이 줄 데미지</param>
    /// <param name="shotID">[추가] 발사 인스턴스 고유 ID</param>

    public void Initialize(Vector2 direction, float initialSpeed, float damage, string shotID, CardDataSO cardData)
    {
        _direction = direction.normalized; // 방향 벡터 정규화
        speed = initialSpeed; // 초기 속도 설정
        this.damage = damage; // 전달받은 데미지 설정
        this.shotInstanceID = shotID; // [추가] 발사 ID 설정
        this.SourceCard = cardData; // [추가] 카드 데이터 저장

        // 총알의 초기 회전 설정 (선택 사항: 방향에 따라 총알 스프라이트 회전)
        // 예를 들어, Vector2.right가 기본 방향일 때
        float angle = Mathf.Atan2(_direction.y, _direction.x) * Mathf.Rad2Deg;
        transform.rotation = Quaternion.Euler(0, 0, angle);

        // 활성화될 때마다 소멸 타이머를 재시작합니다.
        // Invoke는 간단하지만, 성능이 중요한 경우 코루틴이나 Update에서 직접 시간을 빼는 것이 더 좋습니다.
        Invoke(nameof(Deactivate), lifetime);
    }

    void Update()
    {
        // 매 프레임 지정된 방향으로 이동합니다.
        transform.Translate(_direction * speed * Time.deltaTime, Space.World);
    }

    private void Deactivate()
    {
        // PoolManager를 통해 오브젝트를 풀로 반환합니다.
        ServiceLocator.Get<PoolManager>().Release(gameObject);
    }

    // 몬스터와 충돌했을 때 MonsterController가 이 메서드를 호출하지 않으므로,
    // 이 스크립스는 데미지 값을 가지고 있는 역할만 수행합니다.
    // 충돌 처리는 MonsterController의 OnTriggerEnter2D에서 담당합니다.
}



--- 파일명: ICardEffectHandler.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Gameplay/CardEffectHandlers/ICardEffectHandler.cs) ---
using UnityEngine;

/// <summary>
/// 모든 카드 효과 처리기(Handler)가 구현해야 하는 인터페이스입니다.
/// 전략 패턴(Strategy Pattern)을 사용하여 각 카드 효과를 별도 클래스로 캡슐화합니다.
/// </summary>
public interface ICardEffectHandler
{
    /// <summary>
    /// 카드 효과를 실행합니다.
    /// </summary>
    /// <param name="cardData">실행할 효과가 담긴 카드 데이터입니다.</param>
    /// <param name="executor">다른 시스템에 접근할 때 사용하는 EffectExecutor의 인스턴스입니다.</param>
    /// <param name="casterStats">효과를 시전하는 주체의 CharacterStats입니다.</param>
    /// <param name="spawnPoint">효과가 생성될 위치입니다. (예: 총구 위치, 플레이어의 발사 지점)</param>
    void Execute(CardDataSO cardData, EffectExecutor executor, CharacterStats casterStats, Transform spawnPoint);
}

--- 파일명: SingleShotHandler.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Gameplay/CardEffectHandlers/SingleShotHandler.cs) ---
using UnityEngine;
using System;

/// <summary>
/// 'SingleShot' 타입의 카드 효과를 처리하는 클래스입니다.
/// </summary>
public class SingleShotHandler : ICardEffectHandler
{
    public void Execute(CardDataSO cardData, EffectExecutor executor, CharacterStats casterStats, Transform spawnPoint)
    {
        GameObject bulletPrefab = cardData.bulletPrefab;
        if (bulletPrefab == null)
        { 
            Debug.LogError($"[SingleShotHandler] 오류: 카드 '{cardData.cardName}'에 bulletPrefab이 할당되지 않았습니다!");
            return;
        }


        // 타겟팅 타입에 따라 발사 각도를 계산합니다.
        float angle = executor.GetTargetingAngle(cardData.targetingType, casterStats.transform, spawnPoint);
        Quaternion rotation = Quaternion.Euler(0, 0, angle);
        Vector2 direction = rotation * Vector2.right;

        // 풀 매니저에서 총알 인스턴스를 가져옵니다.
        GameObject bulletGO = ServiceLocator.Get<PoolManager>().Get(bulletPrefab);
        if (bulletGO == null)
        { 
            Debug.LogError($"[SingleShotHandler] 오류: 풀 매니저에서 총알 오브젝트를 가져오지 못했습니다!");
            return;
        }

        // 총알 위치와 회전을 설정합니다.
        bulletGO.transform.position = spawnPoint.position;
        bulletGO.transform.rotation = rotation;

        if (bulletGO.TryGetComponent<BulletController>(out var bullet))
        { 
            // 총알을 초기화하고 발사합니다.
            float totalDamage = executor.CalculateTotalDamage(cardData, casterStats);
            string shotID = Guid.NewGuid().ToString(); // 관통 효과를 위한 고유 ID

            bullet.Initialize(direction, cardData.bulletSpeed, totalDamage, shotID, cardData);
        }
        else
        {
            Debug.LogError($"[SingleShotHandler] 오류: '{bulletPrefab.name}' 프리팹에 BulletController.cs 스크립트가 없습니다!");
        }
    }
}

--- 파일명: SplitShotHandler.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Gameplay/CardEffectHandlers/SplitShotHandler.cs) ---
using UnityEngine;
using System;

/// <summary>
/// 'SplitShot' 타입의 카드 효과를 처리하는 클래스입니다.
/// </summary>
public class SplitShotHandler : ICardEffectHandler
{
    public void Execute(CardDataSO cardData, EffectExecutor executor, CharacterStats casterStats, Transform spawnPoint)
    {
        GameObject bulletPrefab = cardData.bulletPrefab;
        if (bulletPrefab == null)
        {
            Debug.LogError($"[SplitShotHandler] 오류: 스플릿샷 카드 '{cardData.cardName}'에 bulletPrefab이 할당되지 않았습니다!");
            return;
        }


        // 기본 발사 각도를 계산합니다.
        float baseAngle = executor.GetTargetingAngle(cardData.targetingType, casterStats.transform, spawnPoint);

        // 발사할 총알의 개수, 각도 등을 계산합니다.
        int projectileCount = Mathf.Max(1, (int)cardData.triggerValue);
        float angleStep = 360f / projectileCount;
        float totalDamage = executor.CalculateTotalDamage(cardData, casterStats);
        string shotID = Guid.NewGuid().ToString(); // 모든 총알에 대해 동일한 관통 ID를 사용합니다.

        for (int i = 0; i < projectileCount; i++)
        {
            // 현재 총알의 발사 각도를 계산합니다.
            float currentAngle = baseAngle + (angleStep * i);
            Quaternion rotation = Quaternion.Euler(0, 0, currentAngle);
            Vector2 direction = rotation * Vector2.right;

            GameObject bulletGO = ServiceLocator.Get<PoolManager>().Get(bulletPrefab);

            if (bulletGO == null) continue;

            // 총알 위치와 회전을 설정합니다.
            bulletGO.transform.position = spawnPoint.position;
            bulletGO.transform.rotation = rotation;

            if (bulletGO.TryGetComponent<BulletController>(out var bullet))
            {
                bullet.Initialize(direction, cardData.bulletSpeed, totalDamage, shotID, cardData);
            }
        }
    }
}

--- 파일명: WaveHandler.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Gameplay/CardEffectHandlers/WaveHandler.cs) ---
using UnityEngine;
using System;

/// <summary>
/// 'Wave' 타입의 카드 효과(파동, 장판 등)를 처리하는 클래스입니다.
/// </summary>
public class WaveHandler : ICardEffectHandler
{
    public void Execute(CardDataSO cardData, EffectExecutor executor, CharacterStats casterStats, Transform spawnPoint)
    {
        GameObject wavePrefab = cardData.effectPrefab;
        if (wavePrefab == null)
        { 
            Debug.LogError($"[WaveHandler] 오류: 웨이브 카드 '{cardData.cardName}'에 effectPrefab이 할당되지 않았습니다!");
            return;
        }

        // 풀 매니저에서 웨이브 오브젝트를 가져옵니다.
        GameObject waveGO = ServiceLocator.Get<PoolManager>().Get(wavePrefab);

        if (waveGO == null) return;

        // 효과 생성 위치를 지정합니다.
        waveGO.transform.position = spawnPoint.position;

        if (waveGO.TryGetComponent<DamagingZone>(out var zone))
        {
            float totalDamage = executor.CalculateTotalDamage(cardData, casterStats);
            string shotID = Guid.NewGuid().ToString();

            // DamagingZone을 카드 데이터에 맞게 초기화합니다.
            zone.Initialize(
                singleHitDmg: totalDamage,
                continuousDmgPerTick: cardData.effectDamagePerTick,
                tickInt: cardData.effectTickInterval,
                totalDur: cardData.effectDuration,
                expSpeed: cardData.effectExpansionSpeed,
                expDur: cardData.effectExpansionDuration,
                isWave: cardData.isEffectSingleHitWaveMode,
                shotID: shotID
            );
        }
        else
        {
            Debug.LogError($"[WaveHandler] 오류: '{wavePrefab.name}' 프리팹에 DamagingZone.cs 스크립트가 없습니다!");
        }
    }
}

--- 파일명: CardManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Gameplay/CardManager.cs) ---
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class CardManager : MonoBehaviour
{
    [Header("카드 목록")]
    public List<CardDataSO> ownedCards = new List<CardDataSO>();
    public List<CardDataSO> equippedCards = new List<CardDataSO>();

    [Header("슬롯 설정")]
    public int maxOwnedSlots = 7;
    public int maxEquipSlots = 5;

    [Header("실시간 카드 상태")]
    public CardDataSO activeCard;

    private CharacterStats playerStats;

    private void Awake()
    {
        ServiceLocator.Register<CardManager>(this);
        DontDestroyOnLoad(gameObject);
    }

    void OnEnable()
    {
        RoundManager.OnRoundEnded += HandleRoundEnd;
    }

    void OnDisable()
    {
        RoundManager.OnRoundEnded -= HandleRoundEnd;
    }

    private void HandleRoundEnd(bool success)
    {
        CancelInvoke(nameof(SelectActiveCard));
    }

    public void LinkToNewPlayer(CharacterStats newPlayerStats)
    {
        playerStats = newPlayerStats;
        RecalculateCardStats();
    }

    public void AcquireNewCard(CardDataSO newCard)
    {
        if (ownedCards.Count >= maxOwnedSlots)
        {
            int randomIndex = Random.Range(0, ownedCards.Count);
            CardDataSO cardToRemove = ownedCards[randomIndex];
            if (equippedCards.Contains(cardToRemove)) Unequip(cardToRemove);
            ownedCards.Remove(cardToRemove);
        }

        ownedCards.Add(newCard);

        if (equippedCards.Count >= maxEquipSlots)
        {
            int randomIndex = Random.Range(0, equippedCards.Count);
            CardDataSO cardToUnequip = equippedCards[randomIndex];
            Unequip(cardToUnequip);
        }

        Equip(newCard);
    }

    public void AddCard(CardDataSO cardToAdd)
    {
        if (ownedCards.Count >= maxOwnedSlots) return;
        ownedCards.Add(cardToAdd);
    }

    public bool Equip(CardDataSO card)
    {
        if (playerStats == null || equippedCards.Count >= maxEquipSlots || !ownedCards.Contains(card) || equippedCards.Contains(card)) return false;

        equippedCards.Add(card);
        
        // [리팩토링] AddModifier 호출 (올바른 StatType 사용)
        playerStats.AddModifier(StatType.Attack, new StatModifier(card.damageMultiplier, card));
        playerStats.AddModifier(StatType.AttackSpeed, new StatModifier(card.attackSpeedMultiplier, card));
        playerStats.AddModifier(StatType.MoveSpeed, new StatModifier(card.moveSpeedMultiplier, card));
        playerStats.AddModifier(StatType.Health, new StatModifier(card.healthMultiplier, card));
        playerStats.AddModifier(StatType.CritRate, new StatModifier(card.critRateMultiplier, card));
        playerStats.AddModifier(StatType.CritMultiplier, new StatModifier(card.critDamageMultiplier, card));

        return true;
    }

    public bool Unequip(CardDataSO card)
    {
        if (playerStats == null || !equippedCards.Contains(card)) return false;

        bool removed = equippedCards.Remove(card);
        if (removed)
        {
            playerStats.RemoveModifiersFromSource(card);
        }
        return removed;
    }

    private void RecalculateCardStats()
    {
        if (playerStats == null) return;

        var allOwnedCards = new List<CardDataSO>(ownedCards);
        foreach (var card in allOwnedCards)
        {
            playerStats.RemoveModifiersFromSource(card);
        }

        var currentEquippedCards = new List<CardDataSO>(equippedCards);
        equippedCards.Clear();
        foreach (var card in currentEquippedCards)
        {
            Equip(card);
        }
    }

    public List<CardDataSO> GetEquippedCards()
    {
        return new List<CardDataSO>(equippedCards);
    }

    public void StartCardSelectionLoop()
    {
        CancelInvoke(nameof(SelectActiveCard));
        float interval = (playerStats != null) ? playerStats.cardSelectionInterval : 10f;
        InvokeRepeating(nameof(SelectActiveCard), 0f, interval);
        SelectActiveCard();
    }

    private void SelectActiveCard()
    {
        if (equippedCards.Count == 0)
        {
            activeCard = null;
            return;
        }

        float totalWeight = equippedCards.Sum(card => Mathf.Max(0, card.selectionWeight));
        if (totalWeight <= 0)
        {
            activeCard = equippedCards[0];
            return;
        }

        float randomPoint = Random.Range(0, totalWeight);
        float currentWeightSum = 0f;
        foreach (var card in equippedCards)
        {
            float weight = Mathf.Max(0, card.selectionWeight);
            if (randomPoint <= currentWeightSum + weight)
            {
                activeCard = card;
                return;
            }
            currentWeightSum += weight;
        }
        activeCard = equippedCards.LastOrDefault();
    }

    public bool HasSynthesizablePair(CardDataSO card)
    {
        if (card == null) return false;
        return ownedCards.Any(ownedCard => ownedCard.type == card.type && ownedCard.rarity == card.rarity);
    }

    public List<CardDataSO> GetSynthesizablePairs(CardDataSO card)
    {
        return ownedCards.Where(ownedCard => ownedCard.type == card.type && ownedCard.rarity == card.rarity).ToList();
    }

    public void SynthesizeCards(CardDataSO rewardCard, CardDataSO materialCard)
    {
        bool wasEquipped = equippedCards.Contains(materialCard);
        if (wasEquipped) Unequip(materialCard);
        ownedCards.Remove(materialCard);

        CardDataSO baseCard = Random.Range(0, 2) == 0 ? rewardCard : materialCard;
        CardDataSO enhancedCard = Instantiate(baseCard);
        enhancedCard.name = baseCard.name + "_Synth";
        enhancedCard.cardName = baseCard.cardName + "+";
        if (enhancedCard.baseDamage > 0) enhancedCard.baseDamage *= 1.1f;

        ownedCards.Add(enhancedCard);
        if (wasEquipped) Equip(enhancedCard);
    }
}

--- 파일명: CharacterStats.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Gameplay/CharacterStats.cs) ---
using UnityEngine;
using UnityEngine.Events;
using System.Collections.Generic;
using System.Linq;

[RequireComponent(typeof(PlayerHealthBar))]
public class CharacterStats : MonoBehaviour
{
    [Header("기본 능력치")]
    public BaseStats stats;

    [Header("현재 상태 (런타임)")]
    public float currentHealth;
    public bool isInvulnerable = false;

    [Header("이벤트")]
    public UnityEvent OnFinalStatsCalculated = new UnityEvent();

    private PlayerHealthBar playerHealthBar;
    public float cardSelectionInterval = 10f;

    private readonly Dictionary<StatType, List<StatModifier>> statModifiers = new Dictionary<StatType, List<StatModifier>>();

    // [리팩토링] 최종 스탯을 실시간으로 계산하는 프로퍼티 (올바른 StatType 사용)
    public float FinalDamage => CalculateFinalValue(StatType.Attack, stats.baseDamage);
    public float FinalAttackSpeed => Mathf.Max(0.1f, CalculateFinalValue(StatType.AttackSpeed, stats.baseAttackSpeed));
    public float FinalMoveSpeed => Mathf.Max(0f, CalculateFinalValue(StatType.MoveSpeed, stats.baseMoveSpeed));
    public float FinalHealth => Mathf.Max(1f, CalculateFinalValue(StatType.Health, stats.baseHealth));
    public float FinalCritRate => Mathf.Clamp(CalculateFinalValue(StatType.CritRate, stats.baseCritRate), 0f, 100f);
    public float FinalCritDamage => Mathf.Max(0f, CalculateFinalValue(StatType.CritMultiplier, stats.baseCritDamage));

    void Awake()
    {
        playerHealthBar = GetComponent<PlayerHealthBar>();
        foreach (StatType type in System.Enum.GetValues(typeof(StatType)))
        {
            statModifiers[type] = new List<StatModifier>();
        }
    }

    void OnDestroy()
    {
        var debugManager = ServiceLocator.Get<DebugManager>();
        if (debugManager != null)
        {
            debugManager.UnregisterPlayer();
        }
    }

    public void AddModifier(StatType type, StatModifier modifier)
    {
        statModifiers[type].Add(modifier);
        CalculateFinalStats();
    }

    public void RemoveModifiersFromSource(object source)
    {
        foreach (var key in statModifiers.Keys)
        {
            statModifiers[key].RemoveAll(mod => mod.Source == source);
        }
        CalculateFinalStats();
    }

    private float CalculateFinalValue(StatType type, float baseValue)
    {
        float totalBonusRatio = statModifiers[type].Sum(mod => mod.Value);
        return baseValue * (1 + totalBonusRatio / 100f);
    }

    public void CalculateFinalStats()
    {
        OnFinalStatsCalculated?.Invoke();
    }

    public void TakeDamage(float damage)
    {
        if (isInvulnerable) return;
        currentHealth -= damage;
        playerHealthBar.UpdateHealth(currentHealth, FinalHealth);
        if (currentHealth <= 0)
        {
            currentHealth = 0;
            Die();
        }
    }

    private void Die()
    {
        Debug.Log("[CharacterStats] 플레이어가 사망했습니다. 게임오버 상태로 전환합니다.");
        gameObject.SetActive(false);
        ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.GameOver);
    }

    public void Heal(float amount)
    {
        currentHealth += amount;
        if (currentHealth > FinalHealth) currentHealth = FinalHealth;
        playerHealthBar.UpdateHealth(currentHealth, FinalHealth);
    }

    public void ApplyPermanentStats(CharacterPermanentStats permanentStats)
    {
        if (permanentStats == null) return;
        RemoveModifiersFromSource(StatSources.Permanent);
        foreach (var stat in permanentStats.investedRatios)
        {
            AddModifier(stat.Key, new StatModifier(stat.Value, StatSources.Permanent));
        }
    }

    public void ApplyAllocatedPoints(int points, CharacterPermanentStats permStats)
    {
        if (points <= 0 || permStats == null) return;
        RemoveModifiersFromSource(StatSources.Allocated);

        List<StatType> availableStats = permStats.GetUnlockedStats();
        if (availableStats.Count == 0) return;

        for (int i = 0; i < points; i++)
        {
            StatType targetStat = availableStats[Random.Range(0, availableStats.Count)];
            float weight = GetWeightForStat(targetStat);
            AddModifier(targetStat, new StatModifier(weight, StatSources.Allocated));
        }
    }

    private float GetWeightForStat(StatType stat)
    {
        return stat == StatType.Health ? 2f : 1f;
    }

    public float GetCurrentHealth()
    {
        return currentHealth;
    }

    public static BaseStats CalculatePreviewStats(BaseStats baseStats, int allocatedPoints)
    {
        BaseStats previewStats = new BaseStats();
        float healthGeneBoosterRatio = allocatedPoints * 2f;
        float otherStatsGeneBoosterRatio = allocatedPoints * 1f;

        previewStats.baseHealth = baseStats.baseHealth * (1 + healthGeneBoosterRatio / 100f);
        previewStats.baseDamage = baseStats.baseDamage * (1 + otherStatsGeneBoosterRatio / 100f);
        previewStats.baseAttackSpeed = baseStats.baseAttackSpeed * (1 + otherStatsGeneBoosterRatio / 100f);
        previewStats.baseMoveSpeed = baseStats.baseMoveSpeed * (1 + otherStatsGeneBoosterRatio / 100f);
        previewStats.baseCritDamage = baseStats.baseCritDamage * (1 + otherStatsGeneBoosterRatio / 100f);
        previewStats.baseCritRate = baseStats.baseCritRate;
        return previewStats;
    }
}

--- 파일명: DamagingZone.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Gameplay/DamagingZone.cs) ---
using UnityEngine;
using System.Collections.Generic;

public class DamagingZone : MonoBehaviour
{
    [Header(" ")]
    public float singleHitDamage = 0f;
    public float damagePerTick = 10f;
    [Tooltip("     ִ  (). ĵ   100 ̻ Էϼ.")]
    public float tickInterval = 1.0f;
    public float duration = 5.0f;

    [Header("ĵ/ Ȯ ")]
    public float expansionSpeed = 1.0f;
    public float expansionDuration = 2.0f;

    public string shotInstanceID;
    public bool isSingleHitWaveMode = true;

    private List<MonsterController> targets = new List<MonsterController>();
    private float tickTimer;
    private float durationTimer;
    private float expansionTimer;
    private CircleCollider2D circleCollider;
    private Vector3 initialScale;
    private float initialColliderRadius;

    void Awake()
    {
        initialScale = transform.localScale;
        circleCollider = GetComponent<CircleCollider2D>();
        if (circleCollider != null)
        {
            initialColliderRadius = circleCollider.radius;
        }
    }

    void OnEnable()
    {
        tickTimer = 0f;
        durationTimer = duration;
        expansionTimer = 0f;
        transform.localScale = initialScale;
        targets.Clear();
    }

    public void Initialize(float singleHitDmg, float continuousDmgPerTick, float tickInt, float totalDur, float expSpeed, float expDur, bool isWave, string shotID)
    {
        this.singleHitDamage = singleHitDmg;
        this.damagePerTick = continuousDmgPerTick;
        this.tickInterval = tickInt;
        this.duration = totalDur;
        this.expansionSpeed = expSpeed;
        this.expansionDuration = expDur;
        this.isSingleHitWaveMode = isWave;
        this.shotInstanceID = shotID;
        OnEnable();
    }

    void Update()
    {
        durationTimer -= Time.deltaTime;
        if (durationTimer <= 0)
        {
            // --- [] PoolManager ȣ ڵ带 ϳ մϴ. ---
            var poolManager = ServiceLocator.Get<PoolManager>();
            if (poolManager != null)
                poolManager.Release(gameObject);
            else
                Destroy(gameObject);
            return;
        }

        if (expansionTimer < expansionDuration)
        {
            expansionTimer += Time.deltaTime;
            transform.localScale += Vector3.one * expansionSpeed * Time.deltaTime;
        }

        if (!isSingleHitWaveMode)
        {
            tickTimer += Time.deltaTime;
            if (tickTimer >= tickInterval)
            {
                tickTimer = 0f;
                ApplyDamageToTargets();
            }
        }
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Monster"))
        {
            MonsterController monster = other.GetComponent<MonsterController>();
            if (monster == null) return;

            if (isSingleHitWaveMode)
            {
                if (!monster.hitShotIDs.Contains(this.shotInstanceID))
                {
                    monster.hitShotIDs.Add(this.shotInstanceID);
                    monster.TakeDamage(this.singleHitDamage);
                }
            }
            else
            {
                if (!targets.Contains(monster))
                {
                    targets.Add(monster);
                }
            }
        }
    }

    private void OnTriggerExit2D(Collider2D other)
    {
        if (other.CompareTag("Monster"))
        {
            MonsterController monster = other.GetComponent<MonsterController>();
            if (monster == null) return;

            if (!isSingleHitWaveMode)
            {
                if (targets.Contains(monster))
                {
                    targets.Remove(monster);
                }
            }
        }
    }

    private void ApplyDamageToTargets()
    {
        List<MonsterController> currentTargets = new List<MonsterController>(targets);
        foreach (var monster in currentTargets)
        {
            if (monster != null && monster.gameObject.activeInHierarchy)
            {
                monster.TakeDamage(damagePerTick);
            }
        }
    }
}

--- 파일명: MapGenerator.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Gameplay/MapGenerator.cs) ---
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// 절차적 맵 생성을 담당하는 클래스입니다.
/// MonoBehaviour를 상속하여 Inspector에서 맵 생성 규칙을 쉽게 조정할 수 있습니다.
/// </summary>
public class MapGenerator : MonoBehaviour
{
    [Header("맵 크기 설정")]
    [SerializeField] private int mapHeight = 15; // y: 0 ~ 14
    [SerializeField] private int mapWidth = 5;   // x: 0 ~ 4

    // [추가됨] 다른 스크립트에서 맵 크기를 읽을 수 있도록 public getter를 추가합니다.
    public int MapHeight => mapHeight;
    public int MapWidth => mapWidth;

    [Header("노드 타입 생성 확률 (0~100%)")]
    [Range(0, 100)] [SerializeField] private float monsterChance = 60f;
    [Range(0, 100)] [SerializeField] private float restChance = 15f;
    [Range(0, 100)] [SerializeField] private float eventChance = 15f;
    [Range(0, 100)] [SerializeField] private float merchantChance = 10f; // 상점

    [Header("맵 경로 설정")]
    [SerializeField] private int numberOfPathsToGenerate = 4; // 생성할 경로의 개수

    [Header("디버그 옵션")]
    [SerializeField] private bool forceAllMonsters = true; // 이 옵션이 켜져 있으면 모든 노드를 몬스터로 강제합니다.

    /// <summary>
    /// 설정된 규칙에 따라 새로운 맵 데이터를 생성하고 노드 리스트를 반환합니다.
    /// </summary>
    /// <returns>생성된 모든 MapNode 객체의 리스트</returns>
    public List<MapNode> Generate()
    {

        // 맵 그리드 초기화 (모든 노드를 일단 생성)
        MapNode[,] grid = new MapNode[mapWidth, mapHeight];
        for (int y = 0; y < mapHeight; y++)
        {
            for (int x = 0; x < mapWidth; x++)
            {
                grid[x, y] = new MapNode { Position = new Vector2Int(x, y) };
            }
        }

        // 경로에 포함될 노드를 추적하기 위한 HashSet
        HashSet<MapNode> nodesInPaths = new HashSet<MapNode>();

        // 1. 고정된 시작/끝 노드 처리
        MapNode startNode = grid[mapWidth / 2, 0]; // y=0, x=2
        MapNode endNode = grid[mapWidth / 2, mapHeight - 1]; // y=14, x=2
        nodesInPaths.Add(startNode);
        nodesInPaths.Add(endNode);

        // 2. 지정된 개수만큼 경로 생성
        for (int i = 0; i < numberOfPathsToGenerate; i++)
        {
            GenerateSinglePath(grid, nodesInPaths, startNode, endNode);
        }

        // 3. 경로에 포함되지 않은 노드 삭제 및 최종 노드 리스트 생성
        List<MapNode> finalNodes = nodesInPaths.ToList();

        // 4. 노드 타입 할당 및 연결
        AssignNodeTypesAndConnectNodes(finalNodes, grid);

        return finalNodes;
    }

    /// <summary>
    /// 단일 경로를 생성하고, 경로에 포함된 노드들을 nodesInPaths에 추가합니다.
    /// </summary>
    private void GenerateSinglePath(MapNode[,] grid, HashSet<MapNode> nodesInPaths, MapNode startNode, MapNode endNode)
    {
        MapNode currentNode = startNode;
        nodesInPaths.Add(currentNode);

        for (int y = 0; y < mapHeight - 1; y++)
        {
            List<MapNode> possibleNextNodes = new List<MapNode>();

            if (y == 0) // y=0 -> y=1로 갈 때: y=1의 모든 x 노드로 연결 가능
            {
                for (int x = 0; x < mapWidth; x++)
                {
                    possibleNextNodes.Add(grid[x, y + 1]);
                }
            }
            else if (y == mapHeight - 2) // y=13 -> y=14로 갈 때: y=14의 x=2 노드로만 연결
            {
                possibleNextNodes.Add(endNode);
            }
            else // 일반적인 이동 규칙: x-1, x, x+1
            {
                int currentX = currentNode.Position.x;
                for (int dx = -1; dx <= 1; dx++)
                {
                    int nextX = currentX + dx;
                    if (nextX >= 0 && nextX < mapWidth)
                    {
                        possibleNextNodes.Add(grid[nextX, y + 1]);
                    }
                }
            }

            if (possibleNextNodes.Count > 0)
            {
                MapNode nextNode = possibleNextNodes[Random.Range(0, possibleNextNodes.Count)];
                nodesInPaths.Add(nextNode);
                currentNode = nextNode;
            }
            else
            {
                Debug.LogWarning($"[MapGenerator] 경로 생성 중 다음 노드를 찾을 수 없습니다. Y:{y}, X:{currentNode.Position.x}");
                break; // 경로 생성 실패
            }
        }
    }

    /// <summary>
    /// 최종 노드 리스트에 노드 타입을 할당하고, 노드 간 연결을 설정합니다.
    /// </summary>
    private void AssignNodeTypesAndConnectNodes(List<MapNode> finalNodes, MapNode[,] grid)
    {
        // 노드 타입 할당
        foreach (var node in finalNodes)
        {
            node.NodeType = GetNodeTypeForPosition(node.Position.y);
        }

        // 노드 연결
        foreach (var currentNode in finalNodes)
        {
            // y=14 노드는 다음 노드가 없습니다.
            if (currentNode.Position.y == mapHeight - 1) continue;

            List<MapNode> possibleNextLayerNodes = new List<MapNode>();

            if (currentNode.Position.y == 0) // y=0 노드: y=1에 있는 모든 노드와 연결
            {
                for (int x = 0; x < mapWidth; x++)
                {
                    MapNode nextNodeCandidate = grid[x, 1];
                    if (finalNodes.Contains(nextNodeCandidate))
                    {
                        possibleNextLayerNodes.Add(nextNodeCandidate);
                    }
                }
            }
            else if (currentNode.Position.y == mapHeight - 2) // y=13 노드: y=14의 x=2 노드와 연결
            {
                MapNode nextNodeCandidate = grid[mapWidth / 2, mapHeight - 1];
                if (finalNodes.Contains(nextNodeCandidate))
                {
                    possibleNextLayerNodes.Add(nextNodeCandidate);
                }
            }
            else // 일반적인 이동 규칙: x-1, x, x+1 범위 내의 다음 층 노드와 연결
            {
                int currentX = currentNode.Position.x;
                for (int dx = -1; dx <= 1; dx++)
                {
                    int nextX = currentX + dx;
                    if (nextX >= 0 && nextX < mapWidth)
                    {
                        MapNode nextNodeCandidate = grid[nextX, currentNode.Position.y + 1];
                        if (finalNodes.Contains(nextNodeCandidate))
                        {
                            possibleNextLayerNodes.Add(nextNodeCandidate);
                        }
                    }
                }
            }

            // 실제 연결
            foreach (var nextNode in possibleNextLayerNodes)
            {
                currentNode.NextNodes.Add(nextNode);
            }
        }
    }

    /// <summary>
    /// y 좌표에 따라 노드 타입을 결정합니다.
    /// </summary>
    private NodeType GetNodeTypeForPosition(int y)
    {
        // 시작(y=0)과 끝(y=14)은 항상 몬스터 노드
        if (y == 0 || y == mapHeight - 1)
        {
            return NodeType.Monster;
        }

        // 디버그 옵션이 켜져 있으면 항상 몬스터 반환
        if (forceAllMonsters)
        {
            return NodeType.Monster;
        }

        // ---- 향후 구현을 위한 확률 기반 노드 타입 결정 로직 ----
        // 현재는 주석 처리되어 있으며, forceAllMonsters가 false일 때 동작합니다.

        float totalChance = monsterChance + restChance + eventChance + merchantChance;
        float randomValue = Random.Range(0, totalChance);

        // if (randomValue < monsterChance)
        // {
        //     return NodeType.Monster;
        // }
        // else if (randomValue < monsterChance + restChance)
        // {
        //     // return NodeType.Rest; // 기능 구현 시 주석 해제
        //     return NodeType.Monster; // 현재는 몬스터로 대체
        // }
        // else if (randomValue < monsterChance + restChance + eventChance)
        // {
        //     // return NodeType.Event; // 기능 구현 시 주석 해제
        //     return NodeType.Monster; // 현재는 몬스터로 대체
        // }
        // else
        // {
        //     // return NodeType.Shop; // 기능 구현 시 주석 해제
        //     return NodeType.Monster; // 현재는 몬스터로 대체
        // }

        // 위 로직을 모두 주석처리하고 몬스터로 고정합니다.
        return NodeType.Monster;
    }
}

--- 파일명: MonsterController.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Gameplay/MonsterController.cs) ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

[RequireComponent(typeof(Rigidbody2D))]
public class MonsterController : MonoBehaviour
{
    public static event System.Action<float, Vector3> OnMonsterDamaged;
    public static event System.Action<MonsterController> OnMonsterDied;

    [HideInInspector] public float moveSpeed;
    [HideInInspector] public float contactDamage;
    [HideInInspector] public float maxHealth;
    public float currentHealth;

    private MonsterDataSO monsterData;
    private Transform playerTransform;
    private bool isInvulnerable = false;
    private Rigidbody2D rb;

    private const float DAMAGE_INTERVAL = 0.1f;
    private float damageTimer = 0f;
    private bool isTouchingPlayer = false;

    public HashSet<string> hitShotIDs = new HashSet<string>();

    private bool isDead = false;

    void Awake()
    {
        rb = GetComponent<Rigidbody2D>();
    }

    void OnEnable()
    {
        // ... 기존 코드 ...
        ServiceLocator.Get<MonsterManager>()?.RegisterMonster(this); // 활성화될 때 리스트에 추가
        hitShotIDs.Clear();
        isDead = false;
        if (monsterData != null)
        {
            currentHealth = monsterData.maxHealth;
        }
        isInvulnerable = false;
    }

    void OnDisable()
    {
        // ... 기존 코드 ...
        ServiceLocator.Get<MonsterManager>()?.UnregisterMonster(this); // 비활성화될 때 리스트에서 제거
    }

    

    public void Initialize(MonsterDataSO data)
    {
        monsterData = data;
        maxHealth = monsterData.maxHealth;
        moveSpeed = monsterData.moveSpeed;
        contactDamage = monsterData.contactDamage;
        currentHealth = maxHealth;
        hitShotIDs.Clear();
        isDead = false;
    }

    void Update()
    {
        if (isTouchingPlayer)
        {
            damageTimer += Time.deltaTime;
            if (damageTimer >= DAMAGE_INTERVAL)
            {
                ApplyContactDamage();
                damageTimer = 0f;
            }
        }
    }

    void FixedUpdate()
    {
        // --- [수정] ServiceLocator를 통해 PlayerController를 찾아옵니다. ---
        var playerController = ServiceLocator.Get<PlayerController>();
        if (playerController != null)
        {
            playerTransform = playerController.transform;
        }
        else
        {
            Debug.LogError($"[{gameObject.name}] PlayerController 인스턴스를 찾을 수 없습니다! 스크립트를 비활성화합니다.");
            this.enabled = false;
            return;
        }

        if (isInvulnerable || playerTransform == null || isDead)
        {
            rb.velocity = Vector2.zero;
            return;
        }
        Vector2 direction = (playerTransform.position - transform.position).normalized;
        rb.velocity = direction * moveSpeed;
    }

    void OnCollisionEnter2D(Collision2D collision)
    {
        CheckForPlayer(collision.gameObject);
    }

    void OnCollisionExit2D(Collision2D collision)
    {
        LeavePlayer(collision.gameObject);
    }

    void OnTriggerEnter2D(Collider2D other)
    {
        if (isDead)
        {
            return;
        }

        if (other.TryGetComponent<BulletController>(out var hitBullet))
        {
            if (hitShotIDs.Contains(hitBullet.shotInstanceID))
            {
                ServiceLocator.Get<PoolManager>().Release(other.gameObject);
                return;
            }

            hitShotIDs.Add(hitBullet.shotInstanceID);
            TakeDamage(hitBullet.damage);

            if (hitBullet.SourceCard != null && hitBullet.SourceCard.statusEffectToApply != null)
            {
                ServiceLocator.Get<StatusEffectManager>().ApplyStatusEffect(this.gameObject, hitBullet.SourceCard.statusEffectToApply);
            }

            if (hitBullet.SourceCard != null && hitBullet.SourceCard.secondaryEffect != null)
            {
                ServiceLocator.Get<EffectExecutor>().Execute(hitBullet.SourceCard.secondaryEffect, GetComponent<CharacterStats>(), this.transform);
            }

            ServiceLocator.Get<PoolManager>().Release(other.gameObject);
        }
        else
        {
            CheckForPlayer(other.gameObject);
        }
    }

    void OnTriggerExit2D(Collider2D other)
    {
        LeavePlayer(other.gameObject);
    }

    private void CheckForPlayer(GameObject target)
    {
        if (target.GetComponent<CharacterStats>() != null)
        {
            isTouchingPlayer = true;
            damageTimer = DAMAGE_INTERVAL;
        }
    }

    private void LeavePlayer(GameObject target)
    {
        if (target.GetComponent<CharacterStats>() != null)
        {
            isTouchingPlayer = false;
            damageTimer = 0f;
        }
    }

    private void ApplyContactDamage()
    {
        if (playerTransform != null)
        {
            CharacterStats playerStats = playerTransform.GetComponent<CharacterStats>();
            if (playerStats != null)
            {
                playerStats.TakeDamage(contactDamage);
            }
        }
    }

    public void TakeDamage(float damage)
    {
        if (isDead || isInvulnerable) return;

        currentHealth -= damage;
        OnMonsterDamaged?.Invoke(damage, transform.position);

        if (currentHealth <= 0) Die();
    }

    private void Die()
    {
        if (isDead) return;

        isDead = true;
        OnMonsterDied?.Invoke(this);
        ServiceLocator.Get<PoolManager>().Release(gameObject);
    }

    public void SetInvulnerable(float duration)
    {
        StopCoroutine("InvulnerableRoutine");
        StartCoroutine(InvulnerableRoutine(duration));
    }

    private IEnumerator InvulnerableRoutine(float duration)
    {
        isInvulnerable = true;
        yield return new WaitForSeconds(duration);
        isInvulnerable = false;
    }
}

--- 파일명: MonsterSpawner.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Gameplay/MonsterSpawner.cs) ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class MonsterSpawner : MonoBehaviour
{
    [Header("스폰 위치 설정")]
    private Transform playerTransform;
    [SerializeField] private float minSpawnRadius = 10f;
    [SerializeField] private float maxSpawnRadius = 15f;

    private Coroutine spawnCoroutine;

    // ★★★ 핵심 수정: StartSpawning의 인자를 List<Wave>로 수정 (Assets.txt 기반) ★★★
    public void StartSpawning(List<Wave> waves)
    {
        Debug.Log("[MonsterSpawner] StartSpawning called.");
        if (spawnCoroutine != null) StopCoroutine(spawnCoroutine);
        spawnCoroutine = StartCoroutine(SpawnRoutine(waves));
    }

    // ★★★ 핵심 수정: StopSpawning() 함수 복원 (CS1061 오류 해결) ★★★
    public void StopSpawning()
    {
        Debug.Log("[MonsterSpawner] StopSpawning called.");
        if (spawnCoroutine != null)
        {
            StopCoroutine(spawnCoroutine);
            spawnCoroutine = null;
        }
    }

    private IEnumerator SpawnRoutine(List<Wave> waves)
    {
        // --- 기존 디버그 로그 보존 ---
        Debug.Log($"[MonsterSpawner] 스폰 루틴 시작. 전달받은 웨이브 개수: {waves.Count}");

        Debug.Log($"[MonsterSpawner] 스폰 루틴 시작. 전달받은 웨이브 개수: {waves.Count}");
        
        // playerTransform을 찾을 때까지 대기
        while (playerTransform == null)
        {
            var playerController = ServiceLocator.Get<PlayerController>();
            if (playerController != null)
            {
                playerTransform = playerController.transform;
                Debug.Log($"[MonsterSpawner] 성공: ServiceLocator를 통해 PlayerController를 찾아 playerTransform에 할당했습니다.");
            }
            else
            {
                // 아직 Player가 생성/등록되지 않았으면 한 프레임 대기 후 다시 시도
                yield return null; 
            }
        }

        yield return new WaitForSeconds(1f);

        foreach (var wave in waves)
        {
            if (wave.monsterData == null)
            {
                // --- 기존 디버그 로그 보존 ---
                Debug.LogWarning("Wave에 몬스터 데이터가 설정되지 않아 해당 웨이브를 건너뜁니다.");
                continue;
            }

            switch (wave.spawnType)
            {
                case SpawnType.Spread:
                    float spawnInterval = (wave.count > 1 && wave.duration > 0) ? wave.duration / wave.count : 0.5f;
                    for (int i = 0; i < wave.count; i++)
                    {
                        SpawnMonster(wave.monsterData, playerTransform.position);
                        yield return new WaitForSeconds(spawnInterval);
                    }
                    yield return new WaitForSeconds(wave.delayAfterWave);
                    break;

                case SpawnType.Burst:
                    yield return new WaitForSeconds(wave.delayAfterWave);
                    for (int i = 0; i < wave.count; i++)
                    {
                        SpawnMonster(wave.monsterData, playerTransform.position);
                    }
                    break;
            }
        }
    }

    // ★★★ 핵심 수정: MonsterData를 MonsterDataSO로 변경 (CS0246 오류 해결) ★★★
    private void SpawnMonster(MonsterDataSO monsterData, Vector3 center)
    {
        if (monsterData == null)
        {
            // --- 기존 디버그 로그 보존 ---
            Debug.LogWarning("[MonsterSpawner] 스폰 실패! 전달된 MonsterDataSO가 null입니다.");
            return;
        }

        GameObject monsterPrefab = monsterData.prefab;

        if (monsterPrefab == null)
        {
            // --- 기존 디버그 로그 보존 ---
            Debug.LogError($"[MonsterSpawner] 스폰 실패! '{monsterData.monsterName}' 데이터에 프리팹이 연결되지 않았습니다.");
            return;
        }

        Vector2 randomDirection = Random.insideUnitCircle.normalized;
        float randomDistance = Random.Range(minSpawnRadius, maxSpawnRadius);
        Vector3 spawnPosition = center + (Vector3)(randomDirection * randomDistance);

        GameObject monsterInstance = ServiceLocator.Get<PoolManager>().Get(monsterPrefab);

        monsterInstance.transform.position = spawnPosition;

        MonsterController mc = monsterInstance.GetComponent<MonsterController>();
        if (mc != null)
        {
            mc.Initialize(monsterData);
            mc.SetInvulnerable(0.3f);
        }
    }
}

--- 파일명: PlayerController.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Gameplay/PlayerController.cs) ---
// 파일명: PlayerController.cs (리팩토링 완료)
using UnityEngine;

[RequireComponent(typeof(Rigidbody2D))]
public class PlayerController : MonoBehaviour
{
    private Rigidbody2D rb;
    private CharacterStats stats;
    private Vector2 moveInput;

    private CardManager cardManager;
    private EffectExecutor effectExecutor;
    private InputManager inputManager;

    [Header("공격 시작 위치")]
    public Transform firePoint;

    void Awake()
    {
        // 씬이 시작될 때 ServiceLocator에 자신을 등록합니다.
        ServiceLocator.Register<PlayerController>(this);
        Debug.Log($"[{GetType().Name}] ServiceLocator에 PlayerController를 등록했습니다.");

        rb = GetComponent<Rigidbody2D>();
        stats = GetComponent<CharacterStats>();

        cardManager = ServiceLocator.Get<CardManager>();
        effectExecutor = ServiceLocator.Get<EffectExecutor>();
        inputManager = ServiceLocator.Get<InputManager>();

        if (cardManager == null || effectExecutor == null || inputManager == null)
        {
            Debug.LogError($"[{GetType().Name}] Awake에서 필수 매니저 중 하나를 가져오지 못했습니다! ServiceLocator 등록 순서를 확인하세요.");
        }
    }

    void OnEnable()
    {
        if (inputManager != null)
        {
            inputManager.OnMove.AddListener(OnMove);
        }
        RoundManager.OnRoundEnded += HandleRoundEnd;
    }

    void OnDisable()
    {
        if (inputManager != null)
        {
            inputManager.OnMove.RemoveListener(OnMove);
        }
        RoundManager.OnRoundEnded -= HandleRoundEnd;
    }

    // 오브젝트가 파괴될 때 ServiceLocator에서 등록을 해제합니다.
    private void OnDestroy()
    {
        ServiceLocator.Unregister<PlayerController>(this);
        Debug.Log($"[{GetType().Name}] ServiceLocator에서 PlayerController를 등록 해제했습니다.");
    }

    private void HandleRoundEnd(bool success)
    {
        Debug.Log($"[{GetType().Name}] 라운드 종료(성공: {success}). 자동 공격을 중지합니다.");
        CancelInvoke(nameof(PerformAttack));
    }

    public void StartAutoAttackLoop()
    {
        CancelInvoke(nameof(PerformAttack));
        if (stats == null)
        {
            Debug.LogError($"[{GetType().Name}] CharacterStats가 없어 공격 루프를 시작할 수 없습니다!");
            return;
        }

        float interval = 1f / stats.FinalAttackSpeed;
        Debug.Log($"[{GetType().Name}] 공격 루프 시작. (공격 속도: {stats.FinalAttackSpeed}, 반복 주기: {interval}초)");

        if (float.IsInfinity(interval) || interval <= 0)
        {
            Debug.LogError($"[{GetType().Name}] 공격 주기가 비정상적({interval})이므로 공격을 시작할 수 없습니다!");
            return;
        }

        InvokeRepeating(nameof(PerformAttack), 0f, interval);
    }

    private void PerformAttack()
    {
        if (cardManager == null) return;
        if (cardManager.activeCard == null) return;
        if (effectExecutor == null) return;

        // 자신의 정보(stats, firePoint)를 인자로 넘겨줌
        effectExecutor.Execute(cardManager.activeCard, stats, firePoint);
    }

    void FixedUpdate()
    {
        if (stats == null || rb == null) return;
        Vector2 finalVelocity = moveInput * stats.FinalMoveSpeed;
        rb.velocity = finalVelocity;
    }

    private void OnMove(Vector2 input)
    {
        moveInput = input;
    }

    public void Heal(float amount)
    {
        if (stats != null)
        {
            Debug.Log($"[{GetType().Name}] {amount}만큼 체력을 회복합니다.");
            stats.Heal(amount);
        }
    }
}

--- 파일명: PlayerInitializer.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Gameplay/PlayerInitializer.cs) ---
// --- 파일 위치: Assets/1.Scripts/Gameplay/PlayerInitializer.cs ---

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;

/// <summary>
/// 게임 시작 시 플레이어 오브젝트를 초기화하는 역할을 담당합니다. (리팩토링 버전)
/// 이 클래스는 필요한 데이터와 컴포넌트를 가져와서, 각 컴포넌트가 스스로를 초기화하도록
/// 메시지를 전달하는 '지휘자(Coordinator)'의 역할에 집중합니다.
/// </summary>
public class PlayerInitializer : MonoBehaviour
{
    [Header("테스트용 시작 카드 목록")]
    [Tooltip("캐릭터 데이터(SO)에 시작 카드가 설정되어 있으면, 이 목록은 무시됩니다.")]
    [SerializeField] private List<CardDataSO> testStartingCards;

    void Start()
    {
        EventSystem.current.SetSelectedGameObject(null);

        // --- 1. 공통 초기화 (매 라운드 실행) ---
        var playerStats = GetComponent<CharacterStats>();
        var playerController = GetComponent<PlayerController>();
        var gameManager = ServiceLocator.Get<GameManager>();
        var playerSpriteRenderer = GetComponent<SpriteRenderer>();

        var debugManager = ServiceLocator.Get<DebugManager>();
        if (debugManager != null)
        {
            debugManager.RegisterPlayer(playerStats);
        }

        // GameManager에 저장된 캐릭터 정보를 불러옵니다.
        CharacterDataSO characterToLoad = gameManager.SelectedCharacter ?? ServiceLocator.Get<DataManager>().GetCharacter(CharacterIDs.Warrior);
        if (characterToLoad == null)
        {
            Debug.LogError("CRITICAL: 적용할 캐릭터 데이터를 찾을 수 없습니다!");
            return;
        }

        // 캐릭터의 기본 능력치와 외형을 먼저 적용합니다.
        playerStats.stats = characterToLoad.baseStats;
        playerSpriteRenderer.sprite = characterToLoad.illustration;

        // --- 2. 분기: 첫 라운드 vs 이후 라운드 ---
        if (gameManager.isFirstRound)
        {
            var progressionManager = ServiceLocator.Get<ProgressionManager>();

            // 영구 스탯 및 분배 포인트 적용 (게임 시작 시 한 번만)
            CharacterPermanentStats permanentStats = progressionManager.GetPermanentStatsFor(characterToLoad.characterId);
            playerStats.ApplyPermanentStats(permanentStats);
            playerStats.ApplyAllocatedPoints(gameManager.AllocatedPoints, permanentStats);


            if (ServiceLocator.Get<CardManager>() != null)
            {
                ServiceLocator.Get<CardManager>().LinkToNewPlayer(playerStats);
            }

            EquipStartingItems(characterToLoad);


            gameManager.isFirstRound = false;
        }
        else
        {
            // CardManager와 ArtifactManager에 새로운 플레이어 정보를 연결하고, 스탯 재계산을 요청합니다.
            if (ServiceLocator.Get<CardManager>() != null)
            {
                ServiceLocator.Get<CardManager>().LinkToNewPlayer(playerStats);
            }
            if (ServiceLocator.Get<ArtifactManager>() != null)
            {
                ServiceLocator.Get<ArtifactManager>().LinkToNewPlayer(playerStats);
            }
        }

        // --- 3. 공통 마무리 (매 라운드 실행) ---
        // 최종 스탯 계산 (카드, 유물 등 모든 보너스 합산)
        playerStats.CalculateFinalStats();
        
        // 체력을 최대로 회복
        playerStats.currentHealth = playerStats.FinalHealth;

        // 게임플레이 루프 시작
        if (ServiceLocator.Get<CardManager>() != null) ServiceLocator.Get<CardManager>().StartCardSelectionLoop();
        if (playerController != null) playerController.StartAutoAttackLoop();
    }

    /// <summary>
    /// 캐릭터의 시작 카드와 유물을 장착합니다.
    /// </summary>
    private void EquipStartingItems(CharacterDataSO characterData)
    {
        Debug.Log($"--- [100% 검증] 3. PlayerInitializer 테스트용 카드 수: {testStartingCards.Count} ---");
        // 시작 카드 결정 및 장착
        List<CardDataSO> cardsToEquip = new List<CardDataSO>();
        if (testStartingCards != null && testStartingCards.Count > 0)
        {
            cardsToEquip.AddRange(testStartingCards); // 1순위: 테스트용 카드
        }
        else if (characterData.startingCard != null)
        {
            cardsToEquip.Add(characterData.startingCard); // 2순위: 캐릭터 데이터의 시작 카드
        }

        if (cardsToEquip.Count > 0 && ServiceLocator.Get<CardManager>() != null)
        {
            foreach (var card in cardsToEquip)
            {
                if (card != null)
                {
                    ServiceLocator.Get<CardManager>().AddCard(card);
                    ServiceLocator.Get<CardManager>().Equip(card);
                }
            }
        }

        // 시작 유물 장착
        if (characterData.startingArtifacts != null && characterData.startingArtifacts.Count > 0)
        {
            if (ServiceLocator.Get<ArtifactManager>() != null)
            {
                foreach (var artifact in characterData.startingArtifacts)
                {
                    if (artifact != null) ServiceLocator.Get<ArtifactManager>().EquipArtifact(artifact);
                }
            }
        }
    }
}


--- 파일명: PointAllocationManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Gameplay/PointAllocationManager.cs) ---
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class PointAllocationManager : MonoBehaviour
{
    [Header("UI 참조")]
    [SerializeField] private PointAllocationResultUI resultUI;
    [SerializeField] private TMP_InputField pointsToInvestInput_Actual;
    [SerializeField] private Button inputActivationButton;
    [SerializeField] private TextMeshProUGUI inputActivationButtonText;
    [SerializeField] private Button confirmButton;
    [SerializeField] private Button backButton;
    [SerializeField] private TextMeshProUGUI totalPointsText;

    [Header("코어 로직 참조")]
    [SerializeField] private MapGenerator mapGenerator;

    private CharacterDataSO selectedCharacter;
    private int totalCharacterPoints;

    private void Awake()
    {
        inputActivationButton.onClick.AddListener(ActivateInputMode);
        confirmButton.onClick.AddListener(OnConfirmAllocationClicked);
        backButton.onClick.AddListener(OnBackClicked);
        pointsToInvestInput_Actual.onEndEdit.AddListener(DeactivateInputMode);
    }

    void Start()
    {
        InitializeAllocation();
        if (resultUI != null)
        {
            resultUI.gameObject.SetActive(true);
            resultUI.UpdateDisplay(selectedCharacter.baseStats, null);
        }
        pointsToInvestInput_Actual.gameObject.SetActive(false);

        if (mapGenerator == null)
        {
            Debug.LogError("[PointAllocationManager] MapGenerator 참조가 설정되지 않았습니다! Inspector에서 연결해주세요.");
        }
    }

    private void OnConfirmAllocationClicked()
    {
        if (!int.TryParse(pointsToInvestInput_Actual.text, out int allocatedPoints))
        {
            allocatedPoints = 0;
        }

        // --- ServiceLocator를 통해 필요한 매니저들을 미리 가져옵니다. ---
        var gameManager = ServiceLocator.Get<GameManager>();
        var progressionManager = ServiceLocator.Get<ProgressionManager>();
        var mapManager = ServiceLocator.Get<MapManager>();
        var campaignManager = ServiceLocator.Get<CampaignManager>();

        gameManager.AllocatedPoints = allocatedPoints;

        CharacterPermanentStats permanentStats = progressionManager.GetPermanentStatsFor(selectedCharacter.characterId);
        Dictionary<StatType, int> distributedPoints = CalculateDistributedPoints(allocatedPoints, permanentStats);
        resultUI.UpdateDisplay(selectedCharacter.baseStats, distributedPoints);

        confirmButton.interactable = false;
        backButton.interactable = false;
        inputActivationButton.interactable = false;

        Debug.Log("[PointAllocationManager] 확인 버튼 클릭됨. 맵 생성을 시작합니다.");

        // 1. 맵 데이터를 먼저 생성하고 MapManager를 초기화합니다.
        if (mapGenerator != null && mapManager != null)
        {
            List<MapNode> mapData = mapGenerator.Generate();
            mapManager.InitializeMap(mapData, mapGenerator.MapWidth, mapGenerator.MapHeight);
            Debug.Log("[PointAllocationManager] MapManager 초기화 완료.");
        }
        else
        {
            Debug.LogError("[PointAllocationManager] MapGenerator 또는 MapManager 참조가 없어 맵을 생성할 수 없습니다!");
            confirmButton.interactable = true;
            backButton.interactable = true;
            inputActivationButton.interactable = true;
            return;
        }

        // 2. 캠페인 매니저를 통해 이번에 플레이할 캠페인을 미리 선택합니다.
        CampaignDataSO selectedCampaign = campaignManager.SelectRandomCampaign();
        if (selectedCampaign == null)
        {
            confirmButton.interactable = true;
            backButton.interactable = true;
            inputActivationButton.interactable = true;
            return;
        }

        // 3. 선택된 캠페인의 첫 번째 라운드 데이터를 가져옵니다.
        MapNode firstNode = mapManager.GetReachableNodes().FirstOrDefault();
        RoundDataSO firstRoundData = campaignManager.GetRoundDataForNode(firstNode);
        if (firstRoundData == null)
        {
            Debug.LogError("첫 라운드 데이터를 찾을 수 없어 프리로딩을 시작할 수 없습니다!");
            confirmButton.interactable = true;
            backButton.interactable = true;
            inputActivationButton.interactable = true;
            return;
        }

        // 4. GameManager의 준비 코루틴에 첫 라운드 데이터를 전달하여 프리로딩을 시작합니다.
        StartCoroutine(gameManager.PreloadAssetsForRound(firstRoundData, OnPreloadComplete));
    }

    private void OnPreloadComplete()
    {
        Debug.Log("[PointAllocationManager] 프리로딩 완료 신호를 받았습니다. Gameplay 씬으로 전환합니다.");
        ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.Gameplay);
    }

    public void ActivateInputMode()
    {
        inputActivationButton.gameObject.SetActive(false);
        pointsToInvestInput_Actual.gameObject.SetActive(true);
        EventSystem.current.SetSelectedGameObject(pointsToInvestInput_Actual.gameObject);
        pointsToInvestInput_Actual.ActivateInputField();
    }

    private void DeactivateInputMode(string text)
    {
        ValidateInputValue();
        string correctedText = pointsToInvestInput_Actual.text;
        if (string.IsNullOrEmpty(correctedText))
        {
            inputActivationButtonText.text = "포인트 입력...";
        }
        else
        {
            inputActivationButtonText.text = correctedText;
        }
        pointsToInvestInput_Actual.gameObject.SetActive(false);
        inputActivationButton.gameObject.SetActive(true);
        EventSystem.current.SetSelectedGameObject(inputActivationButton.gameObject);
    }

    private void InitializeAllocation()
    {
                        selectedCharacter = ServiceLocator.Get<GameManager>().SelectedCharacter ?? ServiceLocator.Get<DataManager>().GetCharacter(CharacterIDs.Warrior);
        totalCharacterPoints = selectedCharacter.initialAllocationPoints;
        if (totalPointsText != null) totalPointsText.text = $"Total Points: {totalCharacterPoints}";
    }

    private void ValidateInputValue()
    {
        if (!string.IsNullOrEmpty(pointsToInvestInput_Actual.text) && int.TryParse(pointsToInvestInput_Actual.text, out int points))
        {
            if (points > totalCharacterPoints)
            {
                pointsToInvestInput_Actual.text = totalCharacterPoints.ToString();
            }
            else if (points < 0)
            {
                pointsToInvestInput_Actual.text = "0";
            }
        }
    }

    public void OnBackClicked()
    {
        ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.CharacterSelect);
    }

    private Dictionary<StatType, int> CalculateDistributedPoints(int pointsToDistribute, CharacterPermanentStats permStats)
    {
        var pointCounts = new Dictionary<StatType, int>();
        foreach (StatType type in System.Enum.GetValues(typeof(StatType))) pointCounts[type] = 0;
        List<StatType> availableStats = permStats.GetUnlockedStats();
        if (availableStats.Count == 0) return pointCounts;
        for (int i = 0; i < pointsToDistribute; i++)
        {
            StatType targetStat = availableStats[Random.Range(0, availableStats.Count)];
            pointCounts[targetStat]++;
        }
        return pointCounts;
    }
}

--- 파일명: PrefabProvider.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Gameplay/PrefabProvider.cs) ---
// PrefabProvider.cs (최종 수정안)

using UnityEngine;
using System.Collections.Generic;

// ▼▼▼ [1] 프리팹과 개수를 묶는 클래스를 여기에 추가합니다. ▼▼▼
[System.Serializable]
public class PreloadItem
{
    public GameObject prefab;
    [Tooltip("미리 생성해 둘 개수입니다.")]
    public int count;
}

public class PrefabProvider : MonoBehaviour
{
    // ▼▼▼ [2] 리스트의 타입을 List<GameObject>에서 List<PreloadItem>으로 변경합니다. ▼▼▼
    [Header("공용 프리팹 목록 (Damage Text 등)")]
    [SerializeField] private List<PreloadItem> commonPreloadItems;

    private readonly Dictionary<string, GameObject> prefabDictionary = new Dictionary<string, GameObject>();

    void Awake()
    {
        ServiceLocator.Register<PrefabProvider>(this);
        
        // commonPreloadItems 리스트를 기반으로 딕셔너리를 채웁니다.
        if (commonPreloadItems != null)
        {
            foreach (var item in commonPreloadItems)
            {
                if (item.prefab != null && !prefabDictionary.ContainsKey(item.prefab.name))
                {
                    // GetPrefab을 위해 이름-프리팹 쌍을 저장합니다.
                    prefabDictionary.Add(item.prefab.name, item.prefab);
                }
            }
        }
        Debug.Log($"[{GetType().Name}] 공용 프리팹 딕셔너리 초기화 완료. 총 {prefabDictionary.Count}개의 프리팹이 등록되었습니다.");
    }

    // GetPrefab 함수는 기존과 동일하게 유지됩니다.
    public GameObject GetPrefab(string name)
    {
        if (string.IsNullOrEmpty(name)) return null;
        prefabDictionary.TryGetValue(name, out GameObject prefab);
        if (prefab == null)
        {
            Debug.LogError($"[PrefabProvider] 프리팹 딕셔너리에서 '{name}'을(를) 찾을 수 없습니다.");
        }
        return prefab;
    }

    // ▼▼▼ [3] GameManager가 프리팹과 개수 정보를 함께 가져갈 수 있도록 새 함수를 추가합니다. ▼▼▼
    public List<PreloadItem> GetCommonPreloadItems() => commonPreloadItems;
}

--- 파일명: RewardManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Gameplay/RewardManager.cs) ---
// 파일 경로: Assets/1.Scripts/Gameplay/RewardManager.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// 게임 플레이 중 발생하는 모든 '보상' 관련 로직을 총괄하는 중앙 관리자입니다.
/// 라운드 승리/패배 여부를 기록하고, 카드 보상 큐를 관리하며, 보상 UI에 필요한 데이터를 제공합니다.
/// </summary>
public class RewardManager : MonoBehaviour
{
    // --- Public Properties --- //

    /// <summary>
    /// 마지막으로 플레이한 라운드에서 승리했는지 여부를 나타냅니다. (현재는 카드 보상에 직접적인 영향을 주지 않지만, 추후 다른 보상 시스템을 위해 유지됩니다.)
    /// </summary>
    public bool LastRoundWon { get; set; } = true;

    /// <summary>
    /// 현재 플레이어가 카드 보상 선택을 완료했는지 여부를 나타내는 중요한 상태 플래그입니다.
    /// true: 보상 선택이 끝났거나, 받을 보상이 없는 상태. (맵 노드 선택 가능)
    /// false: 보상 선택이 진행 중인 상태. (맵 노드 선택 불가, '보상 페이지로' 버튼 활성화)
    /// </summary>
    public bool IsRewardSelectionComplete { get; private set; } = true;


    // --- Private Fields --- //

    /// <summary>
    /// 제시할 카드 보상 목록을 순서대로 저장하는 큐(Queue)입니다.
    /// </summary>
    private Queue<List<CardDataSO>> cardRewardQueue = new Queue<List<CardDataSO>>();


    // --- Events --- //

    /// <summary>
    /// 처리할 새로운 카드 보상이 준비되었을 때 CardRewardUIManager에 알리는 static 이벤트입니다.
    /// </summary>
    public static event System.Action<List<CardDataSO>> OnCardRewardReady;

    /// <summary>
    /// 처리할 보상이 없어 즉시 맵 선택으로 건너뛰어야 할 때 UI에 알리는 static 이벤트입니다.
    /// </summary>
    public static event System.Action OnRewardSkipped;

    // --- Unity Lifecycle Methods --- //

    void Awake()
    {
        // ServiceLocator에 자기 자신을 등록하여 다른 시스템에서 접근할 수 있도록 합니다.
        ServiceLocator.Register<RewardManager>(this);
        // 씬이 전환되어도 파괴되지 않도록 설정합니다.
        DontDestroyOnLoad(gameObject);
    }

    // --- Public Methods --- //

    /// <summary>
    /// 새로운 카드 보상 목록을 큐의 맨 뒤에 추가합니다.
    /// </summary>
    /// <param name="cardChoices">플레이어에게 보여줄 카드 선택지 목록</param>
    public void EnqueueReward(List<CardDataSO> cardChoices)
    {
        cardRewardQueue.Enqueue(cardChoices);
        Debug.Log($"[RewardManager] 새로운 카드 보상이 큐에 추가되었습니다. 현재 대기 중인 보상 수: {cardRewardQueue.Count}");
    }

    /// <summary>
    /// 처리 대기 중인 보상이 있는지 확인합니다.
    /// </summary>
    /// <returns>큐에 보상이 하나 이상 있으면 true, 아니면 false를 반환합니다.</returns>
    public bool HasPendingRewards()
    {
        return cardRewardQueue.Count > 0;
    }

    /// <summary>
    /// 큐에서 다음 보상을 꺼내어 처리하도록 이벤트를 발생시킵니다.
    /// </summary>
    public void ProcessNextReward()
    {
        Debug.Log("[RewardManager] ProcessNextReward() 호출됨.");
        if (cardRewardQueue.Count > 0)
        {
            // [핵심 로직] 보상 처리를 시작하므로, '선택 완료' 상태를 '진행 중' (false)으로 변경합니다.
            // 이 상태는 RouteSelectionController가 '보상 페이지로' 버튼을 활성화하는 데 사용됩니다.
            IsRewardSelectionComplete = false;

            List<CardDataSO> nextReward = cardRewardQueue.Dequeue();
            Debug.Log($"[RewardManager] 다음 보상을 처리합니다. 남은 보상 수: {cardRewardQueue.Count}. 'IsRewardSelectionComplete' 상태를 [false]로 설정.");

            // UI가 이벤트를 구독하고 있다면, 카드 선택지를 전달하여 화면에 표시하도록 합니다.
            Debug.Log("[RewardManager] OnCardRewardReady 이벤트 발생 시도.");
            OnCardRewardReady?.Invoke(nextReward);
        }
        else
        {
            // 처리할 보상이 없는 경우, 바로 완료 상태로 설정하고 '스킵' 이벤트를 발생시킵니다.
            IsRewardSelectionComplete = true;
            Debug.LogWarning("[RewardManager] 처리할 보상이 없어 즉시 맵 선택으로 건너뜁니다. 'IsRewardSelectionComplete' 상태를 [true]로 설정.");
            OnRewardSkipped?.Invoke();
        }
    }

    /// <summary>
    /// 플레이어가 카드 선택(획득, 합성, 스킵)을 완료했을 때 호출됩니다.
    /// </summary>
    public void CompleteRewardSelection()
    {
        // [핵심 로직] 보상 선택이 모두 끝났으므로, 상태를 '완료' (true)로 변경합니다.
        // 이 상태는 RouteSelectionController가 '보상 페이지로' 버튼을 비활성화하는 데 사용됩니다.
        IsRewardSelectionComplete = true;
        Debug.Log("[RewardManager] 카드 보상 선택이 완료되었습니다. 'IsRewardSelectionComplete' 상태를 [true]로 설정.");
    }
}

--- 파일명: RoundManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Gameplay/RoundManager.cs) ---
using System.Collections;
using UnityEngine;
using System.Collections.Generic; // [1] using 문 추가
using System.Linq;                 // [2] using 문 추가

/// <summary>
/// 개별 전투 라운드의 시작, 진행, 종료를 관리하는 클래스입니다.
/// 몬스터 스폰, 킬 카운트, 제한 시간 등 라운드와 관련된 모든 핵심 로직을 담당합니다.
/// </summary>
public class RoundManager : MonoBehaviour
{
    // --- Events --- //
    public static event System.Action<RoundDataSO> OnRoundStarted;
    public static event System.Action<int, int> OnKillCountChanged;
    public static event System.Action<float> OnTimerChanged;
    public static event System.Action<bool> OnRoundEnded; // bool: 승리 여부

    // ▼▼▼ [3] Inspector에서 보상 카드 수를 설정할 변수 추가 ▼▼▼
    [Header("보상 설정")]
    [SerializeField] private int numberOfRewardChoices = 3;

    // --- Private State Fields --- //
    private MonsterSpawner monsterSpawner;
    private RoundDataSO currentRoundData;
    private int killCount;
    private float roundTimer;
    private bool isRoundActive;
    private Coroutine roundTimerCoroutine; // [1] 코루틴을 저장할 변수 추가

    // --- Unity Lifecycle Methods --- //
    void Awake()
    {
        monsterSpawner = GetComponent<MonsterSpawner>();
        if (monsterSpawner == null)
        {
            Debug.LogError($"[{GetType().Name}] CRITICAL: MonsterSpawner 컴포넌트를 찾을 수 없습니다! 몬스터가 스폰되지 않습니다.", this.gameObject);
        }
    }

    // ▼▼▼ [2] OnEnable, OnDisable 함수를 추가/수정하여 GameManager의 이벤트를 구독 ▼▼▼
    void OnEnable()
    {
        MonsterController.OnMonsterDied += HandleMonsterDied;
        
        // GameManager가 존재할 때만 이벤트를 구독하도록 예외 처리
        var gameManager = ServiceLocator.Get<GameManager>();
        if (gameManager != null)
        {
            gameManager.OnGameStateChanged += HandleGameStateChanged;
        }
    }

    void OnDisable()
    {
        MonsterController.OnMonsterDied -= HandleMonsterDied;

        var gameManager = ServiceLocator.Get<GameManager>();
        if (gameManager != null)
        {
            gameManager.OnGameStateChanged -= HandleGameStateChanged;
        }
    }
    
    // --- Public Methods --- //

    /// <summary>
    /// 새로운 라운드를 시작합니다.
    /// </summary>
    /// <param name="roundData">시작할 라운드의 데이터</param>
    public IEnumerator StartRound(RoundDataSO roundData)
    {
        if (isRoundActive)
        {
            Debug.LogWarning($"[{GetType().Name}] 경고: 이미 라운드가 진행 중일 때 StartRound가 호출되었습니다. 이전 라운드를 강제 종료하고 새 라운드를 시작합니다.");
            yield return StartCoroutine(EndRoundCoroutine(false));
        }

        currentRoundData = roundData;
        Debug.Log($"[{GetType().Name}] 새로운 라운드 시작: '{currentRoundData.name}' (목표 킬: {currentRoundData.killGoal}, 제한 시간: {currentRoundData.roundDuration}초)");

        // 라운드 상태 초기화
        killCount = 0;
        roundTimer = currentRoundData.roundDuration;
        isRoundActive = true;

        // 이벤트 구독
        // MonsterController.OnMonsterDied += HandleMonsterDied; // <-- 이 줄을 제거하세요!

        // UI 및 다른 시스템에 라운드 시작 알림
        OnRoundStarted?.Invoke(currentRoundData);

        // 몬스터 스폰 시작
        if (monsterSpawner != null)
        {
            // [수정] 사용자님이 공유해주신 RoundDataSO의 정확한 변수명인 'waves'를 사용합니다.
            monsterSpawner.StartSpawning(currentRoundData.waves);
        }

        // 라운드 타이머 코루틴 시작
        roundTimerCoroutine = StartCoroutine(RoundTimerCoroutine()); // 코루틴 참조를 저장
        yield return roundTimerCoroutine;
    }

    // --- Coroutines --- //

    private IEnumerator RoundTimerCoroutine()
    {
        Debug.Log($"[{GetType().Name}] 라운드 타이머 코루틴이 시작되었습니다.");
        while (roundTimer > 0 && isRoundActive)
        {
            roundTimer -= Time.deltaTime;
            OnTimerChanged?.Invoke(roundTimer);
            yield return null;
        }

        if (isRoundActive)
        {
            Debug.Log($"[{GetType().Name}] 시간 초과. 라운드를 종료합니다.");
            StartCoroutine(EndRoundCoroutine(false));
        }
    }

    private IEnumerator EndRoundCoroutine(bool wasKillGoalReached)
    {
        if (!isRoundActive) yield break;

        isRoundActive = false;
        roundTimerCoroutine = null; // 코루틴이 끝났으므로 참조를 비워줍니다.
        Debug.Log($"[{GetType().Name}] 라운드 종료 코루틴 시작. (승리: {wasKillGoalReached})");

        MonsterController.OnMonsterDied -= HandleMonsterDied;
        OnRoundEnded?.Invoke(wasKillGoalReached);

        if (monsterSpawner != null)
        {
            monsterSpawner.StopSpawning();
        }

        var rewardManager = ServiceLocator.Get<RewardManager>();
        if (rewardManager != null)
        {
            rewardManager.LastRoundWon = wasKillGoalReached;
            Debug.Log($"[{GetType().Name}] RewardManager에 라운드 결과({(wasKillGoalReached ? "승리" : "패배")})를 기록했습니다.");

        // ============ [핵심 추가 기능: 승리 시 보상 생성] ============
        if (wasKillGoalReached)
        {
            Debug.Log($"[{GetType().Name}] 라운드 승리! 카드 보상을 생성합니다.");
            var dataManager = ServiceLocator.Get<DataManager>();
            if (dataManager != null)
            {
                List<CardDataSO> allCards = dataManager.GetAllCards();
                List<CardDataSO> rewardChoices = new List<CardDataSO>();
                
                // 카드 데이터가 충분한지 확인
                if (allCards.Count >= numberOfRewardChoices)
                {
                    // 가중치에 따라 랜덤 카드 선택 (중복 없음)
                    List<CardDataSO> selectableCards = new List<CardDataSO>(allCards);
                    for (int i = 0; i < numberOfRewardChoices; i++)
                    {
                        if (selectableCards.Count == 0) break;

                        float totalWeight = selectableCards.Sum(card => card.rewardAppearanceWeight);

                        // ▼▼▼▼▼ [핵심 수정] 이 부분을 추가하세요 ▼▼▼▼▼
                        // 만약 모든 카드의 가중치가 0이라면, 가중치 없이 완전 랜덤으로 하나를 고릅니다.
                        if (totalWeight <= 0)
                        {
                            int randomIndex = Random.Range(0, selectableCards.Count);
                            rewardChoices.Add(selectableCards[randomIndex]);
                            selectableCards.RemoveAt(randomIndex);
                            continue; // 다음 카드를 뽑기 위해 for문의 다음 루프로 넘어갑니다.
                        }
                        // ▲▲▲▲▲ [여기까지 추가] ▲▲▲▲▲

                        float randomPoint = Random.Range(0, totalWeight);
                        float currentWeight = 0f;
                        CardDataSO selectedCard = null;

                        foreach (var card in selectableCards)
                        {
                            currentWeight += card.rewardAppearanceWeight;
                            if (randomPoint <= currentWeight)
                            {
                                selectedCard = card;
                                break;
                            }
                        }

                        // 만약 부동소수점 오류 등으로 선택이 안된 경우 마지막 카드를 선택
                        if (selectedCard == null && selectableCards.Count > 0)
                        {
                            selectedCard = selectableCards.Last();
                        }

                        if (selectedCard != null)
                        {
                            rewardChoices.Add(selectedCard);
                            selectableCards.Remove(selectedCard);
                        }
                    }
                }

                // 생성된 보상이 있으면 RewardManager의 대기열에 추가
                if (rewardChoices.Count > 0)
                {
                    rewardManager.EnqueueReward(rewardChoices);
                }
                else
                {
                    Debug.LogWarning($"[{GetType().Name}] 보상으로 제시할 카드를 생성하지 못했습니다. (카드 데이터 부족 가능성)");
                }
            }
        }
        else
        {
            Debug.Log($"[{GetType().Name}] 라운드 패배. 카드 보상을 생성하지 않습니다.");
        }
        // =============================================================
        }
        else
        {
            Debug.LogError($"[{GetType().Name}] CRITICAL: RewardManager를 찾을 수 없어 라운드 결과를 기록할 수 없습니다!");
        }

        // PoolManager를 통해 활성화된 모든 오브젝트(몬스터, 총알 등)를 정리합니다.
        var poolManager = ServiceLocator.Get<PoolManager>();
        if (poolManager != null)
        {
            poolManager.ClearAllActiveObjects();
        }

        Debug.Log($"[{GetType().Name}] GameManager 상태 변경 요청: {GameManager.GameState.Reward}");
        ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.Reward);
    }

    // --- Event Handlers --- //

    // ▼▼▼ [4] GameManager의 상태 변경을 감지할 핸들러 함수 추가 ▼▼▼
    private void HandleGameStateChanged(GameManager.GameState newState)
    {
        // 게임 상태가 '게임오버'로 바뀌면, 라운드 매니저의 모든 활동을 즉시 중단시킵니다.
        if (newState == GameManager.GameState.GameOver)
        {
            Debug.Log($"[{GetType().Name}] 게임오버 상태를 감지했습니다. 라운드 타이머를 강제 종료합니다.");
            isRoundActive = false;
            
            // 실행 중인 타이머 코루틴이 있다면 중지시킵니다.
            if (roundTimerCoroutine != null)
            {
                StopCoroutine(roundTimerCoroutine);
                roundTimerCoroutine = null;
            }
        }
    }

    // --- Event Handlers --- //

    private void HandleMonsterDied(MonsterController monster)
    {
        if (!isRoundActive) return;

        killCount++;
        Debug.Log($"[{GetType().Name}] 몬스터 처치. 현재 킬 수: {killCount}/{currentRoundData.killGoal}");
        OnKillCountChanged?.Invoke(killCount, currentRoundData.killGoal);

        if (killCount >= currentRoundData.killGoal)
        {
            Debug.Log($"[{GetType().Name}] 목표 킬 수를 달성했습니다! 라운드를 승리로 종료합니다.");
            StartCoroutine(EndRoundCoroutine(true));
        }
    }
}

--- 파일명: StatusEffectManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/Gameplay/StatusEffectManager.cs) ---
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// 게임 내 모든 캐릭터(플레이어, 몬스터)의 상태 효과(버프, 디버프)를 관리하는 클래스입니다.
/// </summary>
public class StatusEffectManager : MonoBehaviour
{
    private readonly Dictionary<GameObject, List<StatusEffect>> activeEffects = new Dictionary<GameObject, List<StatusEffect>>();
    private readonly List<StatusEffect> effectsToRemove = new List<StatusEffect>();
    private readonly List<GameObject> targetsToRemove = new List<GameObject>();

    void Awake()
    {
        ServiceLocator.Register<StatusEffectManager>(this);
    }

    void Update()
    {
        if (activeEffects.Count == 0) return;

        effectsToRemove.Clear();
        foreach (var entry in activeEffects.ToList()) // 순회 중 수정을 위해 ToList() 사용
        {
            GameObject target = entry.Key;
            if (target == null) // 대상이 파괴된 경우
            {
                targetsToRemove.Add(target);
                continue;
            }

            List<StatusEffect> effectsOnTarget = entry.Value;

            for (int i = effectsOnTarget.Count - 1; i >= 0; i--)
            {
                StatusEffect effect = effectsOnTarget[i];

                if (effect.effectData.damageOverTime > 0)
                {
                    if (target.CompareTag(Tags.Monster))
                    {
                        var monster = target.GetComponentInChildren<MonsterController>();
                        if (monster != null)
                        {
                            float damageThisFrame = effect.effectData.damageOverTime * monster.maxHealth * Time.deltaTime;
                            monster.TakeDamage(damageThisFrame);
                        }
                    }
                }

                effect.duration -= Time.deltaTime;
                if (effect.duration <= 0)
                {
                    effectsToRemove.Add(effect);
                }
            }
        }

        if (effectsToRemove.Count > 0)
        {
            foreach (StatusEffect effect in effectsToRemove) { RemoveStatusEffect(effect); }
        }

        if (targetsToRemove.Count > 0)
        {
            foreach (GameObject t in targetsToRemove) { activeEffects.Remove(t); }
            targetsToRemove.Clear();
        }
    }

    public void ApplyStatusEffect(GameObject target, StatusEffectDataSO effectData)
    { 
        if (target == null || effectData == null) return;

        StatusEffect newEffect = new StatusEffect(target, effectData);

        if (!activeEffects.ContainsKey(target))
        {
            activeEffects[target] = new List<StatusEffect>();
        }

        activeEffects[target].Add(newEffect);
        newEffect.ApplyEffect();
    }

    private void RemoveStatusEffect(StatusEffect effect)
    {
        if (effect == null || effect.target == null) return;

        if (activeEffects.TryGetValue(effect.target, out var effectList))
        {
            effect.RemoveEffect();
            effectList.Remove(effect);
        }
    }
}

/// <summary>
/// 활성화된 개별 상태 효과의 인스턴스 정보를 담는 클래스입니다.
/// </summary>
public class StatusEffect
{
    public GameObject target;
    public StatusEffectDataSO effectData;
    public float duration;

    public StatusEffect(GameObject target, StatusEffectDataSO effectData)
    {
        this.target = target;
        this.effectData = effectData;
        this.duration = effectData.duration;
    }

    // 이 효과가 적용될 때 즉시 실행되는 로직 (주로 스탯 버프/디버프)
    public void ApplyEffect()
    {
        if (target.TryGetComponent<CharacterStats>(out var stats))
        {
            effectData.ApplyEffect(stats);
        }
    }

    // 이 효과가 제거될 때 실행되는 로직 (스탯 원상복구)
    public void RemoveEffect()
    {
        if (target.TryGetComponent<CharacterStats>(out var stats))
        {
            effectData.RemoveEffect(stats);
        }
    }
}

--- 파일명: AutoFocusScroller.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/AutoFocusScroller.cs) ---
// : Assets/1/Scripts/UI/AutoFocusScroller.cs

using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;

public class AutoFocusScroller : MonoBehaviour
{
    [Header(" ")]
    [SerializeField] private ScrollRect mapScrollRect;
    [SerializeField] private MapView mapView;

    [Header("ũ ")]
    [SerializeField] private float edgeScrollSpeed = 1.0f;
    [SerializeField] private float scrollBoundaryOffset = 50f;

    private Vector3[] viewportCorners = new Vector3[4];

    void Update()
    {
        if (!gameObject.activeInHierarchy) return;

        GameObject rawSelectedObject = EventSystem.current.currentSelectedGameObject;
        if (rawSelectedObject == null) return;


        GameObject closestNode = mapView.FindClosestNodeTo(rawSelectedObject.transform.position);
        if (closestNode == null) return;


        mapScrollRect.viewport.GetWorldCorners(viewportCorners);
        float viewportTopY = viewportCorners[1].y;
        float viewportBottomY = viewportCorners[0].y;

        float nodeY = closestNode.transform.position.y;

        float topBoundary = viewportTopY - scrollBoundaryOffset;
        float bottomBoundary = viewportBottomY + scrollBoundaryOffset;
        
        bool shouldScrollUp = nodeY > topBoundary;
        bool shouldScrollDown = nodeY < bottomBoundary;

        if (shouldScrollUp)
        {
            // --- [ DELTA:  ߵ] ---
            Scroll(1);
        }
        else if (shouldScrollDown)
        {
            // --- [ DELTA:  ߵ] ---
            Scroll(-1);
        }
    }

    private void Scroll(int direction)
    {
        float currentScrollPos = mapScrollRect.verticalNormalizedPosition;
        float newScrollPos = currentScrollPos + (direction * edgeScrollSpeed * Time.unscaledDeltaTime);
        newScrollPos = Mathf.Clamp01(newScrollPos);

        mapScrollRect.verticalNormalizedPosition = newScrollPos;
    }
}

--- 파일명: CardDisplay.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/CardDisplay.cs) ---
// CardDisplay.cs (최종 수정본)
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using UnityEngine.Events;

// [수정] 이벤트가 CardDataSO 대신 CardDisplay 자신을 전달하도록 변경합니다.
[System.Serializable]
public class CardSelectedEvent : UnityEvent<CardDisplay> { }

public class CardDisplay : MonoBehaviour
{
    [Header("UI 요소 참조")]
    [SerializeField] private TextMeshProUGUI nameText;
    [SerializeField] private TextMeshProUGUI descriptionText;
    [SerializeField] private Image cardBackgroundImage;
    [SerializeField] private Image cardIconImage;
    [SerializeField] private Image rarityImage;
    [SerializeField] private Image highlightBorder;

    public Button selectButton;
    public CardSelectedEvent OnCardSelected;

    private CardDataSO currentCard;
    public CardDataSO CurrentCard => currentCard;

    public CardDataSO GetCurrentCard()
    {
        return currentCard;
    }

    public void Setup(CardDataSO cardData)
    {
        currentCard = cardData;

        if (nameText != null) nameText.text = cardData.cardName;
        if (descriptionText != null) descriptionText.text = cardData.effectDescription;
        if (cardIconImage != null && cardData.cardIcon != null)
        {
            cardIconImage.sprite = cardData.cardIcon;
        }
        if (rarityImage != null)
        {
            rarityImage.sprite = UIGraphicsDB.Instance.GetRaritySprite(cardData.rarity);
        }
        if (selectButton != null)
        {
            selectButton.onClick.RemoveAllListeners();
            // [수정] 이벤트 발생 시 카드 데이터(currentCard) 대신 CardDisplay 컴포넌트(this)를 전달합니다.
            selectButton.onClick.AddListener(() => OnCardSelected.Invoke(this));
        }
    }

    public void SetHighlight(bool isSelected)
    {
        if (highlightBorder != null)
        {
            highlightBorder.gameObject.SetActive(isSelected);
        }
    }
}

--- 파일명: CardRewardUIManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/CardRewardUIManager.cs) ---
// 파일 경로: Assets/1/Scripts/UI/CardRewardUIManager.cs

using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.EventSystems;

/// <summary>
/// 카드 보상 씬의 UI를 총괄하는 관리자입니다.
/// RewardManager로부터 카드 목록을 받아 화면에 표시하고, 사용자의 선택(획득, 합성, 스킵)을 처리하며,
/// 선택 결과에 따라 다른 UI(맵 선택)로의 전환을 담당합니다.
/// </summary>
public class CardRewardUIManager : MonoBehaviour
{
    // --- Inspector-Visible Fields --- //
    [Header("UI 요소 및 부모")]
    [SerializeField] private GameObject cardDisplayPrefab;
    [SerializeField] private Transform cardSlotsParent;
    
    // ▼▼▼ [1] 이 줄을 추가하세요. ▼▼▼
    [SerializeField] private CanvasGroup cardRewardCanvasGroup;

    [Header("버튼 참조")]
    [SerializeField] private Button acquireButton;
    [SerializeField] private Button synthesizeButton;
    [SerializeField] private Button skipButton;
    [SerializeField] private Button mapButton;

    [Header("팝업 참조")]
    [SerializeField] private SynthesisPopup synthesisPopup;

    // --- Private State Fields --- //
    private CardDisplay selectedDisplay;
    private List<CardDisplay> spawnedCardDisplays = new List<CardDisplay>();
    private GameObject lastSelectedCardObject; // UI 포커스 관리를 위해 마지막으로 선택된 오브젝트를 저장

    // --- Unity Lifecycle Methods --- //
    void Awake()
    {
        ServiceLocator.Register<CardRewardUIManager>(this);

        // 각 버튼에 대한 이벤트 리스너를 연결합니다.
        acquireButton.onClick.AddListener(OnAcquireClicked);
        synthesizeButton.onClick.AddListener(OnSynthesizeClicked);
        skipButton.onClick.AddListener(OnSkipClicked);
        if (mapButton != null) { mapButton.onClick.AddListener(OnMapButtonClicked); }

        Debug.Log("[CardRewardUIManager] Awake: 이벤트 리스너가 성공적으로 연결되었습니다.");
    }

    void OnEnable()
    {
        // RewardManager의 static 이벤트들을 구독하여, 보상이 준비되거나 스킵될 때 적절한 함수가 호출되도록 합니다.
        RewardManager.OnCardRewardReady += Initialize;
        RewardManager.OnRewardSkipped += HandleRewardSkipped;
    }

    void OnDisable()
{
    // 오브젝트가 비활성화될 때, 메모리 누수를 방지하기 위해 구독했던 이벤트를 해제합니다.
    RewardManager.OnCardRewardReady -= Initialize;
    RewardManager.OnRewardSkipped -= HandleRewardSkipped;
}

// ▼▼▼▼▼▼▼▼▼▼▼ [이 부분 추가] ▼▼▼▼▼▼▼▼▼▼▼
/// <summary>
/// 이 UI 오브젝트가 활성화되고 난 후, 첫 프레임에 호출됩니다.
/// </summary>
void Start()
{
    // RewardManager를 찾아 다음 보상 처리를 시작하도록 명시적으로 요청합니다.
    var rewardManager = ServiceLocator.Get<RewardManager>();
    if (rewardManager != null)
    {
        Debug.Log("[CardRewardUIManager] Start: RewardManager에게 보상 처리를 요청합니다.");
        rewardManager.ProcessNextReward();
    }
    else
    {
        Debug.LogError("[CardRewardUIManager] Start에서 RewardManager를 찾을 수 없습니다!");
    }
}
// ▲▲▲▲▲▲▲▲▲▲▲ [여기까지 추가] ▲▲▲▲▲▲▲▲▲▲▲

    // --- Event Handlers --- //
    private void HandleRewardSkipped()
    {
        Debug.Log("[CardRewardUIManager] 보상 스킵 신호(OnRewardSkipped)를 감지했습니다. 맵 선택으로 즉시 이동합니다.");
        TransitionToMap();
    }

    /// <summary>
    /// RewardManager로부터 카드 목록을 받아 보상 UI를 초기화하고 화면에 표시합니다.
    /// </summary>
    public void Initialize(List<CardDataSO> cardChoices)
    {
        Debug.Log($"[CardRewardUIManager] Initialize: {cardChoices.Count}개의 카드 보상으로 UI를 초기화합니다.");

        // 이전에 생성된 카드 UI가 있다면 모두 파괴하여 초기화합니다.
        foreach (Transform child in cardSlotsParent) { Destroy(child.gameObject); }
        spawnedCardDisplays.Clear();

        // 전달받은 카드 데이터 목록을 순회하며 CardDisplay 프리팹을 생성합니다.
        foreach (var cardData in cardChoices)
        {
            GameObject cardUI = Instantiate(cardDisplayPrefab, cardSlotsParent);
            CardDisplay cardDisplay = cardUI.GetComponent<CardDisplay>();
            if (cardDisplay != null)
            {
                cardDisplay.Setup(cardData);
                cardDisplay.OnCardSelected.AddListener(HandleCardSelection);
                spawnedCardDisplays.Add(cardDisplay);
            }
        }

        selectedDisplay = null; // 선택된 카드 없음으로 초기화
        UpdateButtonsState(); // 버튼 상태 업데이트
        // ▼▼▼ [2] 기존 SetInitialFocus 호출 부분을 변경된 이름으로 수정합니다. ▼▼▼
        StartCoroutine(SetFocusToCardCoroutine()); // 첫 번째 카드에 포커스 설정
    }

    /// <summary>
    /// 특정 카드 UI가 선택되었을 때 호출됩니다.
    /// </summary>
    private void HandleCardSelection(CardDisplay display)
    {
        selectedDisplay = display;
        Debug.Log($"[CardRewardUIManager] 카드 선택됨: {display.CurrentCard.cardName}");

        // 모든 카드 UI를 순회하며, 선택된 카드에만 하이라이트 효과를 적용합니다.
        foreach (var d in spawnedCardDisplays)
        {
            bool isSelected = (d == selectedDisplay);
            d.SetHighlight(isSelected);
            if (isSelected) { lastSelectedCardObject = d.gameObject; }
        }
        UpdateButtonsState(); // 버튼 상태 업데이트
    }

    // --- Button Click Handlers --- //
    private void OnAcquireClicked()
    {
        if (selectedDisplay == null)
        {
            Debug.LogWarning("[CardRewardUIManager] OnAcquireClicked: 선택된 카드가 없어 아무것도 하지 않습니다.");
            return;
        }

        CardDataSO selectedCardData = selectedDisplay.CurrentCard;
        Debug.Log($"[CardRewardUIManager] '획득' 버튼 클릭됨. 선택된 카드: {selectedCardData.cardName}");

        // [핵심 로직] CardManager를 통해 실제로 카드를 덱에 추가합니다.
        var cardManager = ServiceLocator.Get<CardManager>();
        if (cardManager != null)
        {
            cardManager.AcquireNewCard(selectedCardData);
            Debug.Log($"[CardRewardUIManager] CardManager를 통해 '{selectedCardData.cardName}' 카드를 성공적으로 획득했습니다.");
        }
        else
        {
            Debug.LogError("[CardRewardUIManager] CRITICAL: CardManager를 찾을 수 없어 카드를 획득할 수 없습니다!");
        }

        // 보상 선택이 완료되었음을 RewardManager에 알립니다.
        ServiceLocator.Get<RewardManager>()?.CompleteRewardSelection();
        // 맵 선택 화면으로 전환합니다.
        TransitionToMap();
    }

    private void OnSynthesizeClicked()
    {
        if (selectedDisplay == null || !synthesizeButton.interactable) return;
        Debug.Log($"[CardRewardUIManager] '합성' 버튼 클릭됨. 선택된 카드: {selectedDisplay.CurrentCard.cardName}");

        var cardManager = ServiceLocator.Get<CardManager>();
        CardDataSO selectedCardData = selectedDisplay.CurrentCard;
        List<CardDataSO> materialChoices = cardManager.GetSynthesizablePairs(selectedCardData);

        if (materialChoices.Count > 0 && synthesisPopup != null)
        {
            // ▼▼▼ [2] 팝업을 띄우기 전에 뒷쪽 패널의 상호작용을 막습니다. ▼▼▼
            if (cardRewardCanvasGroup != null)
            {
                cardRewardCanvasGroup.interactable = false;
            }

            synthesisPopup.gameObject.SetActive(true);

            // ▼▼▼ [3] 팝업이 닫힐 때 상호작용을 다시 활성화하도록 콜백을 전달합니다. ▼▼▼
            synthesisPopup.Initialize(selectedCardData.cardName, materialChoices, 
            (chosenMaterial) => {
                // 확인 콜백
                Debug.Log($"[CardRewardUIManager] 합성 재료 '{chosenMaterial.cardName}' 선택됨. 합성을 실행합니다.");
                if (cardRewardCanvasGroup != null) cardRewardCanvasGroup.interactable = true;
                cardManager.SynthesizeCards(selectedCardData, chosenMaterial);
                ServiceLocator.Get<RewardManager>()?.CompleteRewardSelection();
                TransitionToMap();
            }, 
            () => {
                // 취소 콜백
                Debug.Log("[CardRewardUIManager] 합성 취소됨.");
                if (cardRewardCanvasGroup != null) cardRewardCanvasGroup.interactable = true;
                // 포커스를 마지막으로 선택했던 합성 버튼으로 되돌립니다.
                EventSystem.current.SetSelectedGameObject(synthesizeButton.gameObject);
            });
        }
    }

    private void OnSkipClicked()
    {
        Debug.Log("[CardRewardUIManager] '스킵' 버튼 클릭됨.");
        ServiceLocator.Get<RewardManager>()?.CompleteRewardSelection();
        TransitionToMap();
    }

    private void OnMapButtonClicked()
    {
        Debug.Log("[CardRewardUIManager] '맵으로' 버튼 클릭됨.");
        TransitionToMap();
    }

    // --- Helper Methods --- //
    private void UpdateButtonsState()
    {
        acquireButton.interactable = (selectedDisplay != null);

        bool canSynthesize = false;
        if (selectedDisplay != null)
        {
            var cardManager = ServiceLocator.Get<CardManager>();
            if (cardManager != null)
            {
                canSynthesize = cardManager.HasSynthesizablePair(selectedDisplay.CurrentCard);
            }
        }
        synthesizeButton.interactable = canSynthesize;
    }

    private void TransitionToMap()
    {
        Debug.Log("[CardRewardUIManager] 맵 선택 화면으로 전환을 시작합니다...");

        var routeSelectionController = ServiceLocator.Get<RouteSelectionController>();
        if (routeSelectionController != null)
        {
            // [핵심 로직] 맵 선택 UI를 활성화합니다.
            routeSelectionController.Show();
        }
        else
        {
            Debug.LogError("[CardRewardUIManager] CRITICAL: RouteSelectionController를 찾을 수 없어 맵 화면으로 전환할 수 없습니다!");
        }

        // [핵심 로직] 전환 후, 자신(카드 보상 UI)은 확실하게 비활성화합니다.
        Hide();
    }

    // ▼▼▼ [1] 기존 SetInitialFocus 코루틴의 이름을 바꾸고 내용을 보강합니다. ▼▼▼
    private IEnumerator SetFocusToCardCoroutine()
    {
        yield return null; // UI 요소가 완전히 생성/활성화될 때까지 한 프레임 대기

        // 마지막으로 선택했던 카드가 있으면 그곳에 포커스를 맞춥니다.
        if (lastSelectedCardObject != null && lastSelectedCardObject.activeInHierarchy)
        {
            EventSystem.current.SetSelectedGameObject(lastSelectedCardObject);
        }
        // 마지막 선택 기록이 없으면, 생성된 카드 목록의 첫 번째에 포커스를 맞춥니다.
        else if (spawnedCardDisplays.Count > 0)
        {
            lastSelectedCardObject = spawnedCardDisplays[0].gameObject;
            EventSystem.current.SetSelectedGameObject(lastSelectedCardObject);
        }
    }

    public void Show() 
    { 
        gameObject.SetActive(true);
        // 맵에서 돌아왔을 때 포커스를 되찾기 위해 코루틴을 호출합니다.
        StartCoroutine(SetFocusToCardCoroutine());
    }
    public void Hide() { gameObject.SetActive(false); }
}

--- 파일명: CharacterSelectController.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/CharacterSelectController.cs) ---
using UnityEngine;

/// <summary>
/// 캐릭터 선택 씬의 전체적인 흐름과 상태를 관리하는 컨트롤러입니다.
/// 각 UI 패널(캐릭터 선택, 포인트 분배, 결과)을 제어하고,
/// 선택된 캐릭터 데이터와 분배된 포인트를 다음 씬으로 전달할 준비를 합니다.
/// </summary>
public class CharacterSelectController : MonoBehaviour
{
    public CharacterDataSO SelectedCharacter { get; private set; }
    public int AllocatedPoints { get; private set; }

    void Start()
    {
        // 씬이 시작되면, CharacterSelectUI 스크립트가 붙어있는 패널이 활성화됩니다.
    }

    public void OnCharacterSelected(CharacterDataSO characterData)
    {
        SelectedCharacter = characterData;
        Debug.Log($"[CharSelectController] 캐릭터 선택됨: {SelectedCharacter.characterName}");
    }

    public void ProceedToPointAllocation()
    {
        if (SelectedCharacter == null)
        {
            Debug.LogWarning("[CharSelectController] 캐릭터가 선택되지 않았습니다. 포인트 분배를 진행할 수 없습니다.");
            return;
        }

        ServiceLocator.Get<GameManager>().SelectedCharacter = this.SelectedCharacter;
        // GameManager의 PointAllocation 상태로 전환하도록 수정
        ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.PointAllocation);
    }
}

--- 파일명: CharacterSelectUI.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/CharacterSelectUI.cs) ---
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class CharacterSelectUI : MonoBehaviour
{
    [Header("컨트롤러 참조")]
    [SerializeField] private CharacterSelectController controller;
    [Header("UI 요소 참조")]
    [SerializeField] private TextMeshProUGUI totalPointsText;
    [Header("캐릭터별 일러스트 오브젝트 참조")]
    [SerializeField] private GameObject warriorCharacterIllust;
    [SerializeField] private GameObject archerCharacterIllust;
    [SerializeField] private GameObject mageCharacterIllust;
    [Header("버튼 목록")]
    [SerializeField] private Button warriorButton;
    [SerializeField] private Button archerButton;
    [SerializeField] private Button mageButton;
    [SerializeField] private Button startButton;
    [Header("선택 상태 시각화")]
    [SerializeField] private Color selectedButtonColor = Color.yellow;
    [SerializeField] private Color unselectedButtonColor = Color.white;
    private Button currentlySelectedCharacterButton;

    void Awake()
    {
        warriorButton.onClick.AddListener(() => SelectCharacter(CharacterIDs.Warrior));
        archerButton.onClick.AddListener(() => SelectCharacter(CharacterIDs.Archer));
        mageButton.onClick.AddListener(() => SelectCharacter(CharacterIDs.Mage));
        startButton.onClick.AddListener(OnGameStartClicked);
    }

    void Start()
    {
        DeactivateAllCharacterIllustrations();
        if (totalPointsText != null) totalPointsText.text = "보유 포인트: --";
        ResetButtonColors();
    }

    private void ResetButtonColors()
    {
        warriorButton.image.color = unselectedButtonColor;
        archerButton.image.color = unselectedButtonColor;
        mageButton.image.color = unselectedButtonColor;
        currentlySelectedCharacterButton = null;
    }

    private void DeactivateAllCharacterIllustrations()
    {
        if (warriorCharacterIllust != null) warriorCharacterIllust.SetActive(false);
        if (archerCharacterIllust != null) archerCharacterIllust.SetActive(false);
        if (mageCharacterIllust != null) mageCharacterIllust.SetActive(false);
    }

    private void SelectCharacter(string characterId)
    {
        CharacterDataSO characterData = ServiceLocator.Get<DataManager>().GetCharacter(characterId);
        if (characterData == null) return;

        controller.OnCharacterSelected(characterData);
        UpdateCharacterInfo(characterData);
        DeactivateAllCharacterIllustrations();

        if (currentlySelectedCharacterButton != null)
        {
            currentlySelectedCharacterButton.image.color = unselectedButtonColor;
        }

        switch (characterId)
        {
            case CharacterIDs.Warrior:
                if (warriorCharacterIllust != null) warriorCharacterIllust.SetActive(true);
                currentlySelectedCharacterButton = warriorButton;
                break;
            case CharacterIDs.Archer:
                if (archerCharacterIllust != null) archerCharacterIllust.SetActive(true);
                currentlySelectedCharacterButton = archerButton;
                break;
            case CharacterIDs.Mage:
                if (mageCharacterIllust != null) mageCharacterIllust.SetActive(true);
                currentlySelectedCharacterButton = mageButton;
                break;
        }

        if (currentlySelectedCharacterButton != null)
        {
            currentlySelectedCharacterButton.image.color = selectedButtonColor;
        }
    }

    private void UpdateCharacterInfo(CharacterDataSO characterData)
    {
        if (totalPointsText != null)
        {
            totalPointsText.text = $"보유 포인트: {characterData.initialAllocationPoints}";
        }
    }

    private void OnGameStartClicked()
    {
        controller.ProceedToPointAllocation();
    }
}

--- 파일명: CodexController.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/CodexController.cs) ---
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

public class CodexController : MonoBehaviour
{
    [Header("UI 요소 참조")]
    [SerializeField] private GameObject cardCodexPanel;
    [SerializeField] private GameObject artifactCodexPanel;
    [SerializeField] private Button cardTabButton;
    [SerializeField] private Button artifactTabButton;
    [SerializeField] private ScrollRect cardScrollRect;
    [SerializeField] private ScrollRect artifactScrollRect;
    [SerializeField] private GameObject itemInfoPrefab;

    private List<CardDataSO> allCards;
    private List<ArtifactDataSO> allArtifacts;
    private Dictionary<string, CodexItemDisplay> displayedCodexItems = new Dictionary<string, CodexItemDisplay>();

    // --- [추가] 필요한 매니저들을 저장할 변수 ---
    private ProgressionManager progressionManager;
    private PopupController popupController;
    private DataManager dataManager;

    void Awake()
    {
        cardTabButton.onClick.AddListener(ShowCardCodex);
        artifactTabButton.onClick.AddListener(ShowArtifactCodex);

        // --- [추가] Awake에서 매니저들을 미리 찾아옵니다. ---
        progressionManager = ServiceLocator.Get<ProgressionManager>();
        popupController = ServiceLocator.Get<PopupController>();
        dataManager = ServiceLocator.Get<DataManager>();
    }

    void OnEnable()
    {
        LoadData();
        PopulateCodex();
        ShowCardCodex();
    }

    private void LoadData()
    {
        allCards = dataManager.GetAllCards();
        allArtifacts = dataManager.GetAllArtifacts();
    }

    private void PopulateCodex()
    {
        displayedCodexItems.Clear();

        foreach (Transform child in cardScrollRect.content) Destroy(child.gameObject);
        cardScrollRect.content.DetachChildren();

        foreach (var card in allCards)
        {
            GameObject itemUI = Instantiate(itemInfoPrefab, cardScrollRect.content);
            CodexItemDisplay display = itemUI.GetComponent<CodexItemDisplay>();
            if (display != null)
            {
                bool isUnlocked = progressionManager.IsCodexItemUnlocked(card.cardID);
                display.SetupForCard(card, isUnlocked);
                display.SetHintButtonClickListener(card.cardID, PurchaseHint);
                displayedCodexItems[card.cardID] = display;
            }
        }

        foreach (Transform child in artifactScrollRect.content) Destroy(child.gameObject);
        artifactScrollRect.content.DetachChildren();

        if (allArtifacts != null)
        {
            foreach (var artifact in allArtifacts)
            {
                GameObject itemUI = Instantiate(itemInfoPrefab, artifactScrollRect.content);
                CodexItemDisplay display = itemUI.GetComponent<CodexItemDisplay>();
                if (display != null)
                {
                    bool isUnlocked = progressionManager.IsCodexItemUnlocked(artifact.artifactID);
                    display.SetupForArtifact(artifact, isUnlocked);
                    display.SetHintButtonClickListener(artifact.artifactID, PurchaseHint);
                    displayedCodexItems[artifact.artifactID] = display;
                }
            }
        }
        Debug.Log("도감 데이터를 기반으로 UI를 모두 생성했습니다.");
    }

    private void ShowCardCodex()
    {
        cardCodexPanel.SetActive(true);
        artifactCodexPanel.SetActive(false);
        cardTabButton.image.color = Color.white;
        artifactTabButton.image.color = Color.gray;
    }

    private void ShowArtifactCodex()
    {
        cardCodexPanel.SetActive(false);
        artifactCodexPanel.SetActive(true);
        cardTabButton.image.color = Color.gray;
        artifactTabButton.image.color = Color.white;
    }

    public void PurchaseHint(string itemId)
    {
        int hintCost = 10;
        if (progressionManager.SpendCurrency(MetaCurrencyType.KnowledgeShards, hintCost))
        {
            Debug.Log($"{itemId}의 힌트를 구매했습니다.");
            if (displayedCodexItems.TryGetValue(itemId, out CodexItemDisplay display))
            {
                display.ShowHint();
            }
            if (popupController != null) popupController.ShowError("힌트 구매 성공!", 1.5f);
        }
        else
        {
            Debug.LogWarning("힌트 구매에 필요한 지식의 파편이 부족합니다.");
            if (popupController != null) popupController.ShowError("지식의 파편이 부족합니다!", 1.5f);
        }
    }
}

--- 파일명: CodexItemDisplay.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/CodexItemDisplay.cs) ---
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System;

/// <summary>
/// 도감의 개별 항목(카드 또는 유물) 하나의 UI 표시를 담당합니다.
/// </summary>
public class CodexItemDisplay : MonoBehaviour
{
    [Header("UI 요소 참조")]
    [SerializeField] private TextMeshProUGUI nameText;
    [SerializeField] private TextMeshProUGUI typeText; // 카드의 속성(물리/마법) 또는 "유물" 텍스트
    [SerializeField] private TextMeshProUGUI rarityText; // 등급/희귀도
    [SerializeField] private TextMeshProUGUI descriptionText;
    [SerializeField] private Image itemIcon;
    [SerializeField] private GameObject lockedOverlay; // 잠금 상태일 때 표시할 오버레이
    [SerializeField] private Button hintButton; // 힌트 구매 버튼 (잠금 상태일 때만 활성화)

    private string currentItemId; // 현재 표시 중인 아이템의 ID
    private bool isCurrentlyUnlocked; // 현재 아이템의 해금 상태
    private string unlockedDescription; // 해금된 경우의 실제 설명

    /// <summary>
    /// 힌트 버튼 클릭 시 호출될 콜백을 설정합니다.
    /// </summary>
    public void SetHintButtonClickListener(string itemId, Action<string> onClick)
    {
        currentItemId = itemId;
        if (hintButton != null)
        {
            hintButton.onClick.RemoveAllListeners();
            hintButton.onClick.AddListener(() => onClick?.Invoke(currentItemId));
        }
    }

    /// <summary>
    /// 카드 데이터로 UI를 설정합니다.
    /// </summary>
    public void SetupForCard(CardDataSO card, bool isUnlocked)
    {
        isCurrentlyUnlocked = isUnlocked;
        unlockedDescription = card.effectDescription; // 실제 설명 저장

        if (hintButton != null) hintButton.gameObject.SetActive(!isUnlocked);
        if (lockedOverlay != null) lockedOverlay.SetActive(!isUnlocked);

        if (isUnlocked)
        {
            nameText.text = card.cardName;
            typeText.text = card.type.ToString();
            rarityText.text = card.rarity.ToString();
            descriptionText.text = card.effectDescription;
            // if (itemIcon != null && card.icon != null) itemIcon.sprite = card.icon;
        }
        else
        {
            nameText.text = "????????";
            typeText.text = "";
            rarityText.text = "";
            descriptionText.text = "";
            // if (itemIcon != null) itemIcon.sprite = null;
        }
    }

    /// <summary>
    /// 유물 데이터로 UI를 설정합니다.
    /// </summary>
    public void SetupForArtifact(ArtifactDataSO artifact, bool isUnlocked)
    {
        isCurrentlyUnlocked = isUnlocked;
        unlockedDescription = artifact.description; // 실제 설명 저장

        if (hintButton != null) hintButton.gameObject.SetActive(!isUnlocked);
        if (lockedOverlay != null) lockedOverlay.SetActive(!isUnlocked);

        if (isUnlocked)
        {
            nameText.text = artifact.artifactName;
            typeText.text = "유물";
            rarityText.text = artifact.rarity.ToString();
            descriptionText.text = artifact.description; 
            // if (itemIcon != null && artifact.icon != null) itemIcon.sprite = artifact.icon;
        }
        else
        {
            nameText.text = "????????";
            typeText.text = "";
            rarityText.text = "";
            descriptionText.text = "";
            // if (itemIcon != null) itemIcon.sprite = null;
        }
    }

    /// <summary>
    /// 힌트를 표시합니다. (잠금 상태에서만 호출)
    /// </summary>
    public void ShowHint()
    {
        if (!isCurrentlyUnlocked) // 잠금 상태일 때만 힌트 표시
        {
            descriptionText.text = unlockedDescription; // 실제 설명 표시
            if (hintButton != null) hintButton.gameObject.SetActive(false); // 힌트 버튼 비활성화
        }
    }
}


--- 파일명: DamageText.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/DamageText.cs) ---
using UnityEngine;
using System.Collections;
using TMPro;

public class DamageText : MonoBehaviour
{
    [Header("ִϸ̼ ")]
    [Tooltip("ؽƮ Ƣ  ִϸ̼ ü ũ⸦ մϴ. (1 = 100%)")]
    public float animationScale = 1.0f;
    [Tooltip("ִϸ̼ Ǵ ðԴϴ.")]
    public float animationDuration = 0.8f;
    [Tooltip("ؽƮ  ö󰡴 ŸԴϴ.")]
    public float moveUpDistance = 1.5f;

    private TextMeshProUGUI textMesh;
    private PoolManager poolManager;

    private void Awake()
    {
        textMesh = GetComponentInChildren<TextMeshProUGUI>();
        if (textMesh == null)
        {
            Debug.LogError("DamageText: ڽ Ʈ TextMeshProUGUI Ʈ ã  ϴ!");
        }
    }

    void Start()
    {
        // --- [] ServiceLocator  PoolManager ãƿɴϴ. ---
        poolManager = ServiceLocator.Get<PoolManager>();
    }

    public void ShowDamage(float damageAmount)
    {
        if (textMesh == null) return;

        textMesh.text = Mathf.RoundToInt(damageAmount).ToString();
        StartCoroutine(Animate());
    }

    private IEnumerator Animate()
    {
        transform.SetParent(null, true);
        transform.localScale = Vector3.zero;

        Color startColor = textMesh.color;
        startColor.a = 1f;
        textMesh.color = startColor;

        Color endColor = startColor;
        endColor.a = 0f;

        float timer = 0f;
        Vector3 startPosition = transform.position;
        Vector3 targetPosition = startPosition + (Vector3.up * moveUpDistance);

        float popupDuration = 0.1f;
        Vector3 targetScale = Vector3.one * animationScale;

        while (timer < popupDuration)
        {
            transform.localScale = Vector3.Lerp(Vector3.zero, targetScale, timer / popupDuration);
            timer += Time.deltaTime;
            yield return null;
        }
        transform.localScale = targetScale;

        timer = 0f;
        while (timer < animationDuration)
        {
            transform.position = Vector3.Lerp(startPosition, targetPosition, timer / animationDuration);
            textMesh.color = Color.Lerp(startColor, endColor, timer / animationDuration);
            timer += Time.deltaTime;
            yield return null;
        }

        if (poolManager != null)
        {
            poolManager.Release(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }
}

--- 파일명: GameInitiolizer.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/GameInitiolizer.cs) ---
// ϸ: GameInitializer.cs
using System.Collections;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.SceneManagement;

public class GameInitializer : MonoBehaviour
{
    void Start()
    {
        StartCoroutine(LoadEssentialDataAndProceed());
    }

    private IEnumerator LoadEssentialDataAndProceed()
    {
        // 0. (û) ⿡ ε ȭ UI ǥϴ ڵ带   ֽϴ.
        Debug.Log("[GameInitializer] ʼ  ε մϴ...");

        // 1. Addressables ý ʱȭ (   )
        yield return Addressables.InitializeAsync();

        // 2. ٽ Ŵ յ 񵿱 νϽȭմϴ.
        yield return Addressables.InstantiateAsync(PrefabKeys.Managers);
        yield return Addressables.InstantiateAsync(PrefabKeys.GameplaySession);

        Debug.Log("[GameInitializer] ٽ Ŵ  Ϸ.");

        // 3. DataManager   ε   ٸϴ.
        var dataManager = ServiceLocator.Get<DataManager>();
        if (dataManager != null)
        {
            yield return dataManager.LoadAllDataAsync();
        }

        // 4.  ε  MainMenu  ̵մϴ.
        Debug.Log("[GameInitializer]   ε Ϸ.  ޴ ̵մϴ.");
        SceneManager.LoadScene(SceneNames.MainMenu);
    }
}

--- 파일명: GeneBoosterRoulette.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/GeneBoosterRoulette.cs) ---
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;
using TMPro;
using System.Collections;

public class GeneBoosterRoulette : MonoBehaviour
{
    [Header("UI 요소 참조")]
    [SerializeField] private Button spinRouletteButton;
    [SerializeField] private TextMeshProUGUI genePointsText;
    [SerializeField] private TMP_InputField pointsToInvestInput;
    [SerializeField] private Button investButton;
    [SerializeField] private List<GameObject> statUIs;
    [SerializeField] private Image spinRouletteButtonImage;

    private const int ROULETTE_COST = 15;

    private CharacterPermanentStats permanentStats;

    // --- [추가] 서비스 로케이터를 통해 매니저 인스턴스를 저장할 변수 ---
    private ProgressionManager progressionManager;
    private PopupController popupController;

    void Start()
    {
        // --- [추가] 서비스 로케이터를 통해 필요한 매니저를 미리 찾아둡니다. ---
        progressionManager = ServiceLocator.Get<ProgressionManager>();
        popupController = ServiceLocator.Get<PopupController>();
        var gameManager = ServiceLocator.Get<GameManager>();

        string characterId = "warrior";
        if (gameManager != null && gameManager.SelectedCharacter != null)
        {
            characterId = gameManager.SelectedCharacter.characterId;
        }

        permanentStats = progressionManager.GetPermanentStatsFor(characterId);

        spinRouletteButton.onClick.AddListener(SpinRoulette);
        investButton.onClick.AddListener(InvestPoints);

        UpdateUI();
    }

    private void UpdateUI()
    {
        // --- [수정] 미리 찾아둔 progressionManager 변수를 사용합니다. ---
        genePointsText.text = $"보유 포인트: {progressionManager.GenePoints}";

        bool canSpin = progressionManager.GenePoints >= ROULETTE_COST && !permanentStats.AllStatsUnlocked();
        spinRouletteButton.interactable = canSpin;
        if (spinRouletteButtonImage != null)
        {
            spinRouletteButtonImage.color = canSpin ? Color.white : Color.gray;
        }

        investButton.interactable = progressionManager.GenePoints > 0;
    }

    private void SpinRoulette()
    {
        // --- [수정] 미리 찾아둔 변수들을 사용합니다. ---
        if (!progressionManager.SpendCurrency(MetaCurrencyType.GenePoints, ROULETTE_COST))
        {
            if (popupController != null) popupController.ShowError("유전자 포인트가 부족합니다.", 1.5f);
            return;
        }

        List<StatType> availableStats = permanentStats.GetLockedStats();
        if (availableStats.Count == 0)
        {
            if (popupController != null) popupController.ShowError("모든 스탯이 이미 해금되었습니다.", 1.5f);
            return;
        }

        StartCoroutine(SpinRouletteAnimation(availableStats));
    }

    private IEnumerator SpinRouletteAnimation(List<StatType> availableStats)
    {
        spinRouletteButton.interactable = false;
        Debug.Log("룰렛 애니메이션 시작...");

        yield return new WaitForSeconds(2f);

        StatType unlockedStat = availableStats[Random.Range(0, availableStats.Count)];
        permanentStats.UnlockStat(unlockedStat);
        Debug.Log($"룰렛 결과: {unlockedStat} 능력치 해금!");

        spinRouletteButton.interactable = true;
        UpdateUI();
    }

    private void InvestPoints()
    {
        if (!int.TryParse(pointsToInvestInput.text, out int points) || points <= 0)
        {
            // --- [수정] 미리 찾아둔 popupController 변수를 사용합니다. ---
            if (popupController != null) popupController.ShowError("유효한 투자 포인트를 입력하세요.", 1.5f);
            return;
        }

        // --- [수정] 미리 찾아둔 progressionManager 변수를 사용합니다. ---
        points = Mathf.Min(points, progressionManager.GenePoints);

        if (!progressionManager.SpendCurrency(MetaCurrencyType.GenePoints, points))
        {
            if (popupController != null) popupController.ShowError("투자에 필요한 유전자 포인트가 부족합니다.", 1.5f);
            return;
        }

        permanentStats.DistributePoints(points);
        Debug.Log($"{points} 포인트를 해금된 능력치에 랜덤하게 투자했습니다.");

        UpdateUI();
    }
}

--- 파일명: HUDController.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/HUDController.cs) ---
// --- 파일명: HUDController.cs (추적 디버깅 버전) ---
// 역할: HUD의 전체 생명주기를 추적하여 문제의 원인을 찾습니다.
// 수정 내용: Awake, OnEnable, Start, OnDisable, OnDestroy 등 모든 주요 함수에
//           실행 시점을 알리는 디버그 로그를 추가했습니다.
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class HUDController : MonoBehaviour
{
    [SerializeField] private Slider healthBar;
    [SerializeField] private TextMeshProUGUI timerText;
    [SerializeField] private TextMeshProUGUI killCountText;

    private int instanceId;

    // 1. 스크립트 인스턴스가 처음 로드될 때 호출됩니다. (게임 오브젝트가 비활성화 상태여도 호출됨)
    private void Awake()
    {
        // Awake에서 고유한 ID를 생성합니다. GetInstanceID()는 모든 유니티 오브젝트가 가진 고유 번호입니다.
        instanceId = gameObject.GetInstanceID();
        Debug.Log($"[HUD 추적 ID: {instanceId}] {gameObject.name} - Awake() 호출됨. (Frame: {Time.frameCount})");
    }

    private void OnEnable()
    {
        Debug.Log($"[HUD 추적 ID: {instanceId}] {gameObject.name} - OnEnable() 호출됨. 이벤트 구독 시작. (Frame: {Time.frameCount})");
        RoundManager.OnRoundStarted += HandleRoundStarted;
        RoundManager.OnKillCountChanged += UpdateKillCount;
        RoundManager.OnTimerChanged += UpdateTimer;
        RoundManager.OnRoundEnded += HandleRoundEnd;
    }

    private void Start()
    {
        Debug.Log($"[HUD 추적 ID: {instanceId}] {gameObject.name} - Start() 호출됨. (Frame: {Time.frameCount})");
    }

    private void HandleRoundStarted(RoundDataSO roundData)
    {
        // [유령 추적 2] 어떤 HUD가 방송을 수신하는지 확인합니다.
        UpdateKillCount(0, roundData.killGoal);
        UpdateTimer(roundData.roundDuration);
    }

    private void OnDisable()
    {
        RoundManager.OnRoundStarted -= HandleRoundStarted;
        RoundManager.OnKillCountChanged -= UpdateKillCount;
        RoundManager.OnTimerChanged -= UpdateTimer;
        RoundManager.OnRoundEnded -= HandleRoundEnd;
    }

    private void OnDestroy()
    {
        Debug.LogWarning($"[HUD 추적 ID: {instanceId}] {gameObject.name} - OnDestroy() 호출됨! (Frame: {Time.frameCount})");
    }

    // --- UI 업데이트 함수 (변경 없음) ---
    public void UpdateTimer(float time)
    {
        if (timerText == null) return;
        time = Mathf.Max(0, time);
        int minutes = (int)time / 60;
        int seconds = (int)time % 60;
        timerText.text = $"Time : {minutes:00}:{seconds:00}";
    }

    public void UpdateKillCount(int currentKills, int goalKills)
    {
        if (killCountText != null)
        {
            killCountText.text = $"Kills: {currentKills} / {goalKills}";
        }
    }

    private void HandleRoundEnd(bool success)
    {
        Debug.Log($"[HUD 추적] {gameObject.name} - '라운드 종료' 방송 수신. (Frame: {Time.frameCount})");
    }
}


--- 파일명: MainMenuUI.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/MainMenuUI.cs) ---
﻿using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class MainMenuUI : MonoBehaviour
{
    [Header("UI 요소 참조")]
    public Button optionsButton;
    public Button startButton;
    public Button codexButton;
    public Button exitButton;
    public TextMeshProUGUI versionInfoText;

    void Start()
    {
        startButton.onClick.AddListener(OnStartButtonClicked);
        optionsButton.onClick.AddListener(OnOptionsButtonClicked);
        codexButton.onClick.AddListener(OnCodexButtonClicked);
        exitButton.onClick.AddListener(OnExitButtonClicked);

        if (versionInfoText != null)
        {
            versionInfoText.text = "Version: " + Application.version;
        }
    }

    public void OnOptionsButtonClicked() { Debug.Log("옵션 버튼 클릭!"); }
    public void OnStartButtonClicked() { ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.CharacterSelect); }
    public void OnCodexButtonClicked() { ServiceLocator.Get<GameManager>().ChangeState(GameManager.GameState.Codex); }
    public void OnExitButtonClicked() { Application.Quit(); }
}

--- 파일명: MapNodeUI.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/MapNodeUI.cs) ---
using UnityEngine;
using UnityEngine.UI;

// 이 스크립트는 UI 버튼 오브젝트가 어떤 맵 노드 데이터(위치)를
// 가지고 있는지 관리하는 스크립트입니다.
public class MapNodeUI : MonoBehaviour
{
    public MapNode nodeData; // 이 노드 UI가 나타내는 맵 노드 데이터
    
    // [수정됨] Inspector에서 Button 컴포넌트를 연결할 수 있도록 [HideInInspector]를 제거합니다.
    [SerializeField] public Button button; 

    void Awake()
    {
        // [수정됨] 자식 오브젝트에서도 Button 컴포넌트를 찾을 수 있도록 GetComponentInChildren를 사용합니다.
        if (button == null) // Inspector에서 연결되지 않았다면 코드로 찾습니다.
        {
            button = GetComponentInChildren<Button>();
            if (button == null)
            {
                Debug.LogError($"[MapNodeUI] {gameObject.name}에서 Button 컴포넌트를 찾을 수 없습니다! Inspector에서 연결하거나 자식 오브젝트에 Button이 있는지 확인하세요.");
            }
        }
    }
}


--- 파일명: MapView.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/MapView.cs) ---
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;
using System.Linq;

public class MapView : MonoBehaviour
{
    [Header("UI 프리팹")]
    [SerializeField] private GameObject nodePrefab;
    [SerializeField] private GameObject pathPrefab;

    [Header("UI 부모 오브젝트")]
    [SerializeField] private Transform pathParent;
    [SerializeField] private Transform nodeParent;

    [Header("맵 시각화 설정")]
    [SerializeField] private float nodeSpacingX = 200f;
    [SerializeField] private float nodeSpacingY = 120f;
    [SerializeField] private ScrollRect mapScrollRect;

    private Dictionary<MapNode, GameObject> nodeUiMap = new Dictionary<MapNode, GameObject>();

    public event System.Action<MapNode> OnNodeSelected;

    public void GenerateMapView(List<MapNode> mapData, int mapWidth, int intMapHeight)
    {
        Debug.Log("[MapView] GenerateMapView 시작."); // [추가됨] 디버그 로그
        foreach (Transform child in nodeParent) Destroy(child.gameObject); // [수정됨] intMapHeight로 변수명 변경
        foreach (Transform child in pathParent) Destroy(child.gameObject);
        nodeUiMap.Clear();

        float horizontalOffset = (mapWidth - 1) * nodeSpacingX * 0.5f;

        foreach (var nodeData in mapData)
        {
            GameObject nodeObj = Instantiate(nodePrefab, nodeParent);
            RectTransform nodeRect = nodeObj.GetComponent<RectTransform>();
            if (nodeRect != null)
            {
                float posX = nodeData.Position.x * nodeSpacingX - horizontalOffset;
                float posY = nodeData.Position.y * nodeSpacingY;
                nodeRect.anchoredPosition = new Vector2(posX, posY);
            }

            MapNodeUI mapNodeUI = nodeObj.GetComponent<MapNodeUI>();
            if (mapNodeUI != null)
            {
                // [추가됨] MapNodeUI의 button 참조 확인
                if (mapNodeUI.button == null)
                {
                    Debug.LogError($"[MapView] MapNodeUI ({nodeObj.name})에 Button 컴포넌트가 연결되지 않았습니다!");
                }
                else
                {
                    mapNodeUI.nodeData = nodeData;
                    MapNode currentNodeData = nodeData;
                    mapNodeUI.button.onClick.AddListener(() => OnNodeClicked(currentNodeData));
                }
            }
            else
            {
                Debug.LogError($"[MapView] 노드 프리팹 ({nodePrefab.name})에 MapNodeUI 컴포넌트가 없습니다!"); // [추가됨] 디버그 로그
            }

            nodeUiMap.Add(nodeData, nodeObj);
        }

        foreach (var nodeData in mapData)
        {
            if (nodeData.NextNodes.Count > 0)
            {
                GameObject fromObj = nodeUiMap[nodeData];
                foreach (var childNode in nodeData.NextNodes)
                {
                    if (nodeUiMap.ContainsKey(childNode))
                    {
                        DrawPath(fromObj, nodeUiMap[childNode]);
                    }
                }
            }
        }

        RectTransform contentRect = mapScrollRect.content;
        float totalMapHeight = (intMapHeight - 1) * nodeSpacingY; // [수정됨] intMapHeight로 변수명 변경
        contentRect.sizeDelta = new Vector2(contentRect.sizeDelta.x, totalMapHeight + 8000f);
        Debug.Log("[MapView] GenerateMapView 완료."); // [추가됨] 디버그 로그
    }

    private void OnNodeClicked(MapNode node)
    {
        OnNodeSelected?.Invoke(node);
        Debug.Log($"[MapView] OnNodeSelected 이벤트 발생 시도.");
    }

    private void DrawPath(GameObject from, GameObject to)
    {
        GameObject pathObj = Instantiate(pathPrefab, pathParent);
        RectTransform pathRect = pathObj.GetComponent<RectTransform>();
        Image pathImage = pathObj.GetComponent<Image>();

        Vector2 dir = (to.transform.position - from.transform.position).normalized;
        float distance = Vector2.Distance(to.transform.position, from.transform.position);

        pathRect.sizeDelta = new Vector2(distance, pathRect.sizeDelta.y);
        pathRect.position = from.transform.position;
        pathRect.pivot = new Vector2(0, 0.5f);
        pathRect.rotation = Quaternion.FromToRotation(Vector3.right, dir);
        if (pathImage != null) pathImage.type = Image.Type.Tiled;
    }

    /// <summary>
    /// [변경됨] 모든 노드의 네비게이션을 요구사항에 맞게 설정합니다.
    /// </summary>
    public void SetupAllNodeNavigations(Button backButton)
    {
        Debug.Log("[MapView] SetupAllNodeNavigations 시작."); // [추가됨] 디버그 로그
        foreach (var pair in nodeUiMap)
        {
            MapNode currentNodeData = pair.Key;
            GameObject currentNodeObj = pair.Value;
            Button currentBtn = currentNodeObj.GetComponent<Button>();

            if (currentBtn == null)
            {
                Debug.LogError($"[MapView] 노드 오브젝트 {currentNodeObj.name}에 Button 컴포넌트가 없습니다!"); // [추가됨] 디버그 로그
                continue;
            }

            Navigation nav = new Navigation
            {
                mode = Navigation.Mode.Explicit
            };

            var upCandidates = nodeUiMap.Where(p => p.Key.Position.y == currentNodeData.Position.y + 1);
            if (upCandidates.Any()) 
            {
                var targetUp = upCandidates.OrderBy(p => Mathf.Abs(p.Value.transform.position.x - currentNodeObj.transform.position.x)).First();
                nav.selectOnUp = targetUp.Value.GetComponent<Button>();
            }

            var downCandidates = nodeUiMap.Where(p => p.Key.Position.y == currentNodeData.Position.y - 1);
            if (downCandidates.Any())
            {
                var targetDown = downCandidates.OrderBy(p => Mathf.Abs(p.Value.transform.position.x - currentNodeObj.transform.position.x)).First();
                nav.selectOnDown = targetDown.Value.GetComponent<Button>();
            }

            var leftCandidates = nodeUiMap.Where(p => p.Key.Position.y == currentNodeData.Position.y && p.Key.Position.x < currentNodeData.Position.x);
            if (leftCandidates.Any())
            {
                var targetLeft = leftCandidates.OrderByDescending(p => p.Key.Position.x).First();
                nav.selectOnLeft = targetLeft.Value.GetComponent<Button>();
            }
            else
            {
                if (backButton != null && backButton.interactable)
                {
                    nav.selectOnLeft = backButton;
                }
            }

            var rightCandidates = nodeUiMap.Where(p => p.Key.Position.y == currentNodeData.Position.y && p.Key.Position.x > currentNodeData.Position.x);
            if (rightCandidates.Any())
            {
                var targetRight = rightCandidates.OrderBy(p => p.Key.Position.x).First();
                nav.selectOnRight = targetRight.Value.GetComponent<Button>();
            }

            currentBtn.navigation = nav;
        }
        Debug.Log("[MapView] SetupAllNodeNavigations 완료."); // [추가됨] 디버그 로그
    }

    public void UpdateNodeInteractability(List<MapNode> reachableNodes)
    {
        Debug.Log($"[MapView] UpdateNodeInteractability 시작. 도달 가능한 노드 수: {reachableNodes.Count}"); // [추가됨] 디버그 로그
        foreach (var entry in nodeUiMap)
        {
            Button button = entry.Value.GetComponentInChildren<Button>();
            if (button != null)
            {
                bool isInteractable = reachableNodes.Contains(entry.Key);
                button.interactable = isInteractable;
            }
            else
            {
                Debug.LogWarning($"[MapView] 노드 {entry.Key.Position}의 자식에서 Button 컴포넌트를 찾을 수 없습니다."); // [추가됨] 디버그 로그
            }
        }
        Debug.Log("[MapView] UpdateNodeInteractability 완료."); // [추가됨] 디버그 로그
    }

    public GameObject FindClosestNodeTo(Vector3 position)
    {
        if (nodeUiMap.Count == 0) return null;
        return nodeUiMap.OrderBy(p => Vector3.Distance(p.Value.transform.position, position)).First().Value;
    }

    public GameObject FindLeftmostAvailableNode(List<MapNode> reachableNodes)
    {
        if (reachableNodes == null || reachableNodes.Count == 0) return null;

        MapNode leftmostNode = reachableNodes
            .OrderBy(n => n.Position.y)
            .ThenBy(n => n.Position.x)
            .FirstOrDefault();

        if (leftmostNode != null && nodeUiMap.ContainsKey(leftmostNode))
        {
            return nodeUiMap[leftmostNode];
        }
        return null;
    }
}

--- 파일명: OptionsController.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/OptionsController.cs) ---
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Collections.Generic;

public class OptionsController : MonoBehaviour
{
    [Header("그래픽 설정 참조")]
    [SerializeField] private TMP_Dropdown resolutionDropdown;
    [SerializeField] private Toggle fullscreenToggle;

    [Header("오디오 설정 참조")]
    [SerializeField] private Slider bgmVolumeSlider;
    [SerializeField] private Slider sfxVolumeSlider;

    [Header("언어 및 접근성 참조")]
    [SerializeField] private TMP_Dropdown languageDropdown;
    [SerializeField] private Slider fontSizeSlider;
    [SerializeField] private CanvasScaler mainCanvasScaler;

    private Resolution[] resolutions;

    // --- [추가] AudioManager 인스턴스를 저장할 변수 ---
    private AudioManager audioManager;

    void Start()
    {
        // --- [추가] ServiceLocator를 통해 AudioManager를 찾아옵니다. ---
        audioManager = ServiceLocator.Get<AudioManager>();

        resolutionDropdown.onValueChanged.AddListener(SetResolution);
        fullscreenToggle.onValueChanged.AddListener(SetFullscreen);
        bgmVolumeSlider.onValueChanged.AddListener(SetBgmVolume);
        sfxVolumeSlider.onValueChanged.AddListener(SetSfxVolume);
        languageDropdown.onValueChanged.AddListener(SetLanguage);
        fontSizeSlider.onValueChanged.AddListener(SetFontSize);

        InitializeGraphicsSettings();
        InitializeAudioSettings();
        InitializeAccessibilitySettings();
        LoadSettings();
    }

    private void InitializeGraphicsSettings()
    {
        resolutions = Screen.resolutions;
        resolutionDropdown.ClearOptions();
        List<string> options = new List<string>();
        int currentResolutionIndex = 0;
        for (int i = 0; i < resolutions.Length; i++)
        {
            string option = resolutions[i].width + " x " + resolutions[i].height;
            options.Add(option);
            if (resolutions[i].width == Screen.currentResolution.width &&
                resolutions[i].height == Screen.currentResolution.height)
            {
                currentResolutionIndex = i;
            }
        }
        resolutionDropdown.AddOptions(options);
        resolutionDropdown.value = currentResolutionIndex;
        resolutionDropdown.RefreshShownValue();

        fullscreenToggle.isOn = Screen.fullScreen;
    }

    private void InitializeAudioSettings()
    {
        // --- [수정] 찾아온 audioManager 인스턴스를 사용합니다. ---
        if (audioManager != null)
        {
            bgmVolumeSlider.value = audioManager.GetBgmVolume();
            sfxVolumeSlider.value = audioManager.GetSfxVolume();
        }
    }

    private void InitializeAccessibilitySettings()
    {
        languageDropdown.ClearOptions();
        languageDropdown.AddOptions(new List<string> { "한국어", "English" });
        languageDropdown.value = 0;
        languageDropdown.RefreshShownValue();

        fontSizeSlider.minValue = 0.5f;
        fontSizeSlider.maxValue = 1.5f;
        fontSizeSlider.value = 1.0f;
    }

    public void SetResolution(int resolutionIndex)
    {
        Resolution resolution = resolutions[resolutionIndex];
        Screen.SetResolution(resolution.width, resolution.height, Screen.fullScreen);
        Debug.Log($"해상도 변경: {resolution.width}x{resolution.height}");
        SaveSettings();
    }

    public void SetFullscreen(bool isFullscreen)
    {
        Screen.fullScreen = isFullscreen;
        Debug.Log($"전체화면 모드: {isFullscreen}");
        SaveSettings();
    }

    public void SetBgmVolume(float volume)
    {
        // --- [수정] 찾아온 audioManager 인스턴스를 사용합니다. ---
        if (audioManager != null)
        {
            audioManager.SetVolume(volume, sfxVolumeSlider.value);
        }
        SaveSettings();
    }

    public void SetSfxVolume(float volume)
    {
        // --- [수정] 찾아온 audioManager 인스턴스를 사용합니다. ---
        if (audioManager != null)
        {
            audioManager.SetVolume(bgmVolumeSlider.value, volume);
        }
        SaveSettings();
    }

    public void SetLanguage(int languageIndex)
    {
        string languageCode = languageDropdown.options[languageIndex].text;
        Debug.Log($"언어 변경: {languageCode}");
        SaveSettings();
    }

    public void SetFontSize(float scale)
    {
        if (mainCanvasScaler != null)
        {
            mainCanvasScaler.dynamicPixelsPerUnit = 1.0f * scale;
            Debug.Log($"폰트 크기 변경: {scale}");
        }
        else
        {
            Debug.LogWarning("mainCanvasScaler가 할당되지 않았습니다. 폰트 크기를 변경할 수 없습니다.");
        }
        SaveSettings();
    }

    public void SaveSettings()
    {
        PlayerPrefs.SetInt("ResolutionIndex", resolutionDropdown.value);
        PlayerPrefs.SetInt("Fullscreen", fullscreenToggle.isOn ? 1 : 0);
        PlayerPrefs.SetFloat("BGMVolume", bgmVolumeSlider.value);
        PlayerPrefs.SetFloat("SFXVolume", sfxVolumeSlider.value);
        PlayerPrefs.SetInt("LanguageIndex", languageDropdown.value);
        PlayerPrefs.SetFloat("FontSizeScale", fontSizeSlider.value);
        PlayerPrefs.Save();
        Debug.Log("설정이 저장되었습니다.");
    }

    private void LoadSettings()
    {
        if (PlayerPrefs.HasKey("ResolutionIndex"))
        {
            resolutionDropdown.value = PlayerPrefs.GetInt("ResolutionIndex");
            resolutionDropdown.RefreshShownValue();
            SetResolution(resolutionDropdown.value);
        }
        if (PlayerPrefs.HasKey("Fullscreen"))
        {
            fullscreenToggle.isOn = PlayerPrefs.GetInt("Fullscreen") == 1;
            SetFullscreen(fullscreenToggle.isOn);
        }
        if (PlayerPrefs.HasKey("BGMVolume"))
        {
            bgmVolumeSlider.value = PlayerPrefs.GetFloat("BGMVolume");
            SetBgmVolume(bgmVolumeSlider.value);
        }
        if (PlayerPrefs.HasKey("SFXVolume"))
        {
            sfxVolumeSlider.value = PlayerPrefs.GetFloat("SFXVolume");
            SetSfxVolume(sfxVolumeSlider.value);
        }
        if (PlayerPrefs.HasKey("LanguageIndex"))
        {
            languageDropdown.value = PlayerPrefs.GetInt("LanguageIndex");
            languageDropdown.RefreshShownValue();
            SetLanguage(languageDropdown.value);
        }
        if (PlayerPrefs.HasKey("FontSizeScale"))
        {
            fontSizeSlider.value = PlayerPrefs.GetFloat("FontSizeScale");
            SetFontSize(fontSizeSlider.value);
        }
        Debug.Log("설정을 불러왔습니다.");
    }
}

--- 파일명: PlayerHealthBar.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/PlayerHealthBar.cs) ---
using UnityEngine;
using UnityEngine.UI;

public class PlayerHealthBar : MonoBehaviour
{
    [SerializeField]
    private Slider healthBarSlider;

    void LateUpdate()
    {
        transform.rotation = Quaternion.identity;
    }

    public void UpdateHealth(float currentHealth, float maxHealth)
    {
        if (healthBarSlider != null && maxHealth > 0)
        {
            healthBarSlider.value = currentHealth / maxHealth;
        }
    }
}

--- 파일명: PointAllocationResultUI.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/PointAllocationResultUI.cs) ---
// --- 파일명: PointAllocationResultUI.cs (최종 수정본) ---

using UnityEngine;
using TMPro;
using System.Collections.Generic;

public class PointAllocationResultUI : MonoBehaviour
{
    // ... (UI 참조 변수들은 이전과 동일) ...
    [SerializeField] private TextMeshProUGUI damageText;
    [SerializeField] private TextMeshProUGUI attackSpeedText;
    [SerializeField] private TextMeshProUGUI moveSpeedText;
    [SerializeField] private TextMeshProUGUI healthText;
    [SerializeField] private TextMeshProUGUI critRateText;
    [SerializeField] private TextMeshProUGUI critDamageText;

    // ✨ [1번 문제 해결] 파라미터를 분배된 포인트 딕셔너리로 변경
    public void UpdateDisplay(BaseStats baseStats, Dictionary<StatType, int> distributedPoints)
    {
        if (distributedPoints == null) // Confirm 전
        {
            damageText.text = $"Base Damage ({baseStats.baseDamage:F0}) + Gene Boost (??) = ???";
            attackSpeedText.text = $"Base Attack Speed ({baseStats.baseAttackSpeed:F1}) + Gene Boost (??) = ???";
            moveSpeedText.text = $"Base Move Speed ({baseStats.baseMoveSpeed:F1}) + Gene Boost (??) = ???";
            healthText.text = $"Base Health ({baseStats.baseHealth:F0}) + Gene Boost (??) = ???";
            critRateText.text = $"Base Crit Rate ({baseStats.baseCritRate:F0}%) + Gene Boost (??) = ???";
            critDamageText.text = $"Base Crit Damage ({baseStats.baseCritDamage:F0}%) + Gene Boost (??) = ???";
        }
        else // Confirm 후
        {
            // 각 스탯에 실제 분배된 포인트 개수를 가져옴
            int attackPoints = distributedPoints[StatType.Attack];
            int attackSpeedPoints = distributedPoints[StatType.AttackSpeed];
            int moveSpeedPoints = distributedPoints[StatType.MoveSpeed];
            int healthPoints = distributedPoints[StatType.Health];
            float baseCritRatePercent = baseStats.baseCritRate / 100f;
            float baseCritDmgPercent = baseStats.baseCritDamage / 100f;
            int critDmgPoints = distributedPoints[StatType.CritMultiplier];

            int critRatePoints = distributedPoints[StatType.CritRate];
            float finalCritRate = baseStats.baseCritRate * (1 + critRatePoints * 0.01f);


            // 최종 능력치 계산
            float finalDamage = baseStats.baseDamage * (1 + attackPoints * 0.01f);
            float finalAttackSpeed = baseStats.baseAttackSpeed * (1 + attackSpeedPoints * 0.01f);
            float finalMoveSpeed = baseStats.baseMoveSpeed * (1 + moveSpeedPoints * 0.01f);
            float finalHealth = baseStats.baseHealth * (1 + healthPoints * 0.02f);
            float finalCritDamage = baseCritDmgPercent * (1 + critDmgPoints * 0.01f);

            // ✨ 실제 분배된 포인트 개수를 UI에 표시
            damageText.text = $"Base Damage ({baseStats.baseDamage:F0}) + Gene Boost ({attackPoints}) = {finalDamage:F2}";
            attackSpeedText.text = $"Base Attack Speed ({baseStats.baseAttackSpeed:F1}) + Gene Boost ({attackSpeedPoints}) = {finalAttackSpeed:F2}";
            moveSpeedText.text = $"Base Move Speed ({baseStats.baseMoveSpeed:F1}) + Gene Boost ({moveSpeedPoints}) = {finalMoveSpeed:F2}";
            healthText.text = $"Base Health ({baseStats.baseHealth:F0}) + Gene Boost ({healthPoints}) = {finalHealth:F2}";
            critRateText.text = $"Base Crit Rate ({baseStats.baseCritRate:F0}%) + Gene Boost ({critRatePoints}) = {finalCritRate:F2}%"; // 포맷을 F2로 변경
            critDamageText.text = $"Base Crit Damage ({baseStats.baseCritDamage:F0}%) + Gene Boost ({critDmgPoints}) = {finalCritDamage * 100:F0}%";
        }
    }
}

--- 파일명: PopupController.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/PopupController.cs) ---
using UnityEngine;
using TMPro;
using UnityEngine.UI;
using System.Collections;
using System; // Action 사용을 위해 필요

/// <summary>
/// 게임 전체에서 사용될 수 있는 범용 팝업 UI를 관리하는 싱글톤 클래스입니다.
/// 간단한 오류 메시지를 일정 시간 동안 보여주거나, 
/// 사용자에게 확인/취소 선택지를 제공하는 확인(Confirm) 팝업을 생성합니다.
/// </summary>
public class PopupController : MonoBehaviour
{
    [Header("오류 팝업 참조")]
    [SerializeField] private GameObject errorPopupPanel; // 오류 메시지 패널
    [SerializeField] private TextMeshProUGUI errorText; // 오류 메시지 텍스트

    [Header("확인 팝업 참조")]
    [SerializeField] private GameObject confirmPopupPanel; // 확인 팝업 패널
    [SerializeField] private TextMeshProUGUI confirmText; // 확인 메시지 텍스트
    [SerializeField] private Button confirmYesButton; // '예' 버튼
    [SerializeField] private Button confirmNoButton; // '아니오' 버튼

    private Action onConfirmYes; // '예' 버튼 클릭 시 실행될 콜백
    private Action onConfirmNo; // '아니오' 버튼 클릭 시 실행될 콜백

    void Awake()
    {
        ServiceLocator.Register<PopupController>(this);
        DontDestroyOnLoad(gameObject);

        // 버튼 리스너 초기화
        confirmYesButton.onClick.AddListener(OnConfirmYesClicked);
        confirmNoButton.onClick.AddListener(OnConfirmNoClicked);

        // 초기에는 모든 팝업을 비활성화
        errorPopupPanel.SetActive(false);
        confirmPopupPanel.SetActive(false);
    }

    /// <summary>
    /// 지정된 시간 동안 오류 메시지 팝업을 표시합니다.
    /// </summary>
    /// <param name="message">표시할 메시지</param>
    /// <param name="duration">표시 시간(초)</param>
    public void ShowError(string message, float duration = 2f)
    {
        errorText.text = message;
        StartCoroutine(ShowErrorRoutine(duration));
    }

    private IEnumerator ShowErrorRoutine(float duration)
    {
        errorPopupPanel.SetActive(true);
        yield return new WaitForSeconds(duration);
        errorPopupPanel.SetActive(false);
    }

    /// <summary>
    /// 확인/취소 버튼이 있는 확인 팝업을 표시합니다.
    /// </summary>
    /// <param name="message">표시할 메시지</param>
    /// <param name="onYes">'예'를 눌렀을 때 실행될 동작</param>
    /// <param name="onNo">'아니오'를 눌렀을 때 실행될 동작 (선택 사항)</param>
    public void ShowConfirm(string message, Action onYes, Action onNo = null)
    {
        confirmText.text = message;
        onConfirmYes = onYes;
        onConfirmNo = onNo;
        confirmPopupPanel.SetActive(true);
    }

    private void OnConfirmYesClicked()
    {
        // '예' 콜백이 있다면 실행
        onConfirmYes?.Invoke();
        confirmPopupPanel.SetActive(false);
    }

    private void OnConfirmNoClicked()
    {
        // '아니오' 콜백이 있다면 실행
        onConfirmNo?.Invoke();
        confirmPopupPanel.SetActive(false);
    }
}


--- 파일명: RewardSceneController.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/RewardSceneController.cs) ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class RewardSceneController : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}


--- 파일명: RouteSelectionController.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/RouteSelectionController.cs) ---
// 파일 경로: Assets/1/Scripts/UI/RouteSelectionController.cs

using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using System.Collections;
using System.Collections.Generic;

/// <summary>
/// 맵 경로 선택 씬의 전체적인 흐름을 제어하는 '조율자(Coordinator)' 클래스입니다.
/// MapManager로부터 맵 데이터를 받아 MapView에 그리도록 지시하고,
/// RewardManager의 상태에 따라 UI 포커스와 버튼 활성화 여부를 결정합니다.
/// </summary>
public class RouteSelectionController : MonoBehaviour
{
    // --- Inspector-Visible Fields --- //
    [Header("제어할 UI 패널")]
    [SerializeField] private GameObject routeSelectPanel;

    [Header("전문 컴포넌트 참조")]
    [SerializeField] private MapView mapView;
    [SerializeField] private AutoFocusScroller autoFocusScroller;

    [Header("포커스 대상 버튼")]
    public Button rewardPageButton;

    // --- Unity Lifecycle Methods --- //
    void Awake()
    {
        ServiceLocator.Register<RouteSelectionController>(this);
    }

    void Start()
    {
        if (routeSelectPanel == null || mapView == null || autoFocusScroller == null)
        {
            Debug.LogError($"[{GetType().Name}] 필요한 UI 컴포넌트가 Inspector에 연결되지 않았습니다!", this.gameObject);
            return;
        }
        mapView.OnNodeSelected += OnNodeClicked;
        routeSelectPanel.SetActive(false); // 시작 시에는 비활성화 상태
    }

    // --- Public Methods --- //

    /// <summary>
    /// 맵 선택 패널을 활성화하고 관련된 모든 UI를 최신 상태로 업데이트합니다.
    /// 다른 UI 관리자(예: CardRewardUIManager)에 의해 호출됩니다.
    /// </summary>
    public void Show()
    {
        Debug.Log($"[{GetType().Name}] Show()가 호출되었습니다. 맵 선택 UI를 활성화합니다.");

        // 맵 뷰를 생성하기 전에, MapManager가 유효한 맵 데이터를 가지고 있는지 다시 확인합니다.
        GenerateMapView();

        routeSelectPanel.SetActive(true);
        UpdateNodeInteractability();
        mapView.SetupAllNodeNavigations(rewardPageButton); // 컨트롤러 네비게이션 설정
        StartCoroutine(SetFocusRoutine()); // 포커스 설정
    }

    /// <summary>
    /// 맵 선택 패널을 비활성화합니다.
    /// </summary>
    public void Hide()
    {
        routeSelectPanel.SetActive(false);
    }

    /// <summary>
    /// '보상 페이지로' 버튼을 클릭했을 때, 다시 카드 보상 UI로 돌아갑니다.
    /// </summary>
    public void GoBackToCardReward()
    {
        Debug.Log($"[{GetType().Name}] '보상 페이지로' 버튼이 클릭되었습니다. 카드 보상 UI로 돌아갑니다.");
        Hide();

        var cardRewardUI = ServiceLocator.Get<CardRewardUIManager>();
        if (cardRewardUI != null)
        {
            cardRewardUI.Show();
        }
    }

    // --- Private Helper Methods --- //

    /// <summary>
    /// MapManager의 데이터를 기반으로 MapView에 맵을 그리도록 지시합니다.
    /// </summary>
    private void GenerateMapView()
    {
        var mapManager = ServiceLocator.Get<MapManager>();

        // [디버깅] 맵이 그려지지 않는 문제의 원인을 찾기 위한 핵심 확인 지점입니다.
        if (mapManager == null || !mapManager.IsMapInitialized)
        {
            Debug.LogError($"[{GetType().Name}] CRITICAL: MapManager를 찾을 수 없거나, 맵 데이터가 초기화되지 않았습니다! (IsMapInitialized: {(mapManager != null ? mapManager.IsMapInitialized.ToString() : "N/A")}). 맵이 그려지지 않을 것입니다.");
            return;
        }

        Debug.Log($"[{GetType().Name}] 유효한 MapManager를 찾았습니다. MapView 생성을 시작합니다.");
        mapView.GenerateMapView(mapManager.AllNodes, mapManager.MapWidth, mapManager.MapHeight);
    }

    /// <summary>
    /// MapView에서 특정 노드가 클릭되었을 때 호출되는 이벤트 핸들러입니다.
    /// </summary>
    // ▼▼▼▼▼ OnNodeClicked 함수를 아래 내용으로 교체 ▼▼▼▼▼
    private void OnNodeClicked(MapNode node)
    {
        // 실제 로직은 코루틴에서 처리하도록 변경
        StartCoroutine(SelectNodeAndPreload(node));
    }

    /// <summary>
    /// 노드 선택 후, 다음 라운드에 필요한 에셋을 프리로드하고 씬을 전환하는 코루틴입니다.
    /// </summary>
    private IEnumerator SelectNodeAndPreload(MapNode node)
    {
        Debug.Log($"[{GetType().Name}] 노드 {node.Position} 선택됨. 다음 라운드 프리로딩을 시작합니다.");

        // 다른 노드를 중복 클릭하는 것을 방지하기 위해 모든 노드 비활성화
        mapView.UpdateNodeInteractability(new List<MapNode>());

        // 필요한 매니저들 가져오기
        var gameManager = ServiceLocator.Get<GameManager>();
        var campaignManager = ServiceLocator.Get<CampaignManager>();
        var mapManager = ServiceLocator.Get<MapManager>();

        // 다음 라운드 데이터 가져오기
        RoundDataSO nextRoundData = campaignManager.GetRoundDataForNode(node);

        // GameManager의 새 프리로더를 호출하고 끝날 때까지 대기
        yield return StartCoroutine(gameManager.PreloadAssetsForRound(nextRoundData, null));

        // 프리로딩이 끝나면 맵 위치를 업데이트하고 씬 전환
        mapManager.MoveToNode(node);
        Hide();
        gameManager.ChangeState(GameManager.GameState.Gameplay);
    }
    // ▲▲▲▲▲ 여기까지 교체 및 추가 ▲▲▲▲▲


    /// <summary>
    /// 현재 플레이어가 이동할 수 있는 노드만 활성화하도록 MapView에 지시합니다.
    /// </summary>
    // ▼▼▼▼▼▼▼▼▼▼▼ [이 함수 전체를 아래 코드로 교체하세요] ▼▼▼▼▼▼▼▼▼▼▼
    private void UpdateNodeInteractability()
    {
        var mapManager = ServiceLocator.Get<MapManager>();
        if (mapManager == null) return;

        List<MapNode> reachableNodes = mapManager.GetReachableNodes();
        mapView.UpdateNodeInteractability(reachableNodes);
    }

    /// <summary>
    /// UI가 활성화된 후, 현재 상황에 맞는 버튼에 자동으로 포커스를 설정하는 코루틴입니다.
    /// </summary>
    private IEnumerator SetFocusRoutine()
    {
        yield return null; // UI가 완전히 활성화될 때까지 한 프레임 대기
        EventSystem.current.SetSelectedGameObject(null);
        GameObject targetObjectToFocus = null;

        // [핵심 로직] RewardManager의 상태를 직접 가져와 '보상 페이지로' 버튼의 활성화 여부를 결정합니다.
        var rewardManager = ServiceLocator.Get<RewardManager>();
        // RewardManager가 없거나, 있더라도 보상 선택이 완료된 상태라면 true가 됩니다.
        bool isRewardSelectionComplete = (rewardManager == null || rewardManager.IsRewardSelectionComplete);

        Debug.Log($"[{GetType().Name}] 포커스 설정 중... RewardManager의 보상 선택 완료 상태: {isRewardSelectionComplete}");

        if (rewardPageButton != null)
        {
            // 보상 선택이 완료되지 않았을 때만 '보상 페이지로' 버튼을 활성화합니다.
            rewardPageButton.gameObject.SetActive(!isRewardSelectionComplete);
        }

        if (isRewardSelectionComplete)
        {
            // 보상 선택이 끝났다면, 선택 가능한 맵 노드 중 가장 왼쪽에 있는 노드에 포커스를 줍니다.
            targetObjectToFocus = mapView.FindLeftmostAvailableNode(ServiceLocator.Get<MapManager>().GetReachableNodes());
            Debug.Log($"[{GetType().Name}] 포커스 대상: 맵 노드 ({(targetObjectToFocus != null ? targetObjectToFocus.name : "없음")})");
        }
        else
        {
            // 아직 보상 선택이 끝나지 않았다면, '보상 페이지로' 버튼에 포커스를 줍니다.
            if (rewardPageButton != null)
            {
                targetObjectToFocus = rewardPageButton.gameObject;
                Debug.Log($"[{GetType().Name}] 포커스 대상: '보상 페이지로' 버튼");
            }
        }

        // 최종적으로 결정된 대상에 포커스를 설정합니다.
        if (targetObjectToFocus != null)
        {
            EventSystem.current.SetSelectedGameObject(targetObjectToFocus);
        }
    }
}

--- 파일명: SynthesisPopup.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/SynthesisPopup.cs) ---
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;
using System;
using TMPro;
using System.Collections; // <-- [1] Coroutine 사용을 위해 추가
using UnityEngine.EventSystems; // <-- [2] EventSystem 사용을 위해 추가

/// <summary>
/// 카드 합성에 사용할 재료를 선택하는 팝업 UI를 제어합니다.
/// </summary>
public class SynthesisPopup : MonoBehaviour
{
    [Header("UI 요소 참조")]
    [SerializeField] private GameObject contentPanel; // 카드들이 표시될 부모 오브젝트
    [SerializeField] private GameObject cardDisplayPrefab; // 재료 카드를 표시할 UI 프리팹 (CardDisplay.cs 포함)
    [SerializeField] private Button confirmButton;
    [SerializeField] private Button cancelButton;
    [SerializeField] private TextMeshProUGUI titleText;

    private Action<CardDataSO> onConfirm; // 확인 시 선택된 카드를 전달할 콜백
    private Action onCancel; // <-- [1] 취소 콜백을 저장할 변수 추가
    private CardDataSO selectedMaterialCard;
    private List<CardDisplay> spawnedCardDisplays = new List<CardDisplay>();

    void Awake()
    {
        confirmButton.onClick.AddListener(OnConfirmClicked);
        cancelButton.onClick.AddListener(OnCancelClicked);
    }

    /// <summary>
    /// 팝업을 초기화하고 재료 카드 목록을 표시합니다.
    /// </summary>
    /// <param name="baseCardName">합성의 기준이 되는 카드 이름</param>
    /// <param name="materialChoices">재료로 사용할 수 있는 카드 목록</param>
    /// <param name="confirmCallback">확인 버튼 클릭 시 실행될 콜백</param>
    public void Initialize(string baseCardName, List<CardDataSO> materialChoices, Action<CardDataSO> confirmCallback, Action onCancelCallback)
    {
        gameObject.SetActive(true);
        onConfirm = confirmCallback;
        onCancel = onCancelCallback; // <-- [3] 전달받은 취소 콜백 저장
        selectedMaterialCard = null;
        UpdateConfirmButton();

        if (titleText != null) titleText.text = $"Select '{baseCardName}' to use as your composite card.";

        // 기존 UI 삭제
        foreach (var display in spawnedCardDisplays) Destroy(display.gameObject);
        spawnedCardDisplays.Clear();
        
        // ▼▼▼▼▼ [3] 포커스 설정을 위한 코루틴을 시작하는 코드 추가 ▼▼▼▼▼
        StartCoroutine(SetInitialPopupFocus());

        // 재료 카드 목록 UI 생성
        foreach (var card in materialChoices)
        {
            GameObject cardUI = Instantiate(cardDisplayPrefab, contentPanel.transform);

            CardDisplay cardDisplay = cardUI.GetComponent<CardDisplay>();
            if (cardDisplay != null)
            {
                cardDisplay.Setup(card);
                // 팝업 내의 카드 클릭 시 OnMaterialCardSelected를 호출하도록 리스너 재설정
                cardDisplay.selectButton.onClick.RemoveAllListeners();
                cardDisplay.selectButton.onClick.AddListener(() => OnMaterialCardSelected(cardDisplay));
                spawnedCardDisplays.Add(cardDisplay);
            }
        }
    }

    /// <summary>
    /// 팝업 내에서 재료 카드가 선택되었을 때 호출됩니다.
    /// </summary>
    private void OnMaterialCardSelected(CardDisplay selectedDisplay)
    {
        selectedMaterialCard = selectedDisplay.GetCurrentCard();

        // 하이라이트 처리
        foreach (var display in spawnedCardDisplays)
        {
            display.SetHighlight(display == selectedDisplay);
        }
        UpdateConfirmButton();
    }

    private void UpdateConfirmButton()
    {
        confirmButton.interactable = (selectedMaterialCard != null);
    }

    private void OnConfirmClicked()
    {
        if (selectedMaterialCard != null)
        {
            onConfirm?.Invoke(selectedMaterialCard);
        }
        gameObject.SetActive(false);
    }

    private void OnCancelClicked()
    {
        onCancel?.Invoke(); // <-- [4] 저장해둔 취소 콜백 실행
        gameObject.SetActive(false);
    }

    // ▼▼▼▼▼ [4] 아래 코루틴 함수 전체를 새로 추가 ▼▼▼▼▼
    /// <summary>
    /// 팝업이 나타난 후, UI 포커스를 팝업 내부의 버튼으로 설정합니다.
    /// </summary>
    private IEnumerator SetInitialPopupFocus()
    {
        // UI 요소들이 완전히 활성화될 시간을 벌기 위해 한 프레임 대기합니다.
        yield return null;

        // EventSystem의 현재 선택된 오브젝트를 null로 초기화하여 이전 포커스를 지웁니다.
        EventSystem.current.SetSelectedGameObject(null);

        // '취소' 버튼이 존재하고 활성화 상태라면, 그곳에 포커스를 맞춥니다.
        if (cancelButton != null && cancelButton.interactable)
        {
            EventSystem.current.SetSelectedGameObject(cancelButton.gameObject);
            Debug.Log("[SynthesisPopup] UI 포커스를 '취소' 버튼으로 설정했습니다.");
        }
    }
}


--- 파일명: UIFeedbackManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/UIFeedbackManager.cs) ---
using UnityEngine;

public class UIFeedbackManager : MonoBehaviour
{
    void OnEnable()
    {
        MonsterController.OnMonsterDamaged += HandleMonsterDamaged;
    }

    void OnDisable()
    {
        MonsterController.OnMonsterDamaged -= HandleMonsterDamaged;
    }

    private void HandleMonsterDamaged(float damageAmount, Vector3 position)
    {

        // DataManager ��� PrefabProvider�� PoolManager�� ���� ����ϴ� ���� �� ȿ�����Դϴ�.
        if (ServiceLocator.Get<PoolManager>() == null || ServiceLocator.Get<PrefabProvider>() == null) return;

        GameObject damageTextPrefab = ServiceLocator.Get<PrefabProvider>().GetPrefab("DamageTextCanvas");
        if (damageTextPrefab == null) return;

        GameObject textGO = ServiceLocator.Get<PoolManager>().Get(damageTextPrefab);
        if (textGO == null) return;

        textGO.transform.position = position + Vector3.up * 0.5f;

        DamageText damageTextComponent = textGO.GetComponent<DamageText>();
        if (damageTextComponent != null)
        {
            damageTextComponent.ShowDamage(damageAmount);
        }
    }
}

--- 파일명: UIManager.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/UIManager.cs) ---
// 파일명: UIManager.cs (리팩토링 완료)
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

/// <summary>
/// 게임 내 UI 패널들을 관리하는 클래스입니다.
/// </summary>
public class UIManager : MonoBehaviour
{
    private Dictionary<string, GameObject> uiPanels = new Dictionary<string, GameObject>();

    void Awake()
    {
        ServiceLocator.Register<UIManager>(this);
        DontDestroyOnLoad(gameObject);
    }

    public void ShowPanel(string panelName, bool isActive)
    {
        if (uiPanels.TryGetValue(panelName, out GameObject panel))
        {
            panel.SetActive(isActive);
            Debug.Log($"UI Panel '{panelName}' set to active: {isActive}");
        }
        else
        {
            Debug.LogWarning($"UI Panel '{panelName}' not found in UIManager.");
        }
    }

    public void ShowPanel(string panelName)
    {
        ShowPanel(panelName, true);
    }

    public void HideAllPanels()
    {
        foreach (var panel in uiPanels.Values)
        {
            panel.SetActive(false);
        }
        Debug.Log("All UI panels hidden.");
    }

    public void RegisterPanel(string panelName, GameObject panelGameObject)
    {
        if (!uiPanels.ContainsKey(panelName))
        {
            uiPanels.Add(panelName, panelGameObject);
            Debug.Log($"UI Panel '{panelName}' registered with UIManager.");
        }
        else
        {
            Debug.LogWarning($"UI Panel '{panelName}' is already registered.");
        }
    }

    public void UnregisterPanel(string panelName)
    {
        if (uiPanels.Remove(panelName))
        {
            Debug.Log($"UI Panel '{panelName}' unregistered from UIManager.");
        }
        else
        {
            Debug.LogWarning($"UI Panel '{panelName}' not found for unregistration.");
        }
    }
}

--- 파일명: UIPanel.cs (경로: /content/drive/MyDrive/Unity/9th/Assets/1.Scripts/UI/UIPanel.cs) ---
using UnityEngine;

/// <summary>
/// UIManager г ڵ ϴ  ũƮԴϴ.
///  ũƮ  UI г Ʈ GameObject ߰ϼ.
/// </summary>
public class UIPanel : MonoBehaviour
{
    // UIManager г ĺ ̸. Inspector մϴ.
    public string panelName;

    void Awake()
    {
        if (string.IsNullOrEmpty(panelName))
        {
            Debug.LogWarning($"UIPanel ũƮ  '{gameObject.name}' Ʈ 'panelName'  ʾҽϴ. GameObject ̸ մϴ.");
            panelName = gameObject.name;
        }

        // --- [] ServiceLocator  UIManager νϽ ɴϴ. ---
        var uiManager = ServiceLocator.Get<UIManager>();
        if (uiManager != null)
        {
            uiManager.RegisterPanel(panelName, gameObject);
        }
    }

    void OnDestroy()
    {
        // --- [] ServiceLocator  UIManager νϽ ɴϴ. ---
        var uiManager = ServiceLocator.Get<UIManager>();
        if (uiManager != null && !string.IsNullOrEmpty(panelName))
        {
            uiManager.UnregisterPanel(panelName);
        }
    }
}